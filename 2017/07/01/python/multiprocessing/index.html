<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="www.lizs.cc"><meta name="keywords" content="lizs, www.lizs.cc, lizs.cc"><title>Python - multiprocessing - lizs</title><!-- link(rel="stylesheet", type="text/css", href="//fonts.neworld.org/css?family=Source+Code+Pro")--><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><!-- #header--><div id="layout" class="layout-g"><div class="layout-r"><div id="sidebar"><div class="site-name"><h1 class="title"><a href="/." class="home">lizs</a></h1><!-- h1.hidden= current_title--><!-- a#logo(href=url_for('.'))= config.title--><p class="description">www.lizs.cc</p></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="www.lizs.cc"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="time">{date}</div><div class="title">{title}</div><!-- .tags {tags}--></a></div></template></div></div><!-- .search-pla--><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#multiprocessing"><span class="toc-text">multiprocessing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#multiprocessing-Process"><span class="toc-text">multiprocessing.Process</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiprocessing-模块其它常用函数"><span class="toc-text">multiprocessing 模块其它常用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程间通信"><span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#multiprocessing-Queue"><span class="toc-text">multiprocessing.Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multiprocessing-Pipe"><span class="toc-text">multiprocessing.Pipe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multiprocessing-Value-typecode-or-type-args-lock-True"><span class="toc-text">multiprocessing.Value(typecode_or_type, *args, lock=True)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multiprocessing-Array-typecode-or-type-size-or-initializer-lock-True"><span class="toc-text">multiprocessing.Array(typecode_or_type, size_or_initializer, *, lock=True)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiprocessing-managers"><span class="toc-text">multiprocessing.managers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#multiprocessing-Manager"><span class="toc-text">multiprocessing.Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multiprocessing-managers-BaseManager-address-authkey"><span class="toc-text">multiprocessing.managers.BaseManager([address[, authkey])</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiprocessing-Pool"><span class="toc-text">multiprocessing.Pool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiprocess-pool-AsyncResult"><span class="toc-text">multiprocess.pool.AsyncResult</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 近期文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/12/01/others/jetbrains_activate/">JetBrains 系列产品激活</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/01/python/abstract_base_classes/">Python - Abstract Base Classes</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/05/linux/centos6.6_upgrade_python2.6/">CentOS6.6 upgrade Python2.6 to Python2.7</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/05/linux/centos6.6_deploy_php_mysql_nginx/">CentOS6.6 install PHP, MySQL and Nginx</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/05/linux/cmd_netstat/">Linux command - netstat</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/03/python/http_server/">Python - HTTP Server</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cordova/">Cordova</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/">TCP/IP</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/cmd/" style="font-size: 15px;">cmd</a> <a href="/tags/cordova/" style="font-size: 15px;">cordova</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/tutorial/" style="font-size: 15px;">tutorial</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/others/" style="font-size: 15px;">others</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/django/" style="font-size: 15px;">django</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li></ul></div><div id="nav-menu"></div></div></div><div class="layout-l"><div class="content_container"><div class="post"><div class="header"><h1 class="post-title">Python - multiprocessing</h1><div class="post-meta"><p><span class="date">2017-07-01</span><span><a href="/categories/Python/" class="category">Python</a></span><span class="view_count"><i id="busuanzi_container_page_pv"><!-- i=  __('hits') + '数: '--><i id="busuanzi_value_page_pv"></i></i></span></p></div></div><div class="post-content"><h1 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h1><p>Python 的 <code>multiprocessing</code> 模块的使用和 <code>threading</code> 类似。</p>
<p><code>multiprocessing</code> 模块包含了很多有用的子模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [</span><br><span class="line">    &apos;Process&apos;, &apos;current_process&apos;, &apos;active_children&apos;, &apos;freeze_support&apos;,</span><br><span class="line">    &apos;Manager&apos;, &apos;Pipe&apos;, &apos;cpu_count&apos;, &apos;log_to_stderr&apos;, &apos;get_logger&apos;,</span><br><span class="line">    &apos;allow_connection_pickling&apos;, &apos;BufferTooShort&apos;, &apos;TimeoutError&apos;,</span><br><span class="line">    &apos;Lock&apos;, &apos;RLock&apos;, &apos;Semaphore&apos;, &apos;BoundedSemaphore&apos;, &apos;Condition&apos;,</span><br><span class="line">    &apos;Event&apos;, &apos;Queue&apos;, &apos;JoinableQueue&apos;, &apos;Pool&apos;, &apos;Value&apos;, &apos;Array&apos;,</span><br><span class="line">    &apos;RawValue&apos;, &apos;RawArray&apos;, &apos;SUBDEBUG&apos;, &apos;SUBWARNING&apos;,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></p>
<h2 id="multiprocessing-Process"><a href="#multiprocessing-Process" class="headerlink" title="multiprocessing.Process"></a>multiprocessing.Process</h2><p>用于创建子进程，<code>Process</code> 对象提供了和<code>threading.Thread</code>类似的使用API。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def __init__(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li><strong>group</strong>:</li>
<li><strong>target</strong>: 进程的执行方法，在 <code>run()</code> 方法内被调用。</li>
<li><strong>name</strong>: 进程名称</li>
<li><strong>args</strong>: 传给进程执行方法 (target) 的参数，默认 <code>()</code>。位置参数和关键字参数都可以传，不过一定要注意顺序，传一个参数的时候要注意 <code>(a,)</code></li>
<li><strong>kwargs</strong>: 传给进程执行方法 (target) 的参数，只能够传关键字参数，默认 <code>{}</code>。</li>
<li><strong>daemon</strong>: Python3.3 新增参数。可以通过 <code>daemon</code> 参数来定义创建的进程是否为 daemon 进程。<br>如果 <code>daemon</code> 为 <code>True</code>，则创建的进程为 daemon 进程，否则，继承创建进程的 <code>daemon</code> 属性。</li>
</ul>
</blockquote>
<ul>
<li><strong>start()</strong><br>启动进程</li>
<li><p><strong>run()</strong><br>进程执行的主要方法，方法里面实际上是调用了 <code>target</code> 参数的函数。所以进程的执行函数可以通过 <code>target</code> 参数传进来给 <code>run()</code>，也可以重写 <code>run()</code> 方法。</p>
</li>
<li><p><strong>join(timeout=None)</strong><br>阻塞当前程序，知道所有进程退出，一个进程可以被 <code>join()</code> 多次。<code>timeout</code>：</p>
<ul>
<li><code>None</code>，会一直阻塞，直到全部被 <code>join()</code> 的进程执行完，才继续执行主体下面的代码。</li>
<li><code>&gt;=0</code> 的 float 时间(seconds)：阻塞一定时间。<code>0</code>，即不阻塞。注意，经测试总阻塞时间为所有进程 <code>timeout</code> 的时间总和。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process_list = [multiprocessing.Process(target=xxx) for _ in range(5)]  # 创建 5 个进程</span><br><span class="line">map(lambda p: p.start(), process_list)  # 启动进程</span><br><span class="line">map(lambda p: p.join(timeout=1), process_list)  # 设置阻塞模式</span><br><span class="line">print(&apos;END&apos;.center(100, &apos;-&apos;))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建进程，并且设置了每个进程阻塞 1s。所以 <code>print(&#39;END&#39;.center(100, &#39;-&#39;))</code> 语句会在全部进程执行完或者 5s 之后才去执行。</p>
</li>
<li><p><strong>name</strong><br>获取或设置进程名称。</p>
</li>
<li><strong>ident</strong><br>进程标识符(pid)，非零整数。如果进程还没有开始，则返回<code>None</code>。</li>
<li><strong>pid</strong><br>即<code>ident</code></li>
<li><strong>exitcode</strong><br>进程的退出状态码。如果子进程还没有退出，则返回<code>None</code>。</li>
<li><strong>authkey</strong><br>获取或设置进程的认证码。</li>
<li><p><strong>daemon</strong><br>获取或设置进程 daemon 属性，设置 daemon 属性要在 <code>start()</code> 之前才会生效。如果不设置，会继承创建进程的程序的 <code>daemon</code> 属性值。如果进程为 daemon 进程，则主程序结束退出的时候，daemon 进程也会结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process_list = [threading.Thread(target=xxx) for _ in range(5)]  # 穿件 5 个进程</span><br><span class="line">map(lambda p: setattr(t, &apos;daemon&apos;, True), process_list)</span><br><span class="line">map(lambda p: p.start(), thread_list)  # 启动进程</span><br><span class="line">time.sleep(5)</span><br><span class="line">exit()</span><br></pre></td></tr></table></figure>
<p>程序创建了 5 个进程，并且都是 daemon 进程。所以，无论进程有没有执行完，主程序执行完 (5s后)，所有进程也会退出。</p>
</li>
</ul>
<p><strong>注意：因为 daemon 进程是会随着主程序的退出而强制结束的，所以，当 daemon 进程的一些操作可能会得不到安全的结束 (如：操作文件的时候)。</strong> <br></p>
<p><strong><code>start()</code>, <code>join()</code>, <code>is_alive()</code>, <code>terminate()</code> 和<code>exitcode</code>只能够在主进程调用。</strong></p>
<ul>
<li><strong>is_alive()</strong><br>返回当前进程是否存活。</li>
<li><strong>terminate()</strong><br>结束进程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_process = multiprocessing.current_process()</span><br><span class="line">current_process.terminate()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因此，<code>multiprocessing</code> 模块创建子进程的方式也是和 <code>threading.Thread</code> 模块一样：</p>
<ul>
<li><p>方法一，通过 <code>multiprocessing.Process</code> 传 <code>target</code> 参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def process_run():</span><br><span class="line">    &quot;&quot;&quot;The sub process mainly run function.&quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line">process = multiprocessing.Process(target=process_run)</span><br><span class="line">process.start()</span><br><span class="line">process.join()</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二，通过继承 <code>multiprocessing.Process</code> 对象，重写 <code>run</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SubProcess(multiprocessing.Process):</span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line">process = SubProcess()</span><br><span class="line">process.start()</span><br><span class="line">process.join()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="multiprocessing-模块其它常用函数"><a href="#multiprocessing-模块其它常用函数" class="headerlink" title="multiprocessing 模块其它常用函数"></a>multiprocessing 模块其它常用函数</h2><ul>
<li><p><strong>multiprocessing.current_thread()</strong><br>返回当前子进程的 <code>Process</code> 对象。</p>
</li>
<li><p><strong>multiprocessing.active_children()</strong><br>返回还没有结束的子进程列表。</p>
</li>
<li><p><strong>multiprocessing.cpu_count()</strong><br>返回当前系统的 CPU 数量。</p>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul>
<li><strong>管道(pipe)</strong>：也叫无名管道，管道是一种半双工通信，数据只能够单方面流动，而且只能够在具有亲缘关系(如：父子进程)的进程间使用。</li>
<li><strong>命名管道(FIFO)</strong>：有名管道也是半双工通信，但是它允许在无亲缘关系的进程间通信。</li>
<li><strong>消息队列(message queue)</strong>：一个消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了管道只能够承载无格式字节流以及缓冲区大小限制等问题。</li>
<li><strong>共享内存(share memory)</strong>：共享内存就是映射一段能被其它进程访问的内存，这个内存由一个进程创建，但是可以被多个进程访问。共享内存是最快的 IPC 方式。</li>
<li><strong>信号(signal)</strong>：通过想向进程发送信号来通知进程要做什么事情。</li>
<li><strong>信号量(semaphore)</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某个进程在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一个进程的不同线程之间的同步手段。</li>
<li><strong>套接字(socket)</strong>：socket 也是一种进程间的通信机制。</li>
</ul>
<blockquote>
<p><a href="https://www.cnblogs.com/LUO77/p/5816326.html" target="_blank" rel="noopener">reference</a></p>
</blockquote>
<p>multiprocessing 模块提供了以下进程间通信的方式:</p>
<h3 id="multiprocessing-Queue"><a href="#multiprocessing-Queue" class="headerlink" title="multiprocessing.Queue"></a>multiprocessing.Queue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def process_run(queue):</span><br><span class="line">    process = multiprocessing.current_process()</span><br><span class="line">    queue.put(process.name)</span><br><span class="line"></span><br><span class="line">q = multiprocessing.Queue()</span><br><span class="line">process = multiprocessing.Process(target=processe_run, args=(q,), name=&apos;sub_process&apos;)</span><br><span class="line">process.daemon = True</span><br><span class="line">process.start()</span><br><span class="line">print(q.get())  # sub_process</span><br></pre></td></tr></table></figure>
<h3 id="multiprocessing-Pipe"><a href="#multiprocessing-Pipe" class="headerlink" title="multiprocessing.Pipe"></a>multiprocessing.Pipe</h3><p><code>Pipe(duplex=True)</code> 会创建一条管道，返回一对<code>multiprocessing.Connection</code>对象 <code>(conn1, conn2)</code> 分别表示管道连接的两端。</p>
<ul>
<li><code>duplex=True</code>: 表示管道是双向的，即 <code>conn1</code> 和 <code>conn2</code> 都可以接收和发送信息。</li>
<li><code>duplex=False</code>: 表示管道是单向的，<code>conn1</code> 只能够接收信息，<code>conn2</code>只能够发送信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def process_run(conn):</span><br><span class="line">    process = multiprocessing.current_process()</span><br><span class="line">    while True:</span><br><span class="line">        msg = conn.recv()</span><br><span class="line">        if msg == &apos;start&apos;:</span><br><span class="line">            conn.send(&apos;%s is starting&apos; % process.name)</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">conn1, conn2 = multiprocessing.Pipe()</span><br><span class="line">process = multiprocessing.Process(target=process_run, args=(conn2,))</span><br><span class="line">process.daemon = True</span><br><span class="line">process.start()</span><br><span class="line">time.sleep(3)</span><br><span class="line">conn1.send(&apos;start&apos;)</span><br><span class="line">conn1.recv()</span><br></pre></td></tr></table></figure>
<h3 id="multiprocessing-Value-typecode-or-type-args-lock-True"><a href="#multiprocessing-Value-typecode-or-type-args-lock-True" class="headerlink" title="multiprocessing.Value(typecode_or_type, *args, lock=True)"></a>multiprocessing.Value(typecode_or_type, *args, lock=True)</h3><p>返回一个共享内存的<code>ctypes</code>对象。<code>multiprocessing.Value()</code>实际上是调用了<code>multiprocessing.sharedctypes.Value()</code>。可以通过<code>value</code>属性来访问共享内存的值。</p>
<ul>
<li><p><code>typecode_or_type</code>: 返回对象的类型。可以是ctypes的类型或特定的类型字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typecode_to_type = &#123;</span><br><span class="line">    &apos;c&apos;: ctypes.c_char,</span><br><span class="line">    &apos;b&apos;: ctypes.c_byte,  &apos;B&apos;: ctypes.c_ubyte,</span><br><span class="line">    &apos;h&apos;: ctypes.c_short, &apos;H&apos;: ctypes.c_ushort,</span><br><span class="line">    &apos;i&apos;: ctypes.c_int,   &apos;I&apos;: ctypes.c_uint,</span><br><span class="line">    &apos;l&apos;: ctypes.c_long,  &apos;L&apos;: ctypes.c_ulong,</span><br><span class="line">    &apos;f&apos;: ctypes.c_float, &apos;d&apos;: ctypes.c_double</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>*args</code>: *args 是传给指定 <code>typecode_or_type</code> 类型的值，可以理解为初始化值。注意，<code>typecode_or_type</code> 的长度，如: <code>c</code> 为一个字节，即只能够传一个字节的字符串<code>Value(&#39;c&#39;, &#39;a&#39;)</code>。</p>
</li>
<li><p><code>lock</code>: keyword-only 参数。默认为<code>True</code>，会自动添加一个递归锁来保护共享内存的读写。如果<code>False</code>，在不添加锁，也可以传一个<code>Lock</code>或<code>Rlock</code>来代替默认的锁。</p>
</li>
</ul>
<h3 id="multiprocessing-Array-typecode-or-type-size-or-initializer-lock-True"><a href="#multiprocessing-Array-typecode-or-type-size-or-initializer-lock-True" class="headerlink" title="multiprocessing.Array(typecode_or_type, size_or_initializer, *, lock=True)"></a>multiprocessing.Array(typecode_or_type, size_or_initializer, *, lock=True)</h3><p><code>Array</code> 实际上调用的是 <code>multiprocessing.sharedctypes.Array</code>，用法类似 <code>Value</code>，只不过<code>Value</code>只能够保存一个相应的类型的值，而<code>Array</code>则可以保存一个数组相应类型的值。</p>
<ul>
<li><code>typecode_or_type</code>: 同<code>Value</code>。</li>
<li><code>size_or_initializer</code>: 初始化共享内存数组的值或指定该数组的大小。如果为整数时，则指定数组的大小，同时各个元素初始化的值为0；当为序列时，则代表初始化的值，并且该序列的长度为共享数组的长度。</li>
<li><code>lock</code>: 同<code>Value</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def process_run(mv, ma):</span><br><span class="line">    print(mv.value)</span><br><span class="line">    mv.value = 1</span><br><span class="line">    for i in range(len(ma)):</span><br><span class="line">        print(ma[i])</span><br><span class="line">        ma[i] = i</span><br><span class="line"></span><br><span class="line">mv = multiprocessing.Value(&apos;i&apos;, 0)</span><br><span class="line">ma = multiprocessing.Array(&apos;i&apos;, 10)</span><br><span class="line">process = multiprocessing.Process(target=process_run, args=(mv, ma))</span><br><span class="line">process.start()</span><br><span class="line">process.join()</span><br><span class="line">print(mv.value)</span><br><span class="line">print(&#123;i: ma[i] for in in range(len(ma))&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="multiprocessing-managers"><a href="#multiprocessing-managers" class="headerlink" title="multiprocessing.managers"></a>multiprocessing.managers</h2><p>通过multiprocessing木块的managers对象创建的数据可以在进程间共享，甚至可以和不同网络的不同机器上面的进程共享。<br></p>
<h3 id="multiprocessing-Manager"><a href="#multiprocessing-Manager" class="headerlink" title="multiprocessing.Manager"></a>multiprocessing.Manager</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def Manager():</span><br><span class="line">    from multiprocessing.managers import SyncManager</span><br><span class="line">    m = SyncManager()</span><br><span class="line">    m.start()</span><br><span class="line">    return m</span><br></pre></td></tr></table></figure>
<p>multiprocessing.Manager 返回一个 <code>SyncManager</code> 实例对象，用于创建已注册类型的共享数据(<code>Queue</code>, <code>list</code>, <code>dict</code> 等)。<br><br>默认注册的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SyncManager.register(&apos;Queue&apos;, Queue.Queue)</span><br><span class="line">SyncManager.register(&apos;JoinableQueue&apos;, Queue.Queue)</span><br><span class="line">SyncManager.register(&apos;Event&apos;, threading.Event, EventProxy)</span><br><span class="line">SyncManager.register(&apos;Lock&apos;, threading.Lock, AcquirerProxy)</span><br><span class="line">SyncManager.register(&apos;RLock&apos;, threading.RLock, AcquirerProxy)</span><br><span class="line">SyncManager.register(&apos;Semaphore&apos;, threading.Semaphore, AcquirerProxy)</span><br><span class="line">SyncManager.register(&apos;BoundedSemaphore&apos;, threading.BoundedSemaphore,</span><br><span class="line">                     AcquirerProxy)</span><br><span class="line">SyncManager.register(&apos;Condition&apos;, threading.Condition, ConditionProxy)</span><br><span class="line">SyncManager.register(&apos;Pool&apos;, Pool, PoolProxy)</span><br><span class="line">SyncManager.register(&apos;list&apos;, list, ListProxy)</span><br><span class="line">SyncManager.register(&apos;dict&apos;, dict, DictProxy)</span><br><span class="line">SyncManager.register(&apos;Value&apos;, Value, ValueProxy)</span><br><span class="line">SyncManager.register(&apos;Array&apos;, Array, ArrayProxy)</span><br><span class="line">SyncManager.register(&apos;Namespace&apos;, Namespace, NamespaceProxy)</span><br><span class="line"></span><br><span class="line"># types returned by methods of PoolProxy</span><br><span class="line">SyncManager.register(&apos;Iterator&apos;, proxytype=IteratorProxy, create_method=False)</span><br><span class="line">SyncManager.register(&apos;AsyncResult&apos;, create_method=False)</span><br></pre></td></tr></table></figure></p>
<p>简单例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def process_run(l, d):</span><br><span class="line">    p = multiprocessing.current_process()</span><br><span class="line">    l.append(p.name)</span><br><span class="line">    d[p.pid] = p.name</span><br><span class="line"></span><br><span class="line">m = multiprocessing.Manager()</span><br><span class="line">l, d = m.list(), m.dict()</span><br><span class="line">process = multiprocessing.Process(target=Process_run, args=(l, d))</span><br><span class="line">process.start()</span><br><span class="line">process.join()</span><br><span class="line">print(l)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure></p>
<h3 id="multiprocessing-managers-BaseManager-address-authkey"><a href="#multiprocessing-managers-BaseManager-address-authkey" class="headerlink" title="multiprocessing.managers.BaseManager([address[, authkey])"></a>multiprocessing.managers.BaseManager([address[, authkey])</h3><p>Manager 的基类。</p>
<ul>
<li><p><code>address</code>: 同参数<code>address</code></p>
</li>
<li><p><code>start([initializer[, initargs])</code> <br><br>启动一个子进程来开启Manager。如果<code>initializer</code>不为空并且为可执行的对象创建子进程时会调用<code>initializer(*initargs)</code>。</p>
</li>
<li><p><code>connect()</code> <br><br>连接Manager，一般用于客户端进程。</p>
</li>
<li><p><code>register(ypeid[, callable[, proxytype[, exposed[, method_to_typeid[, create_method]]]]])</code> <br><br>注册一个自定义类型或可执行对象。</p>
</li>
<li><p><code>get_server()</code><br><br>返回Manager的Server对象。Sever对象支持<code>serve_forever()</code>。</p>
</li>
<li><p><code>shutdown()</code><br><br>关闭启动Manager的进程，<code>start()</code>之后才有意义，可以多次调用<code>stop()</code>。</p>
</li>
</ul>
<p>自定义Manager，注册共享的方法，并在网络端口上暴露：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line">from Queue import Queue</span><br><span class="line"></span><br><span class="line">class QueueManager(BaseManager): pass</span><br><span class="line">QueueManager.register(&apos;get_queue&apos;, lambda:Queue())</span><br><span class="line">qm = QueueManager(address=(&apos;&apos;, 50000), authkey=&apos;queue_manager&apos;)</span><br><span class="line">qm.get_server().serve_forever()</span><br></pre></td></tr></table></figure></p>
<p>首先定义自定义一个Manager，然后注册要使用的属性或方法。注意，<code>register()</code> 是类方法，并且第二个参数是可调用对象，所以传<code>Queue()</code>而不是<code>Queue</code></p>
<p>其它进程访问，可以是本地也可以是不同网络的进程。client1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line"></span><br><span class="line">class QueueManager(BaseManager): pass</span><br><span class="line">QueueManager.register(&apos;get_queue&apos;)</span><br><span class="line">qm = QueueManager(address=(&apos;xxxx&apos;, 50000), authkey=&apos;queue_manager&apos;)</span><br><span class="line">qm.connect()</span><br><span class="line">q = qm.get_queue()</span><br><span class="line">q.put(&apos;hello&apos;)</span><br></pre></td></tr></table></figure></p>
<p>client2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line"></span><br><span class="line">class QueueManager(BaseManager): pass</span><br><span class="line">QueueManager.register(&apos;get_queue&apos;)</span><br><span class="line">qm = QueueManager(address=(&apos;xxxx&apos;, 50000), authkey=&apos;queue_manager&apos;)</span><br><span class="line">qm.connect()</span><br><span class="line">q = qm.get_queue()</span><br><span class="line">q.get()  # &apos;hello&apos;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<hr>
<h2 id="multiprocessing-Pool"><a href="#multiprocessing-Pool" class="headerlink" title="multiprocessing.Pool"></a>multiprocessing.Pool</h2><p>进程池。<code>Poll(processes=None, initializer=None, initargs=(), maxtasksperchild=None)</code>:</p>
<blockquote>
</blockquote>
<ul>
<li><code>processes</code>: 进程数，如果为<code>None</code>, 则去<code>os.cpu_count()/multiprocessing.cpu_count()</code>的值。</li>
<li><code>initializer</code>/<code>initargs</code>: 如果<code>initializer</code>不为<code>None</code>, 则进程池的所有进程在启动的时候都会执行<code>initializer(*initargs)</code>。</li>
<li><p><code>maxtasksperchild</code>:</p>
</li>
<li><p><code>apply(func[, *args[, **kwargs]])</code><br>进程池里面的一个进程会执行<code>func(*args, **kwargs)</code>，并且<code>apply</code>会阻塞主进程直到执行完毕。用法同python2的<code>apply(*args, **kwargs)</code>，<code>*args</code>必须为sequence，<code>**kwargs</code>必须为字典。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def process_run(x, y=None):</span><br><span class="line">    return pow(x, y or x)</span><br><span class="line"></span><br><span class="line">pools = multiprocessing.Pool(5)</span><br><span class="line">result = pools.apply(process_run, (2,), &#123;&apos;y&apos;: 3&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>apply_async(func[, *args[, **kwargs[, callback[, error_callback]]]])</code> <br><br>类似<code>apply</code>，不过<code>apply_async</code>是异步进行的，不会阻塞主进程，并且返回 <code>multiprocessing.pool.AsyncResult</code> 对象。</p>
<ul>
<li><code>callback</code>: 可传入一个参数的可调用对象，当<code>func(*args, **kwargs)</code>执行完毕有结果的时候，传入执行结果来调用。</li>
<li><code>error_callback</code>: 可以传入一个参数的可调用对象，当<code>func(*args, **kwargs)</code>执行出错的时候，传入Exception实例来调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def process_run(x, y=None):</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    return pow(x, y or x)</span><br><span class="line"></span><br><span class="line">def callback(x):</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line">pools = multiprocessing.Pool(5)</span><br><span class="line"># no block, but the result is a multiprocessing.pool.AsyncResult object</span><br><span class="line">result = pools.apply_async(process_run, (x,), &#123;&apos;y&apos;: 3&#125;, callback=callback)</span><br><span class="line"># wait until the result is available or until timeout seconds pass.</span><br><span class="line">result.wait(10)</span><br><span class="line"># get the result value</span><br><span class="line">result.get()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>map(func, iterable[, chunksize])</code> <br><br>相当于并行的内置函数<code>map()</code>，<code>iterable</code>的每一个元素都会作为参数传给<code>func</code>，然后进程池分别调用进程去执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def process_run(x, y):</span><br><span class="line">    return pow(x, y)</span><br><span class="line"></span><br><span class="line">pools = multiprocessing.Pool(5)</span><br><span class="line">result = pools.map(process_run, zip(range(10), range(10)))</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>map_async(func, iterable[, chunksize[, callback[, error_callback]]])</code><br>类似<code>map</code>，不过<code>map_async</code>是异步进行，不会阻塞主进程，并且返回 <code>multiprocessing.pool.AsyncResult</code> 对象。</p>
</li>
</ul>
<p><code>callback</code>和<code>error_callback</code>的用同<code>apply_async</code>。</p>
<blockquote>
<p>Python2.7在类里面使用<code>apply()</code>,<code>map()</code>会出现bug：<a href="https://stackoverflow.com/questions/1816958/cant-pickle-type-instancemethod-when-using-multiprocessing-pool-map" target="_blank" rel="noopener">cPickle.PicklingError: Can’t pickle <type 'function'="">: attribute lookup <strong>builtin</strong>.function failed</type></a></p>
</blockquote>
<h2 id="multiprocess-pool-AsyncResult"><a href="#multiprocess-pool-AsyncResult" class="headerlink" title="multiprocess.pool.AsyncResult"></a>multiprocess.pool.AsyncResult</h2><p>进程池异步调用返回结果，即由<code>apply_async</code>和<code>map_async</code>调用的返回结果。</p>
<ul>
<li><p><code>get([timeout])</code>: 获取返回结果。</p>
<ul>
<li><code>timeout</code>为<code>None</code>: 默认，会阻塞到有执行结果返回。</li>
<li><code>timeout</code>不为<code>None</code>：设置阻塞的秒数，当超时还没有结果返回时，会引起 <code>multiprocessing.TimeoutError</code>。</li>
</ul>
<p>当异步执行出错时，exception 也会由<code>get</code>引起。</p>
</li>
<li><p><code>wait([timeout])</code>: 等待，直到有执行结果返回或超过超时时间。</p>
</li>
<li><code>ready()</code>: True/False，返回调用是否执行完毕。</li>
<li><code>successful()</code>: 当调用程序执行完毕时，返回执行有没有出错(True/False)；当调用程序没有执行完毕时，会引起<code>AssertionError</code>。</li>
</ul>
</div><div class="tags"><a href="/tags/python/">python</a></div><div class="post-nav"><a href="/2017/07/01/linux/cmd_find/" class="pre">linux command - find</a><a href="/2017/06/01/python/threading/" class="next">Python - threading</a></div></div><!-- include _partial/footer--></div></div></div><a id="totop" href="#top"></a></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script></body></html>