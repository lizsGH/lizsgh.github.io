{"meta":{"title":"lizs","subtitle":"www.lizs.cc","description":"www.lizs.cc","author":"lizs","url":"https://lizsgh.github.io"},"pages":[],"posts":[{"title":"Python - Abstract Base Classes","slug":"python/abstract_base_classes","date":"2018-04-30T16:00:00.000Z","updated":"2019-02-25T12:00:35.899Z","comments":true,"path":"2018/05/01/python/abstract_base_classes/","link":"","permalink":"https://lizsgh.github.io/2018/05/01/python/abstract_base_classes/","excerpt":"","text":"Python 中没有接口的正式语法支持，但是 Python 有抽象类的概念。抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化。如果说类是从一堆对象中抽取相同的内容而来的，那么抽象类就是从一堆类中抽取相同的内容而来的，内容包括数据属性和函数属性。 抽象是为了继承，接口继承实质上是要求，“做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象”。这在程序设计上，叫做归一化。即基于同一个接口实现的类，这些类产生的对象在使用时，用法一样。 抽象类的一些特性： 抽象类不能被实例化。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 在继承抽象类的过程中，应该尽量避免多继承；而在继承接口的时候，反而使用多继承。(接口隔离原则) Python 中实现抽象类，需要使用 abc 模块。Python 3+123456789101112131415from abc import ABCMeta, abstractmethodclass People(metaclass=ABCMeta): @abstractmethod def name(self): passclass Teacher(People): @property def name(self): return 'lizs'People()TypeError: Can't instantiate abstract class People with abstract methods nameTeacher().name # lizs Python 2.7123456789class People(object): __metaclass__ = ABCMeta @abstractmethod def name(self): passPeople()TypeError: Can't instantiate abstract class People with abstract methods name 为了兼容 Python 2 和 Python 3，使用six模块。12345678910from abc import ABCMetaimport six@six.add_metaclass(ABCMeta)class People(object): def name(self): passPeople()TypeError: Can't instantiate abstract class People with abstract methods name","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"CentOS6.6 install PHP, MySQL and Nginx","slug":"linux/centos6.6_deploy_php_mysql_nginx","date":"2018-03-04T16:00:00.000Z","updated":"2019-02-26T08:05:11.077Z","comments":true,"path":"2018/03/05/linux/centos6.6_deploy_php_mysql_nginx/","link":"","permalink":"https://lizsgh.github.io/2018/03/05/linux/centos6.6_deploy_php_mysql_nginx/","excerpt":"","text":"PHP5.6 CentOS 默认的 yum 源安装的 PHP 版本过低，又想通过 yum 来安装 PHP5.6。 查看系统上是否安装了 PHP，有就删除。 1234查看系统是否安装了 PHPyum list installed | grep php# 删除PHP相关的模块yum remove phpxxx 添加 EPEL 和 REMI 源 12rpm -Uvh http://ftp.iij.ad.jp/pub/linux/fedora/epel/6/x86_64/epel-release-6-8.noarch.rpmrpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm 查看 yum 源是否有 PHP5.6 及相关库 1yum list --enablerepo=remi --enablerepo=remi-php56 | grep php 添加 REMI 源成功之后，安装 PHP5.6 及相关库 1yum install --enablerepo=remi --enablerepo=remi-php56 php-fpm php-opcache php-devel php-mbstring php-mcrypt php-mysqlnd Nginx 添加 nginx 的 yum 源 12wget http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpmrpm -ivh nginx-release-centos-6-0.el6.ngx.noarch.rpm 或者直接添加 /etc/yum.repos.d/nginx.repo 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/6/$basearch/gpgcheck=0enabled=1 安装 nginx 1yum install -y nginx MySQL 删除系统中旧版本的MySQL 1234# 检测到系统中有 mysql-libs-5.1.73-3.el6_5.x86_64rpm -qa | grep mysql# 删除旧版本MySQL包和相关的依赖rpm -e --nodeps mysql-libs-5.1.73-3.el6_5.x86_64 添加 MySQL 的 yum 源。到 https://dev.mysql.com/downloads/repo/yum/ 下载相应的 RPM 包，如：mysql57-community-release-el6-11.noarch.rpm 12wget https://repo.mysql.com//mysql57-community-release-el6-11.noarch.rpmrpm -Uvh mysql57-community-release-el6-11.noarch.rpm 安装 MySQL 1yum install mysql-community-server 更多信息可以参考：A Quick Guide to Using the MySQL Yum Repository MariaDB 添加 yum 源到 Setting up MariaDB Repositories 生成相应 的 yum 源，然后添加到 /etc/yum.repos.d/mariadb.repo 12345[mariadb] name = MariaDB baseurl = http://yum.mariadb.org/10.2/centos6-amd64 gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB gpgcheck=1 安装 MariaDB 1yum install -y MariaDB-server MariaDB-client MariaDB-devel 用官方源下载在没有翻墙的情况下是很慢的，可以用中国科学技术大学的镜像，不过也很不稳定。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"CentOS6.6 upgrade Python2.6 to Python2.7","slug":"linux/centos6.6_upgrade_python2.6","date":"2018-03-04T16:00:00.000Z","updated":"2019-02-26T12:21:34.287Z","comments":true,"path":"2018/03/05/linux/centos6.6_upgrade_python2.6/","link":"","permalink":"https://lizsgh.github.io/2018/03/05/linux/centos6.6_upgrade_python2.6/","excerpt":"","text":"CentOS6.6 系统自带的 Python 版本是 Python2.6，但项目需要 Python2.7。 升级 Python2.6 到 Python2.7 下载 Python源码包 12curl https://www.python.org/ftp/python/2.7.13/Python-2.7.13.tgz &gt; Python-2.7.13.tgztar -zxvf Python-2.7.13.tgz -C /opt/ 安装 Python 123cd /opt/Python-2.7.13./configuremake &amp;&amp; make install 默认安装在 /usr/loca/python2.7 目录下，也可以通过参数配置来指定安装路径 ./configure --prefix=/path/to/install/python。 安装完之后，系统默认的 Python 版本还是 Python2.6 的，需要修改： 12rm -f /usr/bin/pythonln -s /usr/local/bin/python /usr/bin/python 修改完之后，发现 yum 工具用不了了，因为 yum 工具是基于 Python2.6 的。将 /usr/bin/yum 的头部 #!/usr/bin/python 改为 #!/usr/bin/python2.6。 安装 pip123cd /opt/curl https://bootstrap.pypa.io/get-pip.py &gt; get-pip.pypython get-pip.py 如果出现错误： zipimport.ZipImportError: can’t decompress data; zlib not available 是因为系统缺少了 zlib 和 zlib-devel 库。 1yum install -y zlib zlib-devel 安装成功之后，需要重新编译 Python： 1234cd /opt/Python-2.7.13/make clean &amp;&amp; make &amp;&amp; make install# 重新编译完成之后再试一次安装 pippython get-pip.py 如果接着出现错误： Could not fetch URL https://pypi.python.org/simple/pip/: There was a problem confirming the ssl certificate: Can’t connect to HTTPS URL because the SSL module is not available. - skipping 是因为系统缺少 openssl-devel。 1yum install -y openssl-devel 安装成功之后，需要重新编译 Python： 1234cd /opt/Python-2.7.13/make clean &amp;&amp; make &amp;&amp; make install# 重新编译完成之后再试一次安装 pippython get-pip.py 到这里，我就成功安装了 pip。 总结 update.sh123456789101112131415161718192021#!/bin/shset -e# 先安装需要的库：yum install -y gcc zlib zlib-devel openssl-devel# 下载 Python2.7 的源包curl https://www.python.org/ftp/python/2.7.13/Python-2.7.13.tgz &gt; Python-2.7.13.tgztar -zxvf Python-2.7.13.tgz -C /opt/# 安装 Pythoncd /opt/Python-2.7.13./configuremake &amp;&amp; make install# 修改系统默认的 Python 版本rm -f /usr/bin/pythonln -s /usr/local/bin/python /usr/bin/python# 将 `/usr/bin/yum` 的头部 `#!/usr/bin/python` 改为 `#!/usr/bin/python2.6`sed -i &apos;1c #!/usr/bin/python2.6&apos; /usr/bin/yum# 接着安装 pipcd /opt/curl https://bootstrap.pypa.io/get-pip.py &gt; get-pip.pypython get-pip.py","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Linux command - netstat","slug":"linux/cmd_netstat","date":"2018-01-04T16:00:00.000Z","updated":"2019-02-26T07:35:11.032Z","comments":true,"path":"2018/01/05/linux/cmd_netstat/","link":"","permalink":"https://lizsgh.github.io/2018/01/05/linux/cmd_netstat/","excerpt":"","text":"nestat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships. 1netstat [options] netstat 常见用法： (none): By default, netstat displays a list of open sockets. -a, --all: Show both listening and non-listening sockets. -l, --listening: Show only listening sockets. (these are omitted by default.) -t, --tcp: 显示 TCP 协议连接的 socket。 -u, --udp: 显示 UDP 协议连接的 socket。 -n, --numeric: 显示数字形式的地址，而不用解析主机、端口和用户名。 -p, --program: 显示 socket 连接程序的 PID 和名称。 -c, --continuous: 每秒钟打印一次输出结果。 -s, --statistics: Display summary statistics for each protocol. 显示每种协议收发数据包的统计结果。 -g, --groups: Display multicast group membership information for IPv4 and IPv6. 显示 IPv4 和 IPv6 的 IGMP 组播组成员关系信息。 -i, --interfaces: Display a table of all network interfaces. 显示网络接口信息。 -r, --route: Display the kernel routing tables. 显示内核路由表信息。 -M, --masquerade: Display a list of masqueraded connections. -A, --protocol: 指定要显示哪些的地址族的连接，多个协议用逗号分隔。常见地址族，如：inet, inet6, unix, ipx, ax25, netrom, econet, ddp, bluetooth。也可以作为参数使用: –inet|-4, –inet6|-6, –unix|-x, –ipx, –ax25, –netrom, –ddp, –bluetooth。 输出结果： Proto: 协议 Recv-Q: 此 socket 连接的应用程序未拷贝的字节数。 Send-Q: 远程主机未确认的字节数。 Local Address: socket 连接的本地地址信息 (本地主机名和端口)。 Foreign Address: socket 连接的远程地址信息 (远程主机名和端口)。 State: socket 状态 (ESTABLISHED, SYN_SENT, SYN_RECV, FIN_WAIT1, FIN_WAIT2, TIME_WAIT, CLOSED, CLOSE_WAIT, LAST_ACK, LISTEN, CLOSING, UNKNOWN)。 User: The username or the user id (UID) of the owner of the socket. PID/Program_name: socket 连接的所属应用程序的 PID 和程序名称。 等等 1234567891011121314151617181920# 显示连接状态的 socketnetstat# 显示所有 socketnetstat -a# 显示监听状态的 socketnetstat -l# 显示 TCP 协议并且在监听状态的 IPv6 连接netstat -tl6# 禁用反向域名解析，显示数字形式的地址netstat -n# 显示 UDP 协议监听中的 socket 连接，并显示数字形式的地址和用户名、PIDnetstat -ulnp# 显示内核路由表netstat -r# 每秒刷新显示内核路由表信息netstat -rc# 显示特定地址族的 socketnetstat -lA inet # 显示听中的 IPv4 连接netstat -l --protocol=inet6 # 显示监听中的 IPv6 连接netstat -A inet6,ddp 注意当 netstat -p显示的程序信息看不到的时候 (如-)，可能是权限问题。使用 sudo 提权或切换 root 用户执行命令。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"cmd","slug":"cmd","permalink":"https://lizsgh.github.io/tags/cmd/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Python - HTTP Server","slug":"python/http_server","date":"2018-01-02T16:00:00.000Z","updated":"2019-02-26T07:06:39.492Z","comments":true,"path":"2018/01/03/python/http_server/","link":"","permalink":"https://lizsgh.github.io/2018/01/03/python/http_server/","excerpt":"","text":"BaseHTTPServer/http.server Python2.7: BaseHTTPServer Python3+: http.server http.server 模块提供了创建 HTTP 服务器的简略接口。 http.server.HTTPServer123456789class HTTPServer(socketserver.TCPServer): allow_reuse_address = 1 def server_bind(self): socket.TCPServer.server_bind(self) host, port = self.socket.getsockname()[:2] self.server_name = socket.getfqdn(host) self.server_port = port 可以看到，HTTPServer 实际上就是 socketserver.TCPServer 的一个子类。所以，HTTPServer 的使用和 TCPServer 是相似的，通过 Handler 类来处理请求。 http.server 模块提供的一个处理 HTTP 请求的 Handler 基类 BaseHTTPRequestHandler。 同样，也可以继承 socketserver.ThreadingMixin 或 socketserver.ForkingMixin 来处理请求。 http.server.BaseHTTPRequestHandlerBaseHTTPRequestHandler 和其它 Handler 类一样都是，通过 handler() 方法来处理请求。BaseHTTPRequestHandler 的 handle() 调用了另外一个自定义的方法 handle_one_request() 来处理请求。 handle_one_request() 中将请求的的数据通过 parse_request() 方法解析: self.command: string，请求方法，如 HEAD, GET, etc. self.path: string，请求方法之后的请求路径, 如 /。 self.request_version: string, 请求使用的 HTTP 协议版本，如 HTTP/1.1。 self.headers: mimetools.Message(rfc822.Message) 的一个实例。常用方法/属性： headers: list, 请求头部信息列表。注意，每个信息是带换行符号的字符串。 dict: dict, 请求头部信息字典。 items(): list, 请求头部信息列表，不过每个信息是一个 (key, value) 的二元组 get(name, default=None): string, 获取 headers 信息中 name 属性的值，没有就返回 default 的值。实际上，self.headers.get(name, default=None) 最终是调用 self.headers.dict.get(name.lower(), default)1234self.headers.headers # [&apos;Host: localhost\\r\\n&apos;, &apos;Accept: text/html\\r\\n&apos;]self.headers.dict # &#123;&apos;host&apos;: &apos;localhost&apos;, &apos;accept&apos;: &apos;text/html&apos;&#125;self.headers.items() # [(&apos;host&apos;, &apos;localhost&apos;), (&apos;accept&apos;, &apos;text/html&apos;)]self.headers.get(&apos;host&apos;) # localhost handle_one_request() 通过调用 parse_request() 方法解析出需要的信息之后，会执行以下代码：123456mname = &apos;do_&apos; + self.commandif not hasattr(self, mname): self.send_error(501, &quot;Unsupported method (%r)&quot; % self.command) returnmethod = getattr(self, mname)method() 也就是说，如果请求的方法为 HEAD，Handler 类最终会调用一个名为 do_HEAD() 的方法。这个方法在 BaseHTTPRequestHandler 是没有定义的，需要在子类去创建，然后通过该方法来处理请求。 socketserver 模块的 Handler 是通过子类的 handle() 处理请求，BaseHTTPServer/http.server 的子类是通过一个名为 do_xx 的方法来处理请求(xx为请求方法) Handler 类实例其它常用属性： self.client_address: tuple，客户端的地址 (host, port)，继承自 socketserver.StreamRequestHandler。 self.server: Server 类实例，继承自 socketserver.StreamRequestHandler。 self.close_connection: Boolean，是否关闭当前的连接。True/1，关闭连接；False/0，保持连接。 self.rfile: 继承自 socketserver.StreamRequestHandler， io.BufferedIOBase 输入流对象。 self.wfile: 继承自 socketserver.StreamRequestHandler， 输出流对象。 Handler 类属性： server_version: string, 服务器版本号，主要用于调用 send_response() 方法的时候返回头部信息中 Server 的值。 sys_version: string, Python 版本，主要用于调用 send_response() 方法的时候返回头部信息中 Server 的值。 protocol_version: string, HTTP 版本，默认为 HTTP/1.0。HTTP/1.1 会自动保持连接不关闭。 responses: dict, HTTP 返回状态码和相应的信息， {100: (&#39;Continue&#39;, &#39;Request received, please continue&#39;), ...}。 Handler 类常用方法： address_string(): 返回客户端地址。 123def address_string(self): host, port = self.client_address[:2] return socket.getfqdn(host) version_string(): 服务器的版本信息，主要用于 send_response() 方法中返回头部信息 Server 的值。 12def version_string(self): return self.server_version + &apos; &apos; + self.sys_version send_response(code, message=None)，返回信息给客户端。 123456789101112self.log_request(code)if message is None: if code in self.responses: message = self.responses[code][0] else: message = &apos;&apos;if self.request_version != &apos;HTTP/0.9&apos;: self.wfile.write(&quot;%s %d %s\\r\\n&quot; % (self.protocol_version, code, message)) # print (self.protocol_version, code, message)self.send_header(&apos;Server&apos;, self.version_string())self.send_header(&apos;Date&apos;, self.date_time_string()) code: 请求返回状态码，e.g. 200, 404, etc. message: 返回状态信息，e.g. ok -&gt; HTTP/1.1 200 ok.默认情况下，调用这个方法返回状态信息，还附带返回了头部信息中的 Server 和 Data 信息。 send_header(): 返回头部信息。 123456789def send_header(self, keyword, value): if self.request_version != &apos;HTTP/0.9&apos;: self.wfile.write(&quot;%s: %s\\r\\n&quot; % (keyword, value)) if keyword.lower() == &apos;connection&apos;: if value.lower() == &apos;close&apos;: self.close_connection = 1 elif value.lower() == &apos;keep-alive&apos;: self.close_connection = 0 返回头部信息，如果返回信息中有 Connection 属性，会根据 value 的值自动关闭或保持连接。 end_headers(): 结束头部信息。HTTP 协议规定返回信息中头部和主体要用 \\r\\n 或 \\n 分开。 123def end_headers(self): if self.request_version != &apos;HTTP/0.9&apos;: self.wfile.write(&quot;\\r\\n&quot;) BaseHTTPServer/http.server 实现 HTTP 服务器首先，定义 BaseHTTPRequestHandler 子类:12345678910111213141516171819202122232425class HTTPHandler(BaseHTTPServer.BaseHTTPRequestHandler): def version_string(self): return &apos;nginx/1.13.1&apos; def send_body(self): self.wfile.write(&apos;&lt;div&gt;hello world!&lt;/div&gt;&apos;) self.wfile.write(&quot;\\r\\n&quot;) def do_HEAD(self): if self.path != &apos;/&apos;: self.send_error(404) return False self.send_response(200, &apos;hi~&apos;) self.send_header(&apos;Connect-Type&apos;, &apos;text/html&apos;) # HTTP/1.0 keep-alive if self.headers.get(&apos;connection&apos;) == &apos;keep-alive&apos;: self.send_header(&apos;connection&apos;, &apos;keep-alive&apos;) self.end_headers() self.send_body()if __name__ == &apos;__main__&apos;: server = HTTPServer((&apos;localhost&apos;, 8080), HTTPHandler) server.serve_forever() 上面例子中 do_HEAD 方法会处理 HTTP HEAD 方法的请求。如请求数据为：12HEAD / HTTP/1.1Host: localhost 返回数据为：123456HTTP/1.0 200 hi~Server: nginx/1.13.1Date: Sun, 11 Feb 2018 08:55:09 GMTConnect-Type: text/html&lt;div&gt;hello world!&lt;/div&gt; SimpleHTTPServer/http.server Python2.7: SimpleHTTPServer Python3+: http.server Python3 以后，将 Python2 的 SimpleHTTPServer 模块合并到了 http.server 中。 SimpleHTTPServer 模块主要提供了一个 HTTP 协议的简单实现 Handler：SimpleHTTPRequestHandler。 SimpleHTTPRequestHandler 实现了 HTTP 的 HEAD 和 GET 请求方法： do_HEAD() 和 do_GET()。 do_GET() 会根据请求路径对服务器当前目录下的文件进行访问，默认主页为 index.html 或 index.htm 简单 HTTP 服务器实现12345from http.server import HTTPServer, SimpleHTTPRequestHandlerif __name__ == &apos;__main__&apos;: server = HTTPServer((&apos;localhost&apos;, 8080), SimpleHTTPRequestHandler) server.serve_forever() 在当前代码运行的目录下创建文件 index.html，然后访问 http://localhost:8080,服务器响应的就是 index.html的内容. CGIHTTPServer/http.server Python2.7: CGIHTTPServer Python3+: http.server Python3 以后，将 Python2 的 CGIHTTPServer 模块合并到了 http.server 中。 CGIHTTPServer/http.server 模块定义了 CGI 协议的处理器 CGIHTTPRequestHandler，该 Handler 继承自 SimpleHTTPRequestHandler。 CGIHTTPRequestHandler 可以处理 CGI 脚本，在 SimpleHTTPRequestHandler 的基础上添加了 HTTP POST 方法的处理 do_POST。 CGI: Common Gateway Interface, 通用网关接口。 当网站的页面为静态内容的时候，服务器直接返回相应的资源文件就可以了(如：index.html)， 但是很多情况下，静态页面是不能够实现我们的需求的，我们需要用 PHP，Python等语言来完成页面的内容(如：index.php)。 那么，这个时候服务器要怎么响应客户端的请求呢？ 像静态文件一样直接返回肯定是不行的，返回的只是代码，我们需要的是代码执行后的内容。所以，当客户端请求的内容是一个动态页面(如：.php, .py 等文件)的时候，服务器要去执行这个动态脚本，然后返回脚本的输出内容。 CGI 就是 web 服务器与CGI脚本 (如：.php, .py 等文件) 之间的接口协议。CGI 程序从环境变量和标准输入中读取数据执行完毕之后想标准输出输出数据。web服务器将CGI程序的输出数据返回给客户端。 标准输入：标准输入中的数据一般是服务器接收到的客户端 GET，POST，PUT等发送过来的数据。 环境变量：服务器将一些必要的参数声明成环境变量来传递给 CGI 脚本就。常见的CGI环境变量： SCRIPT_NAME: CGI 脚本名称。 SCRIPT_FILENAME: CGI 脚本的绝对路径。 CONTENT_TYPE: 标准输入中传递的信息的MIME类型，如: application/x-www-form-urlencoded。 CONTENT_LENGTH: 传递内容的长度。 HTTP_COOKIE: 客户端的cookie，即请求 HTTP 头部 Cookie/Cookie2 传过来的 cookie。 HTTP_USER_AGENT: 请求 HTTP 头部的 User-Agent. PATH_INFO: 表示请求URL中紧接在CGI脚本名称后面的path。 QUERY_STING: URL 中的query，即 ?后面的参数(不包括#)。 REMOTE_ADDR: 客户端IP地址。 REQUEST_METHOD: 请求方法，如：GET，POST等。 了解 CGI 之后，我们来看一下 CGIHTTPRequestHandler: cgi_directories: 类变量 cgi_directories 定义了 CGI 脚本的目录 1cgi_directories = [&apos;/cgi-bin&apos;, &apos;/htbin&apos;] 所以，把 CGI 脚本存放到服务器运行目录下的 cgi-bin 或 htbin 目录下，或者通过修改cgi_directories自定义目录。 run_cgi(): 处理 CGI 脚本的主要方法。首先，初始化 CGI 的环境变量，然后通过 os.fork() 或 subprocess.Popen() 来运行 CGI 脚本。 do_POST(): 处理 HTTP POST 方法的请求，仅处理 CGI 脚本的请求。主要通过 run_cgi() 来处理动态脚本。 send_head(): 重写 SimpleHTTPRequestHandler 的 send_head()，使 HTTP HEAD 和 GET 请求也支持 CGI。 支持 CGI 协议的简单 HTTP 服务器服务器脚本 server.py：123456from http.server import HTTPServer, CGIHTTPRequestHandlerif __name__ == &apos;__main__&apos;: CGIHTTPRequestHandler.cgi_directories += [&apos;/apps&apos;] # add custom cgi directory server = HTTPServer((&apos;localhost&apos;, 8000), CGIHTTPRequestHandler) server.serve_forever() 运行服务器脚本 server.py，并在当前路径下创建 apps 目录，用来保存 CGI 程序。apps/index.sh：123456#!/bin/bashecho &quot;REQUEST METHOD: $REQUEST_METHOD&quot;echo &quot;QUERY STRING: $QUERY_STRING&quot;read varsecho &quot;CONTENT: $vars&quot; 客户端发送数据：12345POST /apps/index.sh?action=create HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedname=lizs&amp;age=26 接收数据：1234567HTTP/1.0 200 Script output followsServer: SimpleHTTP/0.6 Python/2.7.12Date: Tue, 06 Mar 2018 13:01:42 GMTREQUEST METHOD: POSTQUERY STRING: action=createCONTENT: name=lizs&amp;age=26 CGI 脚本 apps/index.py:1234567891011121314151617#!/usr/bin/env python# -*- coding: utf-8 -*-import osimport cgidef msg(name): print(&apos;%s: %s&apos; % (name, os.environ.get(name, &apos;&apos;)))msg(&apos;SCRIPT_NAME&apos;)msg(&apos;REQUEST_METHOD&apos;)msg(&apos;QUERY_STRING&apos;)storage = cgi.FieldStorage()print(storage.getvalue(&apos;name&apos;))print(storage.getvalue(&apos;age&apos;)) 客户端请求数据：12GET /apps/index.py?name=lizs&amp;age=26 HTTP/1.1Host: localhost 接收数据：123456789HTTP/1.0 200 Script output followsServer: SimpleHTTP/0.6 Python/2.7.12Date: Tue, 06 Mar 2018 13:11:29 GMTSCRIPT_NAME: /apps/index.pyREQUEST_METHOD: GETQUERY_STRING: name=lizs&amp;age=26name: lizsage: 26 发送数据：12345POST /apps/index.py?action=create HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedname=lizs&amp;age=26 接收数据：1234567HTTP/1.0 200 Script output followsServer: SimpleHTTP/0.6 Python/2.7.12Date: Tue, 06 Mar 2018 13:13:21 GMTSCRIPT_NAME: /apps/index.pyREQUEST_METHOD: POSTQUERY_STRING: action=create 获取content失败？ Python3+ BaseHTTPRequestHandler 源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380class BaseHTTPRequestHandler(socketserver.StreamRequestHandler): # The Python system version, truncated to its first component. sys_version = &quot;Python/&quot; + sys.version.split()[0] # The server software version. You may want to override this. # The format is multiple whitespace-separated strings, # where each string is of the form name[/version]. server_version = &quot;BaseHTTP/&quot; + __version__ error_message_format = DEFAULT_ERROR_MESSAGE error_content_type = DEFAULT_ERROR_CONTENT_TYPE # The default request version. This only affects responses up until # the point where the request line is parsed, so it mainly decides what # the client gets back when sending a malformed request line. # Most web servers default to HTTP 0.9, i.e. don&apos;t send a status line. default_request_version = &quot;HTTP/0.9&quot; def parse_request(self): &quot;&quot;&quot;Parse a request (internal). The request should be stored in self.raw_requestline; the results are in self.command, self.path, self.request_version and self.headers. Return True for success, False for failure; on failure, an error is sent back. &quot;&quot;&quot; self.command = None # set in case of error on the first line self.request_version = version = self.default_request_version self.close_connection = True requestline = str(self.raw_requestline, &apos;iso-8859-1&apos;) requestline = requestline.rstrip(&apos;\\r\\n&apos;) self.requestline = requestline words = requestline.split() if len(words) == 3: command, path, version = words if version[:5] != &apos;HTTP/&apos;: self.send_error( HTTPStatus.BAD_REQUEST, &quot;Bad request version (%r)&quot; % version) return False try: base_version_number = version.split(&apos;/&apos;, 1)[1] version_number = base_version_number.split(&quot;.&quot;) # RFC 2145 section 3.1 says there can be only one &quot;.&quot; and # - major and minor numbers MUST be treated as # separate integers; # - HTTP/2.4 is a lower version than HTTP/2.13, which in # turn is lower than HTTP/12.3; # - Leading zeros MUST be ignored by recipients. if len(version_number) != 2: raise ValueError version_number = int(version_number[0]), int(version_number[1]) except (ValueError, IndexError): self.send_error( HTTPStatus.BAD_REQUEST, &quot;Bad request version (%r)&quot; % version) return False if version_number &gt;= (1, 1) and self.protocol_version &gt;= &quot;HTTP/1.1&quot;: self.close_connection = False if version_number &gt;= (2, 0): self.send_error( HTTPStatus.HTTP_VERSION_NOT_SUPPORTED, &quot;Invalid HTTP Version (%s)&quot; % base_version_number) return False elif len(words) == 2: command, path = words self.close_connection = True if command != &apos;GET&apos;: self.send_error( HTTPStatus.BAD_REQUEST, &quot;Bad HTTP/0.9 request type (%r)&quot; % command) return False elif not words: return False else: self.send_error( HTTPStatus.BAD_REQUEST, &quot;Bad request syntax (%r)&quot; % requestline) return False self.command, self.path, self.request_version = command, path, version # Examine the headers and look for a Connection directive. try: self.headers = http.client.parse_headers(self.rfile, _class=self.MessageClass) except http.client.LineTooLong: self.send_error( HTTPStatus.BAD_REQUEST, &quot;Line too long&quot;) return False except http.client.HTTPException as err: self.send_error( HTTPStatus.REQUEST_HEADER_FIELDS_TOO_LARGE, &quot;Too many headers&quot;, str(err) ) return False conntype = self.headers.get(&apos;Connection&apos;, &quot;&quot;) if conntype.lower() == &apos;close&apos;: self.close_connection = True elif (conntype.lower() == &apos;keep-alive&apos; and self.protocol_version &gt;= &quot;HTTP/1.1&quot;): self.close_connection = False # Examine the headers and look for an Expect directive expect = self.headers.get(&apos;Expect&apos;, &quot;&quot;) if (expect.lower() == &quot;100-continue&quot; and self.protocol_version &gt;= &quot;HTTP/1.1&quot; and self.request_version &gt;= &quot;HTTP/1.1&quot;): if not self.handle_expect_100(): return False return True def handle_expect_100(self): &quot;&quot;&quot;Decide what to do with an &quot;Expect: 100-continue&quot; header. If the client is expecting a 100 Continue response, we must respond with either a 100 Continue or a final response before waiting for the request body. The default is to always respond with a 100 Continue. You can behave differently (for example, reject unauthorized requests) by overriding this method. This method should either return True (possibly after sending a 100 Continue response) or send an error response and return False. &quot;&quot;&quot; self.send_response_only(HTTPStatus.CONTINUE) self.end_headers() return True def handle_one_request(self): &quot;&quot;&quot;Handle a single HTTP request. You normally don&apos;t need to override this method; see the class __doc__ string for information on how to handle specific HTTP commands such as GET and POST. &quot;&quot;&quot; try: self.raw_requestline = self.rfile.readline(65537) if len(self.raw_requestline) &gt; 65536: self.requestline = &apos;&apos; self.request_version = &apos;&apos; self.command = &apos;&apos; self.send_error(HTTPStatus.REQUEST_URI_TOO_LONG) return if not self.raw_requestline: self.close_connection = True return if not self.parse_request(): # An error code has been sent, just exit return mname = &apos;do_&apos; + self.command if not hasattr(self, mname): self.send_error( HTTPStatus.NOT_IMPLEMENTED, &quot;Unsupported method (%r)&quot; % self.command) return method = getattr(self, mname) method() self.wfile.flush() #actually send the response if not already done. except socket.timeout as e: #a read or a write timed out. Discard this connection self.log_error(&quot;Request timed out: %r&quot;, e) self.close_connection = True return def handle(self): &quot;&quot;&quot;Handle multiple requests if necessary.&quot;&quot;&quot; self.close_connection = True self.handle_one_request() while not self.close_connection: self.handle_one_request() def send_error(self, code, message=None, explain=None): &quot;&quot;&quot;Send and log an error reply. Arguments are * code: an HTTP error code 3 digits * message: a simple optional 1 line reason phrase. *( HTAB / SP / VCHAR / %x80-FF ) defaults to short entry matching the response code * explain: a detailed message defaults to the long entry matching the response code. This sends an error response (so it must be called before any output has been generated), logs the error, and finally sends a piece of HTML explaining the error to the user. &quot;&quot;&quot; try: shortmsg, longmsg = self.responses[code] except KeyError: shortmsg, longmsg = &apos;???&apos;, &apos;???&apos; if message is None: message = shortmsg if explain is None: explain = longmsg self.log_error(&quot;code %d, message %s&quot;, code, message) self.send_response(code, message) self.send_header(&apos;Connection&apos;, &apos;close&apos;) # Message body is omitted for cases described in: # - RFC7230: 3.3. 1xx, 204(No Content), 304(Not Modified) # - RFC7231: 6.3.6. 205(Reset Content) body = None if (code &gt;= 200 and code not in (HTTPStatus.NO_CONTENT, HTTPStatus.RESET_CONTENT, HTTPStatus.NOT_MODIFIED)): # HTML encode to prevent Cross Site Scripting attacks # (see bug #1100201) content = (self.error_message_format % &#123; &apos;code&apos;: code, &apos;message&apos;: _quote_html(message), &apos;explain&apos;: _quote_html(explain) &#125;) body = content.encode(&apos;UTF-8&apos;, &apos;replace&apos;) self.send_header(&quot;Content-Type&quot;, self.error_content_type) self.send_header(&apos;Content-Length&apos;, int(len(body))) self.end_headers() if self.command != &apos;HEAD&apos; and body: self.wfile.write(body) def send_response(self, code, message=None): &quot;&quot;&quot;Add the response header to the headers buffer and log the response code. Also send two standard headers with the server software version and the current date. &quot;&quot;&quot; self.log_request(code) self.send_response_only(code, message) self.send_header(&apos;Server&apos;, self.version_string()) self.send_header(&apos;Date&apos;, self.date_time_string()) def send_response_only(self, code, message=None): &quot;&quot;&quot;Send the response header only.&quot;&quot;&quot; if message is None: if code in self.responses: message = self.responses[code][0] else: message = &apos;&apos; if self.request_version != &apos;HTTP/0.9&apos;: if not hasattr(self, &apos;_headers_buffer&apos;): self._headers_buffer = [] self._headers_buffer.append((&quot;%s %d %s\\r\\n&quot; % (self.protocol_version, code, message)).encode( &apos;latin-1&apos;, &apos;strict&apos;)) def send_header(self, keyword, value): &quot;&quot;&quot;Send a MIME header to the headers buffer.&quot;&quot;&quot; if self.request_version != &apos;HTTP/0.9&apos;: if not hasattr(self, &apos;_headers_buffer&apos;): self._headers_buffer = [] self._headers_buffer.append( (&quot;%s: %s\\r\\n&quot; % (keyword, value)).encode(&apos;latin-1&apos;, &apos;strict&apos;)) if keyword.lower() == &apos;connection&apos;: if value.lower() == &apos;close&apos;: self.close_connection = True elif value.lower() == &apos;keep-alive&apos;: self.close_connection = False def end_headers(self): &quot;&quot;&quot;Send the blank line ending the MIME headers.&quot;&quot;&quot; if self.request_version != &apos;HTTP/0.9&apos;: self._headers_buffer.append(b&quot;\\r\\n&quot;) self.flush_headers() def flush_headers(self): if hasattr(self, &apos;_headers_buffer&apos;): self.wfile.write(b&quot;&quot;.join(self._headers_buffer)) self._headers_buffer = [] def log_request(self, code=&apos;-&apos;, size=&apos;-&apos;): &quot;&quot;&quot;Log an accepted request. This is called by send_response(). &quot;&quot;&quot; if isinstance(code, HTTPStatus): code = code.value self.log_message(&apos;&quot;%s&quot; %s %s&apos;, self.requestline, str(code), str(size)) def log_error(self, format, *args): &quot;&quot;&quot;Log an error. This is called when a request cannot be fulfilled. By default it passes the message on to log_message(). Arguments are the same as for log_message(). XXX This should go to the separate error log. &quot;&quot;&quot; self.log_message(format, *args) def log_message(self, format, *args): &quot;&quot;&quot;Log an arbitrary message. This is used by all other logging functions. Override it if you have specific logging wishes. The first argument, FORMAT, is a format string for the message to be logged. If the format string contains any % escapes requiring parameters, they should be specified as subsequent arguments (it&apos;s just like printf!). The client ip and current date/time are prefixed to every message. &quot;&quot;&quot; sys.stderr.write(&quot;%s - - [%s] %s\\n&quot; % (self.address_string(), self.log_date_time_string(), format%args)) def version_string(self): &quot;&quot;&quot;Return the server software version string.&quot;&quot;&quot; return self.server_version + &apos; &apos; + self.sys_version def date_time_string(self, timestamp=None): &quot;&quot;&quot;Return the current date and time formatted for a message header.&quot;&quot;&quot; if timestamp is None: timestamp = time.time() year, month, day, hh, mm, ss, wd, y, z = time.gmtime(timestamp) s = &quot;%s, %02d %3s %4d %02d:%02d:%02d GMT&quot; % ( self.weekdayname[wd], day, self.monthname[month], year, hh, mm, ss) return s def log_date_time_string(self): &quot;&quot;&quot;Return the current time formatted for logging.&quot;&quot;&quot; now = time.time() year, month, day, hh, mm, ss, x, y, z = time.localtime(now) s = &quot;%02d/%3s/%04d %02d:%02d:%02d&quot; % ( day, self.monthname[month], year, hh, mm, ss) return s weekdayname = [&apos;Mon&apos;, &apos;Tue&apos;, &apos;Wed&apos;, &apos;Thu&apos;, &apos;Fri&apos;, &apos;Sat&apos;, &apos;Sun&apos;] monthname = [None, &apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;] def address_string(self): &quot;&quot;&quot;Return the client address.&quot;&quot;&quot; return self.client_address[0] # Essentially static class variables # The version of the HTTP protocol we support. # Set this to HTTP/1.1 to enable automatic keepalive protocol_version = &quot;HTTP/1.0&quot; # MessageClass used to parse headers MessageClass = http.client.HTTPMessage # hack to maintain backwards compatibility responses = &#123; v: (v.phrase, v.description) for v in HTTPStatus.__members__.values() &#125;","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - Socket Server","slug":"python/socket_server","date":"2018-01-01T16:00:00.000Z","updated":"2019-02-26T07:08:56.156Z","comments":true,"path":"2018/01/02/python/socket_server/","link":"","permalink":"https://lizsgh.github.io/2018/01/02/python/socket_server/","excerpt":"","text":"SocketServer/socketserver Python3, SocketServer 模块重命名为 socketserver。socketserver 模块提供了创建网络服务器的简洁的接口。 BaseServer 基类123456789101112131415161718192021222324class BaseServer: def __init__(self, server_address, RequestHandlerClass): self.server_address = server_address self.RequestHandlerClass = RequestHandlerClass ... def get_request(self): pass def finish_request(self, request, client_address): self.RequestHandlerClass(request, client_address, self) def process_request(self, request, client_address) self.finish_request(request, client_address) self.shutdown_request(request) def server_activate(self): pass def serve_forever(self, poll_interval=0.5): pass def close_request(self, request): pass def shutdown_request(self, request): pass ... BaseServer() 初始化必须传递服务器地址((host, port)) 和处理器类(RequestHandlerClass的子类) Server 类最终处理请求的时候是调用 Handler 类去实现的 get_request() 会返回一个二元组 (request, client_address)，传递给 Handler 类。不过这些都是 Server 的子类去实现，如： TCPServer 和 UDPServer 的 get_request() 返回值都不一样。 serve_forever() 启动请求服务器 BaseRequestHandler 基类12345678910111213141516class BaseRequestHandler: def __init__(self, request, client_address, server): self.request = request self.client_address = client_address self.server = server self.setup() try: self.handle() finally: self.finish() def setup(self): pass def handle(self): pass def finish(self): pass Server 子类会调用 Handler 子类来处理请求 process_request。 request: Server 子类 get_request() 方法返回的第一个参数。 TCPServer: 为接受当前请求的 socket 对象； UDPServer: 为接收数据和 socket 对象的二元组 (data, socket)。 client_address: Server 子类 get_request() 方法返回的第二个参数，为 socket 客户端地址，如：TCP/UDP -&gt; (host, port) 处理器主要通过 handle() 方法来处理请求。 在 handle() 之前通过 setup() 方法来初始化工作。 最终通过 finish() 方法来做结束处理工作。 socket 实现 TCP 服务器123456789101112host = &apos;127.0.0.1&apos;port = 8000buff_size = 1024sock = socket.socket()sock.bind((host, port))sock.listen(5)conn, address = sock.accept()while True: data = conn.recv(buff_size) if data: print(data) conn.sendall(data.upper()) socketserver 实现 TCP 服务器socketserver 模块可以通过 TCPServer() 来实现 TCP 服务器。123456789101112131415161718192021222324252627282930313233343536373839404142434445class TCPServer(BaseServer): address_family = socket.AF_INET socket_type = socket.SOCK_STREAM request_queue_size = 5 allow_reuse_address = False def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True): BaseServer.__init__(server_address, RequestHandlerClass) self.socket = socket.socket(self.address_family, self.socket_type) if bind_and_activate: try: self.server_bind() self.server_activate() except: self.server_close() raise def server_bind(self): if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_address) self.server_address = self.socket.getsockname() def server_activate(self): self.socket.listen(self.request_queue_size) def server_close(self): self.socket.close() def get_request(self): return self.socket.accept() def fileno(self): return self.socket.fileno() def shutdown_request(self, request): try: request.shutdown(socket.SHUT_WR) except socket.error: pass #some platforms may raise ENOTCONN here self.close_request(request) def close_request(self, request): request.close() __init__(self, server_address, RequestHandlerClass, bind_and_activate=True) server_address: 服务器地址 (host, port)。 RequestHandlerClass: Handler 类，Server 类处理请求实际上是调用了该类。 bind_and_activate: True/False。 如果为 True，将自动调用 self.server_bind() 和 self.server_activate() 来绑定并监听服务器。 get_request(self)返回一个二元组 (request, client_address)，传递给 Handler 类。这里 TCPServer 直接返回 socket.accept() 的返回值。所以，Handler 子类中的 self.request 为当前连接的新 socket 对象；self.client_address 为 socket 客户端的地址((host, port))。 首先，要定义一个处理TCP请求的 Handler 子类。1234567class TCPHandler(socketserver.BaseRequestHandler): def handle(self): data = self.request.recv(1024) if data: print(&apos;%s:%s - %s&apos; % (self.address_client[0], self.address_client[1], data)) # return the upper data self.request.sendall(data.upper()) 用 TCPServer 实现 TCP 服务器：1234host = &apos;localhost&apos;port = 8080server = socketserver.TCPServer((host, port), TCPHandler)server.serve_forever() Python3.6 以上可以用 with statement context manager 12with socketserver.TCPServer((host, port), TCPHandler) as server: server.serve_forever() socket 实现 UDP 服务器12345678910host = &apos;localhost&apos;port = 8080sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)sock.bind((host, port))while True: data, address = sock.recvfrom(1024) if data: print(&apos;%s:%s - %s&apos; % (address[0], address[1], data)) # return upper data sock.sendto(data.upper(), address) socketserver 实现 UDP 服务器socketserver 模块提供了一个 Server 子类 UDPServer 来实现 UDP 服务器。123456789101112131415161718192021class UDPServer(TCPServer): allow_reuse_address = False socket_type = socket.SOCK_DGRAM max_packet_size = 8192 def get_request(self): data, client_addr = self.socket.recvfrom(self.max_packet_size) return (data, self.socket), client_addr def server_activate(self): # No need to call listen() for UDP. pass def shutdown_request(self, request): # No need to shutdown anything. self.close_request(request) def close_request(self, request): # No need to close anything. pass UDPServer 子类继承了 TCPServer。但是要注意 get_request() 返回与 TCPServer 不同。因此，Handler 子类的 self.request 为 (data, socket) 的二元组。 同样，定义一个 Handler 子类12345678class UDPHandler(BaseRequestHandler): def handle(self): data, sock = self.request if data: print(&apos;%s:%s - %s&apos; % (self.client_address[0], self.client_address[1], data)) sock.sendto(data.upper(), self.client_address) 用 UDPServer 实现 UDP 服务器1234host = &apos;localhost&apos;port = 8080server = socketserver.UDPServer((host, port), UDPHandler)server.serve_forever() 多进程/多线程处理请求socketserver 模块提供了 ForkingMixIn 和 ThreadingMixIn 类来处理请求。 ForkingMixIn 会创建一个子进程来处理每个请求 ThreadingMixIn 会创建一个线程来处理每个请求 多进程/多线程处理请求的 Server 类12345class ForkingUDPServer(ForkingMixIn, UDPServer): passclass ForkingTCPServer(ForkingMixIn, TCPServer): passclass ThreadingUDPServer(ThreadingMixIn, UDPServer): passclass ThreadingTCPServer(ThreadingMixIn, TCPServer): pass 这些 Server 类的用法和 TCPServer, UDPServer 是一样的，只是它们处理请求的机制改变了而已。","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Linux command - tcpdump","slug":"linux/cmd_tcpdump","date":"2018-01-01T16:00:00.000Z","updated":"2019-02-26T07:34:48.857Z","comments":true,"path":"2018/01/02/linux/cmd_tcpdump/","link":"","permalink":"https://lizsgh.github.io/2018/01/02/linux/cmd_tcpdump/","excerpt":"","text":"Dump the traffic on a network. 1tcpdump [options] [expression] 常用 options: -c count: Exit after receiving count packets. 指定抓取的包的数量。 -D, --list-interfaces: 打印出系统中可以被 tcpdump 抓包的网络接口。列出的网络接口包括相应的序号和网络接口名，可以用 tcpdump -i指定相应的网络接口或相应的序号来抓取特定网络接口的数据包。其中名为any的网络接口表示可以抓取所有网络接口的数据包 (tcpdump -i any)。 -F file: 从指定的file中读取expression(tcpdump [options] [expression])。 -i interface, --interface=interface: 指定抓包的网络接口。如果没有指定tcpdump会监听tcpdump -D中第一个网络接口。当指定interface为any则表示监听所有网络接口。 -l: Make stdout line buffered. 将抓包记录从标准输出变为行缓冲形式。当抓包的时候，你可以将抓包记录存到文件，边抓包边分析。 -n: Don not convert address (i.e., host address, port numbers, etc) to names. 即直接显示数字形式的地址端口号等，而不进行解析。 -#, --number: 给每行抓包的输出结果添加行号。 -q: 简短快速输出。只打印较少的协议信息。 -t: 每行抓包记录不打印时间。 -tt: 将每行抓包记录的时间代替为时间戳形式。 -ttt: 将每行记录的时间替换为和上一行的时间差。 -tttt: 在每行记录的时间前添加日期 (默认只显示时分秒)。 -v, -vv, -vvv: 打印其它详细信息，详细程度依次递增。 -w file, 不打印抓取的数据包，而是将数据保存到file文件中，文件后缀一般为.pcap, .cap, .dmp。保存的数据是没有解码的十六进制数据，可以使用 wirekshark 等工具进行分析。 -x: 以十六进制形式打印数据包的头部信息。 -xx: 比-x更加详细。 -X: 以十六进制和 ASCII 的形式打印数据包的头部信息。 -XX: 比-X更加详细。 12345678910111213141516171819202122232425# 查看系统中可以被 tcpdump 抓包的网络接口sudo tcpdump -D 1.wlo1 [Up, Running] 2.vmnet1 [Up, Running] 3.vmnet8 [Up, Running] 4.any (Pseudo-device that captures on all interfaces) [Up, Running] 5.lo [Up, Running, Loopback] 6.docker0 [Up] 7.eno1 [Up] 8.br-eb58f5c99244 [Up] 9.bluetooth0 (Bluetooth adapter number 0) ...# 监听所有接口sudo tcpdump -i any # 或 sudo tcpdump -i 4# 将抓包信息保存到文件，可以边抓包边分析sudo tcpdump -nn -l &gt; packets.log &amp;# 抓取 10 个数据包，并添加行号和显示数字形式的地址、端口信息sudo tcpdump -c 3 -n#listening on wlo1, link-type EN10MB (Ethernet), capture size 262144 bytes 1 19:55:08.990797 IP 192.168.3.3.53751 &gt; 192.168.0.102.63822: UDP, length 96 2 19:55:08.990972 IP 192.168.3.3.58581 &gt; 192.168.1.24.61048: UDP, length 96 3 19:55:08.991039 IP 192.168.3.3.41684 &gt; 140.240.42.194.4321: UDP, length 963 packets captured4 packets received by filter0 packets dropped by kernel expressionexpression 可以用来过滤抓取的数据包。 The filter expression consists of one or more primitives. Primitives usually consist of an id (name or number) preceded by one or more qualifiers. There are three different kinds of qualifier: type, dir, proto.过滤表达式可以由 type, dir, proto 中的一个或多个组成。 type: type qualifiers say what kind of thing the id name or number refers to. Possible type are: host, net, port and portrange. E.g. host lizs.cc, net 127.0, port 80, portrange 6000-6008, etc. 1234# 监听地址以 127. 开头的数据包，如`127.0.0.1`, `127.0.1.1`等sudo tcpdump -c 3 -i any -n# net 127# 监听 lizs.ccsudo tcpdump -c 3 -i any -n# host lizs.cc dir: dir qualifiers specify a particular transfer direction to and/or from id. Possible directions are src, dst, src or dst, src and dst, ra, ta, addr1, addr2, addr3, and addr4. E.g., src foo, dst net 128.3, src or dst port ftp-data. The ra, ta, addr1, addr2, addr3, and addr4 qualifiers are only valid for IEEE 802.11 Wireless LAN link layers. 1234# 监听源地址为 127.0.0.1 的数据包sudo tcpdump -c3 -i any -n# src net 127.0.0.1# 监听源地址或目的地址为 lizs.cc 的数据包sudo tcpdump -c3 -i any -n#tttt src or dst host lizs.cc proto: proto qualifiers restrict the match to a particular protocol. Possible protos are: ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp and udp. E.g., ether src foo, arp net 128.3, tcp port 21, udp portrange 7000-7009, wlan addr2 0:2:3:4:5:6.1234# 监听 TCP 的数据包sudo tcpdump -c 3 -i any -n#qtttt tcp# 监听所有网络接口的 ICMP 数据包sudo tcpdump -c3 -i any -n#qtttt icmp 除了以上 primitive，还有其它 primitive，如：gateway, broadcast, less, greater以及算术表达式，等等。 多个修饰语 (qualifier) 可以用and, or, not, !等连接组合起来，也可以用括号()指定优先级，不过要用反斜杠转义\\(\\)或 expression 用单引号或双引号括起来。12345678910111213141516# 监听源端口为 80 或 443 的 TCP 数据包sudo tcpdump -n#qtttt tcp src port 80 or 443 # 或者 sudo tcpdump -n#qtttt src port 80 or 443 and tcp# 监听 lizs.cc 的 TCP 数据包，不过过滤掉和 github.com 通信的数据包sudo tcpdump -i any tcp host lizs.cc and not github.com# 监听端口不为 1080 的非 TCP 数据包sudo tcpdump ! tcp port ! 1080# 监听目的端口不为 1080 的 tcp 或 arp 包sudo tcpdump dst port ! 1080 and \\(tcp or arp\\) # 或sudo tcpdump 'dst port ! 1080 and (tcp or arp)' # 或sudo tcpdump tcp or arp dst port ! 1080# 监听 ftp 端口或 telnet 端口的数据包sudo tcpdump -i any port ftp or telnet# 监听所有通过网关 snup 的 ftp 数据包sudo tcpdump -i any 'gateway snup and (port ftp or ftp-data)'# 抓取数据包长度小于或等于 65 的 tcp 数据包。sudo tcpdump -i any tcp and less 65 更多端口信息可以查看/etc/services。 表达式中的切片proto[x]，表示协议中的第 x 个字节的内容。proto为相应的协议名称，如tcp, ip。proto[x:y]，表示协议中从 x 位置开始的 y 个字节内容。proto为相应的协议名称，如tcp, ip。12345678910# 过滤掉源端口小于 1024 的 TCP 连接sudo tcpdump -i any -n#qtttt 'tcp[0:2] &lt; 1024'# 打印目的端口为 443 的 TCP 连接数据包sudo tcpdump -i any -n#qtttt 'tcp[2:2] = 443'# 打印源端口不是 443 的 TCP 连接sudo tcpdump -i any -n#qtttt 'tcp[0:2] != 443'# 抓取 SYN 包并保存到 syn_packets.pcap 文件中sudo tcpdump -i any -w syn_pckets.pcap 'tcp[13] == 2'# 抓取 HTTP 协议的 GET 方法请求的数据包sudo tcpdump -i any -n#qtttt 'tcp[20] = 0x47 and tcp[21] = 0x45 and tcp[22] = 0x54' TCP 首部共 20 字节: 16 位 (2 字节) 的源端口和 16 位的目的端口；32 位系列号；32 位确认序列号；4 位首部长度；6位保留位；6 位标志位 (URG, ACK, PSH, RST, SYN, FIN，各占一位)；等等。下标从 0 开始，所以，源端口为tcp[0:2]，目的端口为tcp[2:2]，SYN 标志位在第 14 字节 (即 13),值为 000010 == 2。 因为，要计算各协议的标志位很麻烦，所以，提供了部分别名： proto[icmptype]，ICMP 类型。同时 ICMP 类型有： icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redirect, icmp-echo 等等。 proto[icmpcode]，ICMP 符号。 proto[tcpflags]，TCP 标志位。标志值有：tcp-urg, tcp-ack, tcp-psh, tcp-syn, tcp-fin。12# 抓取 SYN 包sudo tcpdump -i any 'tcp[tcpflags] = tcp-syn' 更多 expression 的详细语法可以通过 man pcap-filter 查看。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"cmd","slug":"cmd","permalink":"https://lizsgh.github.io/tags/cmd/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Python - Socket","slug":"python/socket","date":"2017-12-31T16:00:00.000Z","updated":"2019-02-26T07:07:44.076Z","comments":true,"path":"2018/01/01/python/socket/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/python/socket/","excerpt":"","text":"Socket Reference 创建 socket 对象socket.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None)socket.socket() 函数将根据指定的参数创建一个 socket 对象。 family: 协议族，协议族决定了 socket 连接的地址类型。 AF_INET: IPv4, (host, port). host, a string (e.g. ‘alizs.cc’, ‘127.0.0.1’); port, an integer. AF_INET6: IPv6, (host, port, flowinfo, scopeid). AF_UNIX: 用于单一的 Unix 系统的进程间通信，连接地址为绝对路径。数据传输不需要经过网络，发送的数据经过内核缓冲区后，内核根据路径将数据发送到接收方的内核缓冲区。所以，数据传输的速率远远大于 AF_INET、AF_INET6，而且因为不需要经过网卡，数据传输也不受网卡带宽的限制。 type: Socket 类型。 SOCK_STREAM：流式 Socket，使用 TCP 传输协议，用于提供面向连接、可靠的数据传输服务。传输数据能够实现无差错、无重复发送，并按顺序接收。 SOCK_DGRAM：数据包 Socket，使用 UDP 传输协议，用于提供无连接的数据传输服务。传输数据不具备可靠性，数据有可能在传输工程中丢失或出现重复发送数据，并且无法保证顺序地接收数据。 SOCK_RAM：原始 Socket，允许对较低层次的协议直接访问。如：IP、ICMP 等。 SOCK_STREAM 只能读取 TCP 协议的数据包，SOCK_DGRAM 只能读取 UDP 协议的数据包，要访问其它协议的数据包可以用 SOCK_RAM。 proto：协议类型，可以指定使用的协议。0，表示默认协议。SOCK_STREAM =&gt; IPPROTO_TCP, SOCK_DGRAM =&gt; IPPROTO_UDP。 当 type=SOCK_RAM 时，proto 不能为空，即不能够用默认值0。 fileno：python3 新增，如果指定 fileno，其它参数将没有意义，因为 socket 对象将由该 fileno 创建。 socket.create_connection() socket 对象的常用方法1sock = socket.socket() Python3.2: Support for the context manager with socket.socket() as sock: Socket objects(sock) have the following methods： sock.bind(address)：将 Socket 绑定到指定的地址。 address，绑定的地址，格式取决于family。如：AF_INET =&gt; (&#39;127.0.0.1&#39;, 8080)。 sock.listen(backlog)：Socket 服务器开始监听客户端的连接请求。 backlog，表示服务器在 accept 连接请求之前可以挂起的最大连接数。数值必须大于 0，小于 0 将自动设为 0。 Python3.5: backlog 为可选参数。 sock.accept()：Socket 服务器接收一个客户端的连接请求，socket 必须要先绑定地址，并且在监听状态。accept() 方法会一直阻塞，直到接收到一个连接请求。返回返回值是一个二元组 (conn, address)。 conn：一个新的 Socket 对象，可以用来在该连接上发送或接收数据。 address：客户端的地址。地址格式取决于 family，e.g. AF_INET =&gt; (&#39;127.0.0.1&#39;, 35423). sock.connect(address)：连接到Socket，address 格式取决于 family。连接失败会引起报错。 sock.connect_ex(address)：Like sock.connect(address)，但是一般连接失败不会引起报错，会返回一个状态码，0 表示成功。但是，像 Name or server not know(address=(&#39;127.0.0.999&#39;, 8080)) 这些还是会引起报错的。 sock.send(bytes[, flags])：建立 socket 连接之后，发送数据到 socket。返回发送的字节数。 bytes：发送的数据。注意：Python2，为str类型；Python3，为 bytes 类型。 flags：man recv. 用 send() 发送数据到 socket，不一定一次就发送完毕，所以，发送完一次之后要比较发送的字节数和总共要发送数据的字节数，判断是否需要进行再次发送剩余的数据。 sock.sendall(bytes[, flags])：建立 socket 连接之后，发送数据到 socket。不同 send()，sendall() 会一直发送数据，直到数据发送完毕，或者引起报错。成功发送完毕之后，会返回None。如果引起报错是不能够确定已经发送了多少数据的。 sock.sendto(bytes, address)：发送数据到 sock 没有连接的地址。成功返回发送发送的字节数。地址的格式取决于 family。 （当 family=AF_UNIX 的时候，sendto() 使用出现 socket.error: [Errno 95] Operation not supported 的错误？） sock.recv(bufsize[, flags])：接收 Socket 发送过来的数据，作为返回值。recv() 方法会一直阻塞，直到接收到数据。 bufsize：一次接收数据的最大字节数 flags：man recv sock.recvfrom(bufsize[, flags])：接收 Socket 发送过来的数据，返回值为 (bytes, address)。bytes，接收的数据；address，发送数据过来的Socket地址。bufsize, flags 参数同 recv()。recvfrom() 方法也会一直阻塞，直到接收到数据。 sock.recv_into(buffer[, nbytes[, flags]])：接收 Socket 发送的数据到 buffer，并返回实际接收到数据的字节数。 buffer：接收到的 Socket 数据的保存地方。 nbytes：一次接收 Socket 数据的最大字节数。 falgs：同 recv()，man recv sock.recvfrom_into(buffer[, nbytes[, flags]])：接收 Socket 发送的数据到 buffer，不过返回值是 (nbytes, address)。nbytes，实际接收到数据的字节数；address，发送端的地址。 sock.close()：关闭本进程与 Socket 的连接，并不是关闭 Socket。比如：当多个进程同时操作一个 Socket 的时候，调用 close() 只是断开了当前进程与 Socket 的连接，其它进程与该 Socket 的连接是不会收到影响的。当所有的连接都 close() 了的时候，该 Socket 才算关闭。 sock.shutdown(how)：可以直接关闭关闭 Socket，也可以只关闭 Socket 的读或写功能。如：多个进程同时操作一个 Socket 的时候，其中一个进程调用了 shutdown()，其它进程也会受影响。how 参数： SHUT_RD：关闭 Socket 的读功能，Socket 将不能够接收数据：recv(), recvfrom() … SHUT_WR：关闭 Socket 的写功能，Socket 将不能够发送数据：send(), sendto() … SHUT_RDWR：关闭 Socket 的读写。 sock.fileno()：返回 Socket 的文件描述符。失败返回 -1。 sock.getsockname()：返回 Socket 绑定的地址。地址格式取决于 family，如：AF_INET =&gt; (&#39;127.0.0.1&#39;, 8080)。 sock.getpeername()：返回连接到 Socket 的客户端的地址。地址格式也是取决于 family。某些系统不支持该方法。 sock.gettimeout()：返回 Socket 操作的超时时间。如果没有设置超时时间，则返回 None。 sock.settimeout(value)：设置 Socket 操作的超时时间。value的值： None：阻塞模式。 0：非阻塞模式。 非零：Socket 操作的阻塞时间。 sock.setblocking(flag)：设置 Socket 的模式：阻塞/非阻塞。 True：阻塞模式。sock.setblocking(True) 等于 sock.settimeout(None)。 False：非阻塞模式。sock.setblocking(False) 等于 sock.settimeout(0)。 sock.getsockopt(level, optname[, buflen]): 获取 socket 实例属性 sock.setsockopt(level, optname, value): 设置 socket 实例属性 socket 模块的其它函数 socket.create_connection(address[, timeout[, source_address]])连接到地址为(address)的 TCP 服务器,并返回 socket 对象. address TCP服务器地址,为二元组(host, port). socket.gethostbyname(host)返回 host 的 IP 地址。 socket.getaddrinfo(host, port, family=0, type=0, proto=0, flags=0)获取地址(host, port)的相关信息,返回一个列表,列表中每个元素都是一个五元组 (family, type, proto, canonname, socketaddr),这些信息包含了创建 socket 连接所需的信息.其实,你可以理解这是一次DNS解析请求, socket 每次创建连接之前,都调用这个函数去获取地址的相关信息.所以,在爬虫的时候,因为要请求的URL数量很大,你可以通过打补丁把DNS解析缓存下来. 123456789101112import socketdns_cache = dict()def _getaddrinfo(*args, **kwargs): if args in dns_cache: return dns_cache[args] info = socket._getaddrinfo(*args, **kwargs) dns_cache[args] = info return infosocket.getaddrinfo, socket._getaddrinfo = _getaddrinfo, socket.getaddrinfo 基于 socket 的 TCP 编程12345678910111213141516171819202122232425262728import socket# serverdef server(): host = &apos;127.0.0.1&apos; port = 8080 sock = socket.socket() # Python &gt;= 3.2, support context manager: with socket.socket as sock sock.bind((host, port)) sock.listen(5) conn, address = sock.accept() while True: data = conn.recv(1024) if data: print(&apos;Data receive from client: %s&apos; % data) conn.sendall(&apos;Server receive data succefull!&apos;)def client(): host = &apos;127.0.0.1&apos; port = 8080 sock = socket.socket() sock.connect((host, port)) while True: data = input(&apos;Please input data that send to server: &apos;) sock.sendall(str(data)) msg = sock.recv(1024) if msg: print(&apos;Message from server: %s&apos; % data) TCP 需要先经过三次握手建立连接 accept 才能够通信。 客户端由 connect() 发起连接请求，向服务器发送 SYN (i)，然后 connect() 阻塞； 当服务器收到 SYN 包，向客户端回应 SYN (j) 和 ACK (i+1)； 客户端收到 SYN 和 ACK 之后，确认之后，connect() 从阻塞状态返回，并向服务器发送 ACK (j+1)。 服务器收到 ACK (j+1) 之后，确认之后，accept() 建立一个新的 socket 连接服务端。 TCP 三次握手过程中，服务器的 listen() 会将未完成和已完成(收到确认ACK)的握手过程分别保存到未完成和已完成的队列里，已完成队列的个数可以由 listen(backlog) 的 backlog 参数指定。accept() 就不断从已完成队列中获取完成握手的连接创建新的 socket 来进行通信。 该 server 只能够同时接收进行一个连接请求，如果想要 server 同时接收多个连接请求，可以用多线程分发接收连接的新 socket conn，或用多路复用 select、poll、epoll 来实现。 accept() 方法会阻塞当前进程，直到接收到一个连接请求，然后返回新的 socket conn 和客户端地址 address recv() 方法会阻塞当前进程，直到接收到数据才执行下去。 注意：Python3 发送的数据要转换为 bytes；接收到的数据也是 bytes 类型。 UDP12345678910111213141516171819202122import socketdef server(): host = &apos;127.0.0.1&apos; port = 8080 sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM) sock.bind((host, port)) while True: data, address = sock.recvfrom(1024) print(&apos;Data from client: %s&apos; % data) sock.sendto(&apos;This is a message from server&apos;, address)def client(): host = &apos;127.0.0.1&apos; port = 8080 sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM) while True: msg = input(&apos;Please input data that send to server: &apos;) sock.sendto(str(msg), (host, port)) data, address = sock.recvfrom(1024) print(data) print(address) UDP 通信不需要建立连接 recvfrom() 方法会一直阻塞到接收数据为止。 socket 发送 HTTP/HTTPS 请求URL：http://www.baidu.com12345678910111213import socketsock = socket.socket()sock.connect((&apos;www.baidu.com&apos;, 80))data = &quot;GET / HTTP/1.1\\n&quot; \\ &quot;Accept: */*\\n&quot; \\ &quot;Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh\\n&quot; \\ &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64) &quot; \\ &quot;AppleWebKit/537.36 (KHTML, like Gecko) &quot; \\ &quot;Chrome/58.0.3029.110 Safari/537.36\\n&quot; \\ &quot;Host: www.baidu.com\\n\\n&quot;sock.sendall(data)response = sock.recv(1024) URL：https://www.baidu.com1234567891011121314import socketimport sslsock = ssl.wrap_socket(socket.socket())sock.connect((&apos;www.baidu.com&apos;, 443))data = &quot;GET / HTTP/1.1\\n&quot; \\ &quot;Accept: */*\\n&quot; \\ &quot;Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh\\n&quot; \\ &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64) &quot; \\ &quot;AppleWebKit/537.36 (KHTML, like Gecko) &quot; \\ &quot;Chrome/58.0.3029.110 Safari/537.36\\n&quot; \\ &quot;Host: www.baidu.com\\n\\n&quot;sock.sendall(data)response = sock.recv(1024)","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"TCP/IP - TCP 三次握手连接和四次握手关闭","slug":"tcp/3-handshake_and_4-waves","date":"2017-12-31T16:00:00.000Z","updated":"2018-12-04T08:55:00.033Z","comments":true,"path":"2018/01/01/tcp/3-handshake_and_4-waves/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/tcp/3-handshake_and_4-waves/","excerpt":"","text":"TCP 首部TCP 数据被封装在 IP 数据报中： TCP 首部数据格式： 每个 TCP 段都包含了源端口号和目的端口号，用于寻找发端和接收端的应用程序。这两个端口号加上 IP 首部的源端 IP 地址和目的端 IP 地址就可以确定一个TCP连接。 序号：sequence number, 用来标识从 TCP 发端向 TCP 收端发送的数据字节流。 确认序号：acknowledgement number, 确认序号只有在 ACK 标志位开启(值为1)时有效，值为要确认的数据包的 sequence number + 1。如客户端发送了一个数据包(序号为x)给服务端，则服务端收到这个数据包之后要回复一个确认数据包(确认序号为x + 1)。 标志位：共有 6 个，每个标志位用 1 和 0 分别表示开和关状态。 URG: The urgent point is valid. 当 URG=1 时，表示报文段中有紧急数据，应尽快传送。 ACK: The acknowledgement number is valid. 确认标志位，当 ACK=1 时，表示这是一个确认包。 PSH: The receiver should pass this data to the application as soon as possible. 当 PSH=1 时，接收端应尽快将数据交给应用程序。 RST: Reset the connection. 复位标志位，当 RST=1 时，表示 TCP 连接出现了严重错误，必须释放连接，重新建立连接。 SYN: Synchronize sequence numbers to initiate a connection. 在建立连接时，用来同步序号。SYN=1，ACK=0 表示发起请求连接；SYN=1，ACK=1 表示同意建立连接请求。 FIN: The sender is finished sending data. 检验和：该字段检验的范围包括首部和数据，由发送端计算和存储，并由接收端进行检验。 窗口：用来控制对方发送的数据量，通知发放已确定的发送窗口上限。 紧急指针：在标志位 URG=1 时才有效，它指出本报文中的紧急数据的字节数。 每个TCP数据包的格式都是固定的，都包含了端口号，序号，确认序号，标志位等。 三次握手和四次握手TCP 建立连接需要经过三次握手 (three-way handshake)，关闭连接需要经过四次握手。 建立连接的三次握手 第一次，客户端发送一个数据包：TCP首部的标志位SYN被设置为1，并且序号为初始序号ISN(Initial Sequence Number)。此时，客户端处于 SYN_SENT 状态。 第二次，服务器收到客户端的连接请求后，由标志位SYN为1知道这个是建立TCP连接的请求，返回一个数据包：TCP首部的标志位SYN和ACK都被设置为1；序号为服务器端的ISN；确认序号为客户端序号 + 1。此时，服务器处于 SYN_RCVD 状态。 第三次，客户端收到服务端的返回数据之后，由标志位SYN和ACK为1知道服务器同意建立TCP连接的确认数据包。检查确认序号的值(第一次握手客户端发送的序号 + 1)，标志位SYN和ACK都正确之后，返回一个数据报给服务器：SYN=0；ACK=1；序号递增 (即上次序号 + 1)；确认序号的值为服务器发送过来的序号 + 1。服务器收到这个数据包并检查数据报正确之后，客户端和服务端成功建立TCP连接，进入 ESTABLISHED 状态。 关闭连接的四次握手 第一次，主动关闭的那一端(假设为客户端)发送一个关闭连接FIN数据包：TCP首部的标志位FIN设置为1；序号为正常递增值。此时，客户端进入为 FIN_WAIT_1 状态。 第二次，另一端收到数据包之后，由FIN为1知道这是另一端关闭连接的请求。然后返回一个确认数据包：TCP首部标志位ACK设置为1；确认序号为发端序号 + 1；序号正常递增值。此时，服务器进入 CLOSE_WAIT 状态。当客户端收到确认数据包之后进入 FIN_WAIT_2 状态。 第三次，当服务端发送完数据之后，向客户端发送一个关闭连接数据包：TCP首部的标志位FIN设置为1;序号为正常递增值。此时，服务端进入 LAST_ACK 状态。 第四次，客户端收到数据包之后，由FIN为1知道这是服务端要关闭连接了，然后返回一个确认数据包：TCP首部标志位ACK设置为1；确认序号为收到的序号 + 1；序号为正常递增值。此时，客户端进入 TIME_WAIT 状态。 为什么建立连接是三次握手不是两次握手？关闭连接要四次握手？ 建立连接的时候，当客户端收到服务端的确认信息之后(第二次握手)就已经知道了服务端同意了连接，为什么还要再发送确认数据包给服务端(第三次握手)？ 第三次握手，是对第二次握手的确认。假如不进行第三次握手，服务端发送了SYN的确认数据包之后就直接处于 ESTABLISH 状态。这个确认数据包发送过程中出错，没有发送到给客户端怎么办？所以，一定要进行第三次握手。 关闭TCP连接为什么要四次握手？ TCP连接是全双工的通信，关闭的时候需要每个方向进行单独地关闭。当一端主动请求关闭的时候，被动的一端可能还有数据没有发送完毕，不能够立即关闭，所以不能够同时回复FIN + ACK，只能够先回复ACK数据包(第二次握手)，此时属于半关闭状态。当处理完数据之后，被动关闭的一端再发送FIN包给主动关闭的一端关闭连接。 ISNreference","categories":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://lizsgh.github.io/categories/TCP-IP/"}],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"https://lizsgh.github.io/tags/tcp-ip/"}],"keywords":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://lizsgh.github.io/categories/TCP-IP/"}]},{"title":"Object Oriented Programming","slug":"python/object_oriented_programming","date":"2017-12-31T16:00:00.000Z","updated":"2019-02-26T07:15:49.328Z","comments":true,"path":"2018/01/01/python/object_oriented_programming/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/python/object_oriented_programming/","excerpt":"","text":"OOP (Object Oriented Programming)面向对象的三大基本特征：封装、继承、多态。 封装：把客观事物封装成抽象的类，而且类中特定的属性或方法可以只提供给特定的类或对象使用，从而做到隐蔽性和安全性。 继承：继承可以让新创建的类获得被继承的类的属性和方法。通过继承创建的新类成为“子类”或“派生类”，被继承的类成为“父类”、“基类”或“超类”。继承概念的实现：实现继承和接口继承。 实现继承，是指子类可以直接使用基类的属性和方法； 接口继承，是指基类仅提供了一个接口方法，子类必须先实现了才能够使用。 某些 OOP 语言中，一个子类可以继承多个基类 (多重继承)。 多态：指子类重新定义父类的虚方法 (virtual, abstract)。当子类重新定义了父类的虚方法后，父类根据赋给它的不同子类，动态调用属于子类的该方法。 面向对象的五大基本原则：单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则。 单一职责原则 (SRP, Single Responsibility Principle)：就一个类而言，应该仅有一个引起它变化的原因。简言之，就是一个类的功能要单一。 开放封闭原则 (OCP, Open-Close Principle)：对扩展开放，对修改封闭。 里氏替换原则 (LSP, the Liskov Substitution Principle)：子类应当可以替换父类出现在父类能够出现的任何地方。 依赖倒置原则 (DIP, the Dependency Inversion Principle)：传统结构化编程中，最上层的模块通常要依赖下层模块来实现，即高层依赖低层。DIP 原则就是要让高层模块不依赖低层模块，二者都应该依赖抽象。抽象不应该依赖具体 (细节)，而具体 (细节) 应该依赖抽象。模块间的依赖通过抽象发生，实现类之间不产生直接的依赖关系，而是通过接口或抽象类产生。接口或抽象类不依赖于实现类；实现类依赖于接口或抽象类。 接口隔离原则 (ISP, Interface Segregation Principle)：使用多个专门的接口比使用大一的总接口要好。使用多个专门的接口比使用大一的总接口要好 重载与覆盖重载 (overload)重载，指函数具有相同的函数名，但这些同名函数具有不同的参数列表 (如：参数个数、参数类型、参数顺序等)。返回值可以相同也可以不同。 重载的实现：编译器根据不同的参数表对同名函数的名称做修饰，如：function func(p:integer) -&gt; integer_func； function func(p:string) -&gt; string_func。对编译器而言，这些同名方法就成了不同的方法，而且它们的调用地址在编译期间就绑定了，可以说是“早绑定”或“静态绑定”。 覆盖/重写 (override)覆盖存在类中，子类重写从父类继承过来的函数。但函数名、返回值、参数列表都必须和父类一样。当子类的实例对象调用的时候，会先调用自身的，没有再调用父类的。 如果子类覆盖的是基类的虚函数，则可以实现多态。当子类重新定义基类的虚函数后，基类指针可以根据赋给它的不同子类指针动态的调用子类中的该函数，可以做到动态绑定，即多态。 重载与覆盖 重载要求函数名相同，但是参数列表不同，返回值可以相同也可以不同；覆盖要求函数名、参数列表和返回值都相同。 在类中，重载是同一个类中不同成员函数之间的关系；而覆盖则是子类和基类之间不同成员函数之间的关系。 重载函数的调用是根据参数列表来决定调用哪个函数；覆盖函数的调用则根据对象的不同来决定调用哪个函数。 在类中，函数重载不能够实现多态；而子类对基类虚函数的覆盖则可以实现多态。 多态与重载 多态：基于对抽象方法的覆盖来实现，当子类重新定义基类的虚函数后，基类根据赋给它的不同子类，动态的调用子类中的该函数。多态可以说是“晚绑定”或“动态绑定”。 重载：指函数具有相同的函数名，但这些同名函数具有不同的参数列表。在编译期间就已经绑定调用地址了，是“早绑定”或“静态绑定”。而且，重载只是一种语言特性，一种语法规则，与多态无关，与面向对象也无关。 构造函数与析构函数构造函数：一种特殊的方法，主要用于在创建对象时初始化对象。析构函数：与构造函数相反，当对象结束其生命周期 (如对象所在的函数已调用完毕)，系统自动执行析构函数。 Python 分别用__init__()和__del__()来实现构造函数和析构函数。 混入类 混入类被定义为，一种被设计为通过继承与其它类结合的类，它给其它类提供可选择的接口或功能。 从概念上讲，混入类不定义新类，只是提供接口或功能，便于重用；从实现上讲，混入类要求多继承。 混入类为多个不相干的子类提供方法实现，便于重用，但不会实例化，并且具体类不能只继承混入类。 Python 中没有声明混入类的正式方式，Luciano 推荐在名称中加入Mixin后缀。 12345678910111213class People(object): passclass HasCarsMixin(object): def has_cars(self): return Trueclass NoHasCarsMixin(object): def has_cars(self): return Falseclass XiaoMing(People, HasCarsMixin): pass OOP - Python 在 Python 中一切都是对象。 Python 支持多重继承，内置函数super()可以解决多重继承中父类方法被多次调用的问题。 Python 并没有覆盖 (override) 的概念，从这个角度来说，Python 不支持多态。 12345678910111213141516171819202122232425262728class A(object): def __init__(self): pass def __del__(self): pass def func(self): return 'A.func'class B(A): def func(self, arg=0): return 'B.func'class C(A): passB().func() # B.funcB.func&lt;function __main__.B.func&gt;B().func&lt;bound method B.func of &lt;__main__.B object at 0x7f..&gt;&gt;C().func() # A.funcC.func&lt;function __main__.A.func&gt;C().func&lt;bound method A.func of &lt;__main__.A object at 0x7f...&gt;&gt; Python 中没有覆盖 (override) 的概念，子类重写父类的方法，其实只是把同名函数绑定到不同的函数对象。 Python 没有像 Java 等语言一样的接口概念，为了解决继承结构中接口和实现的问题，可以人为的设计一些规范。 123class A(object): def func(self): raise NotImplementdError 继承A的子类如果要使用func方法就要先实现，不然抛出异常。纵然如此，A还是可以被实例化的，而且无法强制A的子类必须实现func接口。Python 虽然没有接口的语法定义，但是还是有抽象类的概念的，使用抽象类实现类似接口的功能： 12345from abc import abstractmethod, ABCMetaclass A(metaclass=ABCMeta): @abstractmethod def func(self): pass Python 实现抽象类需要使用 abc 模块，抽象类A不会被实例化。 Python 不支持多态，也不用支持多态，Python 是一种多态语言，崇尚鸭子类型 (duck typing，当看到一只鸟走起来像鸭子、游泳起来像鸭子和叫起来也像鸭子，那么这只鸟就可以被成为鸭子)。鸭子类型不关注对象的类型，而是关注对象的行为 (方法)。鸭子类型像多态一样工作，但是没有继承关系。类与类之间不用共同继承同一个父类，只需要将它们做的像同一种事物，就能够实现：面向接口编程，而不是面向实现编程。 耦合与内聚耦合耦合性，也称块间联系，是软件系统结构中模块间相互关联紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。耦合程度取决于各个模块间接口的复杂程度、调用的方式，以及传递的信息。耦合分为七种： 内容耦合：一个模块直接访问另一个模块的内容。具体表现为： 一个模块直接访问另一个模块的内部数据。 一个模块不通过正常入口而直接转入到另一个模块的内部。 两个模块有一部分代码重叠 (该部分代码具有一定的独立功能)。 一个模块有多个入口。 公共耦合：一组模块都访问同一个公共数据环境。公共数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。 外部耦合：一组模块访问同一全局简单变量而不是同一全局数据结构，而且不通过参数传递该全局变量的信息。 控制耦合：模块之间传递的不是数据信息，而是控制信息 (如，标志、开关量等)，一个模块控制了另一个模块的功能。 标记耦合：调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称特征耦合。标记耦合的模块间传递的不是简单变量，而是像高级语言中的数据名、记录名和文件名等数据结果，这些名字即为标记，其实传递的是地址。 数据耦合：调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的值传递。 非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，非直接耦合的模块独立性最强。 耦合是影响软件复杂程度和设计质量的一个重要因素，为提高模块的独立性，应建立模块间尽可能松散的系统，在设计上我们应采用一下原则：若模块间必须存在耦合，应尽量使用数据耦合，少用控制耦合，慎用或有控制地使用公共耦合，并限制公共耦合的范围，尽量避免内容耦合。 内聚内聚性，又称内联系，指模块的功能强度的度量，即一个模块内容各个元素彼此结合的紧密程度的度量。若一个模块内个元素 (语名之间、程序段之间) 联系的越紧密，则它的内聚性就越高。 所谓高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一职责原则。 内聚有如下分类 (顺序按照内聚度由弱到强)： 偶然内聚：也称巧合内聚，模块内的各部分之间没有联系，或即使有联系也和松散，只是偶然地被凑到一起。 逻辑内聚：把几种相关的功能组合到一起，每次被调用时，由传递给模块的参数来确定该模块应该完成哪种功能。 时间内聚：又称经典内聚，这种模块大多为多功能模块，但模块的各个功能的执行与时间有关，通常要求所有功能必须在同一时间内执行。例如，初始化模块和终止模块。 过程内聚：构件或者操作的组合方式时，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。模块完成多个需要按一定的步骤一次完成的功能。(过程相关—控制耦合)。例如：在用程序流程图设计模块时，若将程序流程图中的一部分划出各自组成模块，便形成过程内聚。 通信内聚：指模块内所有处理元素都在同一个数据结构上操作或所有处理功能都通过公用数据而发生关联 (有时称之为信息内聚)。即指模块内各个组成部分都是用相同的数据或产生相同的数据结构。 顺序内聚：一个模块中各个处理元素和同一个功能密切相关，而且这些处理必须顺序执行，通常一个处理元素的输出是后一个处理元素的输入。顺序内聚的内聚度比较高，但缺点是不如功能内聚易于维护。 功能内聚：模块内所有元素的各个组成部分都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分。即模块仅包括为完成某个功能所必须的所有成分，这些成分紧密联系、缺一不可。 功能内聚是最强的内聚，其优点是功能明确。判断一个模块是否功能内聚，一般从模块名称就能够看出。如果模块名称只有一个动词和一个特定的目标 (单数名词)，一般来说就是功能内聚，如：“计算水费”、“计算产值”等模块。 模块划分时，要遵循“一个模块，一个功能”的原则，尽可能使模块达到功能内聚。","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Selenium","slug":"python/selenium","date":"2017-12-17T16:00:00.000Z","updated":"2019-02-26T09:24:29.055Z","comments":true,"path":"2017/12/18/python/selenium/","link":"","permalink":"https://lizsgh.github.io/2017/12/18/python/selenium/","excerpt":"","text":"selenium2 版本，可以用 Selenium + PhantomJS 来爬取异步加载的网页信息。selenium3+ 的某个版本起，selenium已经抛弃Phantomjs了：UserWarning: Selenium support for PhantomJS has been deprecated, please use headless versions of Chrome or Firefox instead selenium selenium selenium python PhantomJS Selenium 是一款 web 应用自动化测试工具，selenium 本身是不带浏览器引擎，所以使用 selenium 进行自动化测试需要驱动其它浏览器。 Installation selenium1pip install selenium Selenium 简单应用1234from selenium import webdriverdriver = webdriver.Firefox(executable_path=&apos;/path/to/firefox&apos;)driver.get(&apos;http://www.lizs.cc&apos;) selenium 支持驱动 Firefox, Chrome, Opera, Safari 等浏览器。 webdriver.Firefox(): 返回一个 WebDriver 对象。 get(url): 用当前驱动的浏览器加载一个 url 页面。 注意：因为浏览器版本问题，有可能自动测试失败。 WebDriver 对象的常用属性和方法 常用属性 name: 浏览器的名称。 title: 加载页面的 title。 current_url: 当前页面的URL。 page_source: 加载页面的源码。 service: 启动浏览器的服务对象 switch_to: 返回一个SwitchTo对象。即当前页面选择(聚焦)的对象，如WebElement对象点击操作click()的时候如果弹窗，则当前就聚焦在弹窗，当前页面聚焦的元素可以用self.switch_to.alert来表示。 12345678from selenium import webdriverdriver = webdriver.Chrome(executable_path=&apos;/path/to/chromedriver&apos;)driver.get(&apos;http://www.lizs.cc&apos;)driver.name # the browser namedriver.title # the page titledriver.current_url # current url of the pagedriver.page_source # the response content 常用方法 get(url): 用当前浏览器session加载url。 set_page_load_time(seconds): 设置页面加载超时时间。 maxsize_window(): 设置浏览器全屏化。 set_window_size(width, height, windowHandle=&#39;current&#39;): 设置浏览器窗口大小 forward(): 前进。 back(): 后退。 refresh(): 刷新页面。 get_cookies(): 返回当前页面所有cookies的key/value字典。 get_cookie(name): 获取当前页面cookie中名为name的cookie值。 execute_script(script): 在当前窗口执行 JavaScript 代码 script close(): 关闭当前窗口。 quit(): 关闭浏览器。 定位元素，返回一个 WebElement 对象 find_element_by_name(name)/find_elements_by_name(name): 根据元素名称定位页面上的元素。 find_element_by_id(id)/find_elements_by_id(id): 根据元素ID定位页面上的元素。 find_element_by_tag_name(name)/find_elements_by_tag_name(name): 根据元素tag名称定位页面上的元素。 find_element_by_class_name(name)/find_elements_by_class_name(name): 根据元素class定位页面上的元素。 find_element_by_css_selector(selector)/find_elements_by_css_selector(selector): 根据 CSS 选择器定位元素。 find_element_by_xpath(xpath)/find_elements_by_xpath(xpath): 根据 xpath 规则定位元素。 1234567891011121314151617from selenium import webdriverdriver = webdriver.Chrome(execute_path=&apos;/path/to/chromedriver&apos;)driver.maxsize_window()driver.set_page_load_time(10) # 设置页面加载的超时时间，单位：秒。driver.get(&apos;http://www.lizs.cc&apos;)element = driver.find_element_by_name(&apos;a&apos;) # 查找当前页面中的一个&lt;a&gt;标签元素element.click() # 点击元素，一般会跳转到新页面print(driver.current_url) # 页面当前的URLdriver.back() # 后退print(driver.current_url)driver.forward()element = driver.find_element_by_xpath(&apos;//*[@onclick]&apos;) # 查找当前页面中有 onclick 动作的元素if element: element.click() driver.switch_to.alert.accept() # 如果当前页面有alert弹窗，接受driver.quit() # 退出浏览器 更多属性和功能查看 selemium.webdriver.remote.WebDriver 对象。 WebElement 对象的常用属性和方法 id: 获取元素的ID。 text: 获取元素的文本内容。 tag_name: 获取元素的 tag 名称。 size: 获取元素的大小(width, height)。 clear(): 如果元素是输入框，清除输入框的内容。 click(): 点击元素。 submit(): 提交表单。 send_keys(value): 模拟输入，即输入 value 到输入框。 更多属性和功能查看 selemium.webdriver.remote.WebElement 对象。 selenium.webdriver.common.keys.Keys 键盘对象Keys 对象定义了键盘上相应按键的编码，可以通过 WebElement.send_keys() 进行操作。 WebElement.send_keys(Keys.TAB): 清除元素输入框的内容，同 click() WebElement.send_keys(Keys.ENTER): 回车操作 WebElement.send_keys(Keys.CONTROL, &#39;a&#39;): 全选输入框的内容 WebElement.send_keys(Keys.CONTROL, &#39;c&#39;): 复制选中的内容 selenium.webdriver.common.action_chains.ActionChains 鼠标对象 ActionChains(WebDriver).click(WebElement).perform(): 鼠标点击。 ActionChains(WebDriver).double_click(WebElement).perform(): 鼠标双击。 ActionChains(WebDriver).context_click(WebElement).perform(): 鼠标右键点击。 PhantomJSPhantomJS 是一个基于 Webkit 的 headless 浏览器。PhantomJS 没有交互界面，并且Selenium 驱动 PhantomJS 速度比 Firefox、chrome 等快。所以，用 Selenium + PhantomJS 来爬取异步加载的网页信息。 PhantomJS 可以从官网免费下载 PhantomJS。 Selenium + PhantomJS1234from selenium import webdriverdriver = webdriver.PhantomJS(executable_path=&apos;/path/to/phantomjs&apos;, service_log_path=&apos;/path/to/save/log&apos;, service_args=[])driver.get(&apos;http://www.lizs.cc&apos;) 在初始化 WebDriver 对象的时候可以指定一些其它选项： service_log_path：指定日志文件的路径，默认为当前目录下的 ghostdriver.log service_args: 列表，执行 PhantomJS 时传递给 PhantomJS 的参数。如：[&#39;--ignore-ssl-error=true&#39;]。更多参数可以查看 PhantomJS command line。 执行到 webdriver.PhantomJS() 的时候，会在后台启动一个 PhantomJS 进程，其中包含了一个选项 --webdriver=xx， xx 为分配的 socket 端口号。可以用 driver.service.port 来获取。12$ ps -ef | grep phantomjslizs 12027 1542 0 Feb27 ? 00:12:07 /home/lizs/apps/my-project/utils/phantomjs --cookies-file=/tmp/tmpOzM7CL --webdriver=56849 ChromeChrome和Firefox最新的版本已经支持headless了。headless-chrome 123456789101112from selenium.webdriver import Chromefrom selenium.webdriver.chrome.options import Optionsurl = &apos;http://www.lizs.cc&apos;options = Options()options.add_argument(&apos;--headless&apos;)options.add_argument(&apos;--disable-gpu&apos;)options.add_argument(&apos;--window-size=1280,1696&apos;)options.binary_location = &apos;/path/to/chrome&apos;driver = webdriver.Chrome(executable_path=&apos;/path/to/chromedriver&apos;, chrome_options=options)driver.set_page_load_timeout(15)driver.get(url)","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Linux add autossh system service","slug":"linux/linux_add_autossh_system_service","date":"2017-11-11T16:00:00.000Z","updated":"2019-02-26T08:09:09.631Z","comments":true,"path":"2017/11/12/linux/linux_add_autossh_system_service/","link":"","permalink":"https://lizsgh.github.io/2017/11/12/linux/linux_add_autossh_system_service/","excerpt":"","text":"Linux autossh + ssh 设置 sockets5 代理翻墙Linux - LSBInitScript 系统服务脚本 /etc/init.d/autossh-proxy:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#!/bin/sh### BEGIN INIT INFO# Provides: autossh-proxy# Required-Start: $network# Required-Stop: $network# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: start and stop autossh-proxy# Description: autossh-proxy is a manager of socket5 proxy by ssh### END INIT INFO# Author: lizs &lt;lizsmail.com&gt;PATH=/sbin:/bin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbinNAME=autosshAUTOSSH=/usr/bin/autosshAUTOSSH_PIDFILE=/var/run/$NAME.pid# AUTOSSH_LOGFILE=/var/log/$BASE.log# autossh can use environment variables to control features, e.g. AUTOSSH_PID.# more info see `man autossh`AUTOSSH_PID=&quot;/usr/bin/env AUTOSSH_PIDFILE=$&#123;AUTOSSH_PIDFILE&#125;&quot;# The autossh argsAUTOSSH_ARGS=&quot;-M 0 -fqTN -D 1080 root@alizs.cc&quot;# Get lsb functions. /lib/lsb/init-functionsdo_start()&#123; start-stop-daemon --start --quiet --oknodo \\ --pidfile $AUTOSSH_PIDFILE \\ --make-pidfile \\ --exec $AUTOSSH_PID $AUTOSSH \\ -- $AUTOSSH_ARGS RETVAL=&quot;$?&quot; return &quot;$&#123;RETVAL&#125;&quot;&#125;do_stop()&#123; # Return # 0 if the daemon has been stopped # 2 if the daemon could not be stopped # other if a failure occured start-stop-daemon --stop --quiet --oknodo \\ --retry=TERM/5/KILL/5 \\ --pidfile $AUTOSSH_PIDFILE \\ --remove-pidfile RETVAL=&quot;$?&quot; return &quot;$&#123;RETVAL&#125;&quot;&#125;do_restart()&#123; exit 0&#125;case &quot;$1&quot; in status) if init_is_upstart; then exit 1 fi status_of_proc -p &quot;$&#123;AUTOSSH_PIDFILE&#125;&quot; &quot;$&#123;AUTOSSH&#125;&quot; &quot;$&#123;NAME&#125;&quot; ;; start) if init_is_upstart; then exit 1 fi log_begin_msg &quot;Starting $&#123;NAME&#125;...&quot; do_start log_end_msg &quot;$?&quot; # e.g. [ok], failed!, (warning) ;; stop) if init_is_upstart; then exit 1 fi log_begin_msg &quot;Stopping $&#123;NAME&#125;...&quot; do_stop log_end_msg &quot;$?&quot; ;; restart) if init_is_upstart; then exit 1 fi log_begin_msg &quot;Restarting $&#123;NAME&#125;&quot; do_restart log_end_msg &quot;$?&quot; ;; force-reload) exit 0 ;; *) log_failure_msg &quot;Usage: service $&#123;NAME&#125; &#123;status|start|stop|restart&#125;&quot; ;;esac 添加系统服务将服务脚本添加到 /etc/init.d/ 目录下之后，就可以添加系统服务了。 CentOSRedhat 提供了 chkconfig 命令来管理系统的服务： chkconfig --list：所有服务列表 chkconfig --list serviceName：只显示 serverName 服务 chkconfig serviceName on：开启 serverName 服务的自动启动 chkconfig serviceName off：关闭 serverName 服务的自动启动 chkconfig --add serviceName：添加服务 chkconfig --del serviceName：删除服务 UbuntuUbuntu 是没有 chkconfig 命令的，而是提供了另外的命令来实现管理服务： sudo update-rc.d serviceName defaults：添加服务，默认添加服务为自动启动，即 /etc/rc0.d/ 到 /etc/rc6.d 各级别里面都添加了服务的启动软链接。 sudo update-rc.d serviceName remove：删除服务，默认会删除所有级别的服务，即彻底删除服务。 如果，你想要配置各级别的启动情况，可以删除相应级别目录里面的服务软链接。 systemctl daemon-reload：修改过服务之后，用该命令来重新加载服务。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Linux - LSBInitScript","slug":"linux/linux_LSBInitScript","date":"2017-11-10T16:00:00.000Z","updated":"2019-02-26T08:11:37.892Z","comments":true,"path":"2017/11/11/linux/linux_LSBInitScript/","link":"","permalink":"https://lizsgh.github.io/2017/11/11/linux/linux_LSBInitScript/","excerpt":"","text":"wiki: LSBInitScriptsLinux Standard Base Core Specification 3.1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#!/bin/sh### BEGIN INIT INFO# Provides: autossh-proxy# Required-Start: $network# Required-Stop: $network# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: start and stop autossh-proxy# Description: autossh-proxy is a manager of socket5 proxy by ssh### END INIT INFO# Author: lizs &lt;lizsmail.com&gt;PATH=/sbin:/bin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbinNAME=autosshAUTOSSH=/usr/bin/autosshAUTOSSH_PIDFILE=/var/run/$NAME.pid# AUTOSSH_LOGFILE=/var/log/$BASE.log# autossh can use environment variables to control features, e.g. AUTOSSH_PID.# more info see `man autossh`AUTOSSH_PID=&quot;/usr/bin/env AUTOSSH_PIDFILE=$&#123;AUTOSSH_PIDFILE&#125;&quot;# The autossh argsAUTOSSH_ARGS=&quot;-M 0 -fqTN -D 1080 root@alizs.cc&quot;# Get lsb functions. /lib/lsb/init-functionsdo_start()&#123; start-stop-daemon --start --quiet --oknodo \\ --pidfile $AUTOSSH_PIDFILE \\ --make-pidfile \\ --exec $AUTOSSH_PID $AUTOSSH \\ -- $AUTOSSH_ARGS RETVAL=&quot;$?&quot; return &quot;$&#123;RETVAL&#125;&quot;&#125;do_stop()&#123; # Return # 0 if the daemon has been stopped # 2 if the daemon could not be stopped # other if a failure occured start-stop-daemon --stop --quiet --oknodo \\ --retry=TERM/5/KILL/5 \\ --pidfile $AUTOSSH_PIDFILE \\ --remove-pidfile RETVAL=&quot;$?&quot; return &quot;$&#123;RETVAL&#125;&quot;&#125;do_restart()&#123; exit 0&#125;case &quot;$1&quot; in status) if init_is_upstart; then exit 1 fi status_of_proc -p &quot;$&#123;AUTOSSH_PIDFILE&#125;&quot; &quot;$&#123;AUTOSSH&#125;&quot; &quot;$&#123;NAME&#125;&quot; ;; start) if init_is_upstart; then exit 1 fi log_begin_msg &quot;Starting $&#123;NAME&#125;...&quot; do_start log_end_msg &quot;$?&quot; # e.g. [ok], failed!, (warning) ;; stop) if init_is_upstart; then exit 1 fi log_begin_msg &quot;Stopping $&#123;NAME&#125;...&quot; do_stop log_end_msg &quot;$?&quot; ;; restart) if init_is_upstart; then exit 1 fi log_begin_msg &quot;Restarting $&#123;NAME&#125;&quot; do_restart log_end_msg &quot;$?&quot; ;; force-reload) exit 0 ;; *) log_failure_msg &quot;Usage: service $&#123;NAME&#125; &#123;status|start|stop|restart&#125;&quot; ;;esac Comment Conventions for Init Scripts Reference: Comment Conventions for Init Scripts 1234567891011### BEGIN INIT INFO# Provides: scriptname# Required-Start: $network# Required-Stop: $network# Should-Start: cgroup-lite# Should-Stop: cgroup-lite# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: short_description# Description: multiline_description### END INIT INFO 以上注释必须在以下两行分隔符内 12### BEGIN INIT INFO### END INIT INFO 前后两行分隔符内的注释要以 # 开头，并且后面至少要跟着一个空格。(Description 除外，Description注释可以是多行描述。) 1# &#123;keyword&#125;: arg1 [arg2 ...] Provides: boot_facility_1 [boot_facility_2 ...]Boot facilities provided by this init script. 该脚本要启动的服务的名称。 Required-Start: boot_facility_1 [boot_facility_2 ...]Facilities which must be available during startup of this service. The init-script system should insure init scripts which provide the Required-Start facilities are started before starting this script. 启动该脚本服务的依赖设备。 Required-Stop: boot_facility_1 [boot_facility_2 ...]Facilities which must be available during the shutdown of this service. The init-script system should avoid stopping init scripts which provide the Required-Stop facilities until this script is stopped. 关闭该脚本服务的依赖设备。 Should-Start: boot_facility_1 [boot_facility_2 ...]Facilities which, if present, should be available during startup of this service. This allows for weak dependencies which do not cause the service to fail if a facility is not available. 启动该脚本服务应该提供的依赖，如果没有，也不会造成启动服务失败。 Should-Stop: boot_facility_1 [boot_facility_2]Facilities which should be available during shutdown of this service. 关闭该脚本服务应该提供的依赖。 Default-Start: run_level_1 [run_level_2 ...] Default-Stop: run_level_1 [run_level_2 ...]which run levels should by default run the init script with a start (stop) argument to start (stop) the services controlled by the init script. 该脚本服务的运行等级(0~6)。Run Level: 0: halt 1: single user mode. 2: multiuser with no network services exported. 3: normal/full multiuser. 4: reserved for local user, default is normal/full multiuser 5: multiuser with a display manager or equivalent 6: reboot Short-Description: short_descriptionProvide a brief description of the actions of the init script. Limited to a single line of text. 脚本服务简述，只能够为一行。 Description: multiline_descriptionProvide a more complete description of the actions of the init script. May span mulitple lines. In a multiline description, each continuation line shall begin with a # followed by tab character or a # followed by at least two space characters. The multiline description is terminated by the first line that does not match this criteria. 脚本服务的详细描述，可以分为多行。多行描述的时候，第二行开始每一行必须要 # 开头接着一个 tab 或者至少两个空格。 Facility NamesBoot facilities are used to indicate dependencies in initialization scripts, as defined in Comment Conventions for Init Scripts. Facility names are assigned to scripts by the Provides: keyword. Facility names that begin with a dollar sign ($) are reserved system facility names. Note: Facility names are only recognized in the context of the init script comment block and are not available in the body of the init script. In particular, the use of the leading $ character does not imply system facility names are subject to shell variable expansion, since they appear inside comments. $local_fs: all local file systems are mounted. $remote_fs: all remote file systems are available. In some configurations, file systems such as /usr may be remote. Many applications that require $local_fs will probably also require $remote_fs. $network: basic networking is available. Example: a server program could listen on a socket. $named: IP name-to-address translation, using the interfaces described in this specification, are available to the level the system normally provides them. Example: if a DNS query daemon normally provides this facility, then that daemon has been started. $portmap: daemons providing SunRPC/ONCRPC portmapping service as defined in RFC 1833: Binding Protocols for ONC RPC Version 2 (if present) are running. $syslog: system logger is operational. $time: the system time has been set, for example by using a network-based time program such as ntp or rdate, or via the hardware Real Time Clock. The comment conventions described are only required for init scripts installed by conforming applications. Conforming runtime implementations are not required to use this scheme in their system provided init scripts. Init Script Functions Reference: Init Script Functions 1. /lib/lsb/init-functions Each conforming init script shall execute the commands in the file /lib/lsb/init-functions in the current environment (see shell special built-in command dot). init_is_upstart: If the currently running init daemon is upstart, return zero; if the calling init script belongs to package which also provides a native upstart job, it should generally exit non-zero in this case. status_of_proc: Return LSB status. $1: daemon，init script 启动的进程 $2: 进程名称 -p: optional, daemon 的 pid 文件1status_of_proc -p &quot;/var/run/nginx.pid&quot; &quot;/usr/bin/nginx&quot; &quot;nginx&quot; log_begin_msg: 记录并打印信息，一般用在执行某个操作的开始位置，记录信息可以在 /var/log/syslog 查看，int log_begin_msg (char *message)，传入值是一个信息字符串. 1log_begin_msg &quot;Starting autossh...&quot; log_end_msg: int log_end_msg (int exitstatus)，传入值是一个整型的退出状态值，根据状态值返回：[ok], failed!, (warning) 等等。 12start-stop-daemon --start ...log_end_msg &quot;$?&quot; log_success_msg, log_failure_msg, log_warning_msg …更多函数说明可以查看 /lib/lsb/init-functions。 Init Script Actions Reference: Init Script Actions Init scripts provided by conforming applications shall accept a single argument which selects the action: start: Start the service stop: Stop the service restart: Stop and restart the service if the service if already running, otherwise start the service. try-restart: Restart the service if the service is already running. reload: Cause the configuration of the service to be reloaded without actually stoping and restarting the service. force-reload: Cause the configuration to be reloaded if the service support this, otherwise restart the service if it is running. status: Print the current status of the service. The start, stop, restart, force-reload and status actions shall be supported by all init scripts; the reload and try-restart actions are optional. Other init-scripts actions may be defined by the init script. 1234567891011121314151617181920case &quot;$1&quot; in status) exit 0 ;; start) exit 0 ;; stop) exit 0 ;; restart) exit 0 ;; force-reload) exit 0 ;; *) log_failure_msg &quot;Usage: service $&#123;NAME&#125; &#123;status|start|stop|restart&#125;&quot; ;;esac Installation and removal of Init Scripts Reference: Linux - 管理系统服务 CentOSRedhat 提供了 chkconfig 命令来管理系统的服务： chkconfig --list：所有服务列表 chkconfig --list serviceName：只显示 serverName 服务 chkconfig serviceName on：开启 serverName 服务的自动启动 chkconfig serviceName off：关闭 serverName 服务的自动启动 chkconfig --add serviceName：添加服务 chkconfig --del serviceName：删除服务 UbuntuUbuntu 是没有 chkconfig 命令的，而是提供了另外的命令来实现管理服务： sudo update-rc.d serviceName defaults：添加服务，默认添加服务为自动启动，即 /etc/rc0.d/ 到 /etc/rc6.d 各级别里面都添加了服务的启动软链接。 sudo update-rc.d serviceName remove：删除服务，默认会删除所有级别的服务，即彻底删除服务。 如果，你想要配置各级别的启动情况，可以删除相应级别目录里面的服务软链接。 systemctl daemon-reload：修改过服务之后，用该命令来重新加载服务。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"HTTP - Authentication","slug":"http/http_authentication","date":"2017-10-31T16:00:00.000Z","updated":"2019-02-26T07:32:44.203Z","comments":true,"path":"2017/11/01/http/http_authentication/","link":"","permalink":"https://lizsgh.github.io/2017/11/01/http/http_authentication/","excerpt":"","text":"HTTP 提供了一套访问控制和认证的通用框架。最常用的 HTTP 认证方案是 HTTP Basic Authentication。 HTTP 常规的认证流程HTTP 通用的认证模型非常简单，就是质询/响应 (challenge/response) 框架。以 HTTP Basic Authentication 为例： 当客户端请求一个需要认证的资源时，服务器返回一条 401 (Unauthorized) 响应。并在 WWW-Authenticate 响应首部携带如何进行验证的相关信息，其中至少包含一种质询方式。 然后，客户端根据WWW-Authentication提供的认证要求，在请求中添加Authorization首部字段进行认证，值为相应认证方案的认证凭证 (如 Basic 认证方案：Basic + “用户名:密码”的 base64 编码)。 服务器验证通过，则返回正常的请求。如果认证错误，则返回 403 (Forbidden)。 代理认证 (Proxy Authentication)服务器可以委托代理服务器提供内部资源的统一访问控制，即代理认证。如果使用了 HTTP 代理服务器，客户端的访问的其实是代理服务器，请求先经过代理服务器，然后代理服务器根据请求的内容处理请求 (如，过滤掉请求或将请求转发到不同的服务器等等)。如果你的网站是发布到公网上的话，你的代理服务器就暴露在公网上了。如果你的代理服务器没有设置任何访问权限，就可能会被网上的大量代理扫描程序扫描出来，公布到各大免费代理站点。所以，代理服务器最好设置账号密码，而且不要是弱密码。 代理认证与 Basic 认证的过程类似，同样的基于 HTTP 质询/响应框架。 Basic Authentication Proxy Authentication 401 407 WWW-Authenticate Proxy-Authenticate Authorization Proxy-Authorization WWW-Authenticate 与 Proxy-AuthenticateWWW-Authenticate与Proxy-Authenticate响应头部指定了获取资源访问权限的身份验证方法。12WWW-Authenticate: &lt;type&gt; realm=&lt;realm&gt;Proxy-Authenticate: &lt;type&gt; realm=&lt;realm&gt; &lt;type&gt;：指验证的类型，如 Basic, Bearer, Digest, HOBA, Mutual等。 &lt;realm&gt;：保护区域的描述，或指定保护的范围。如果未指定 realm，通常客户端显示一个格式化的主机名来代替。 Authorization 与 Proxy-AuthorizationAuthorization与Proxy-Authorization请求消息首部，包含用来向 (代理) 服务器验证身份的凭证。同样需要指明验证的类型，其后跟着验证信息。验证信息可以被编码或者加密，取决于采用的是哪种验证类型。12Authorization: &lt;type&gt; &lt;credentials&gt;Proxy-Authorization: &lt;type&gt; &lt;credentials&gt; Nginx 搭建 HTTP Basic AuthenticationNginx ngx_http_auth_basic_module 可以实现 HTTP Basic Authentication 协议。1234location / &#123; auth_basic &apos;authentication&apos;; auth_basic_user_file conf.d/htpasswd;&#125; auth_basic: string | off，默认 off，不开启。开启 HTTP Basic Authentication 只需要填写一个字符串，该字符串会作为 realm 的值，在服务器质询客户端的返回头部信息 WWW-Authenticate 中显示，如：WWW-Authenticate: Basic realm=&quot;Authorication&quot;。 auth_basic_user_file: 指定访问的用户名和密码的配置文件，可以是相对路径或绝对路径的文件。当使用相对路径时，则相对 nginx 安装配置目录，如/etc/nginx/或/etc/nginx/conf.d/试了下都可以。文件配置内容格式，如htpasswd： 123# commentname1:password1name2:password2:comment 可以用 # 注释 可以设置多个用户名和密码，每行一个，用户名和密码之间用 : 隔开，注释也可以写在密码后面，用 : 隔开。 用户名直接填写，但是密码需要经过加密。如，Linux 系统，密码 123456 可以用 openssl passwd 123456 生成。 假设，刚刚搭建的服务器地址为：127.0.0.1。从浏览器访问 http://127.0.0.1 就会收到一个 401 质询，弹出一个用户名和密码的输入框。用户输入账号和密码之后，浏览器会用 : 将其连接起来，编成 base64 编码，然后将其放在请求头部的 Authorization 中发送给服务端。服务端验证通过后就可以正常浏览页面的内容了。 HTTP 基础认证过程 假如，nginx 配置好的认证页面为 http://127.0.0.1 telnet 建立一条 http 连接 1telnet 127.0.0.1 80 发送正常的请求，会返回 401 12345678910HEAD / HTTP/1.1Host: 172.16.105.114HTTP/1.1 401 UnauthorizedServer: BDSCAN/1.5.0Date: Wed, 17 Jan 2018 08:26:04 GMTContent-Type: text/htmlContent-Length: 195Connection: keep-aliveWWW-Authenticate: Basic realm=&quot;authentication&quot; 发送带验证信息的请求 12345678910111213HEAD / HTTP/1.1Host: 172.16.105.114Authorization: Basic bGl6czoxMjM0NTY=HTTP/1.1 200 OKServer: BDSCAN/1.5.0Date: Wed, 17 Jan 2018 08:26:59 GMTContent-Type: text/htmlContent-Length: 334Last-Modified: Tue, 16 Jan 2018 08:55:10 GMTConnection: keep-aliveETag: &quot;5a5dbdee-14e&quot;Accept-Ranges: bytes 验证信息放在请求头的 Authorization，即 Authorization: Basic base64-username-and-password。base64-username-and-password 为用户名和密码用 : 连接起来，并经过 base64 编码等到的字符串 (即上面的 bGl6czoxMjM0NTY=) 。Python(python2) 生成：12345import base64username = &apos;lizs&apos;password = &apos;123456&apos;msg = base64.b64encode(&apos;%s:%s&apos; % (username, password))","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"https://lizsgh.github.io/tags/http/"}],"keywords":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}]},{"title":"Linux - swap","slug":"linux/swap","date":"2017-07-01T16:00:00.000Z","updated":"2019-02-26T08:21:41.027Z","comments":true,"path":"2017/07/02/linux/swap/","link":"","permalink":"https://lizsgh.github.io/2017/07/02/linux/swap/","excerpt":"","text":"场景在一个内存只有 700M 左右的服务器上面使用 git push 一个带 submodule 的项目的时候，出错： 1fatal: Out of memory, malloc failed (tried to allocate 79691777 bytes) 当停止一些占用内存的服务之后，发现又可以正常 push。Stackoverflow 之后，解决办法有：添加内存或添加 swap 空间。cat /proc/swaps 之后发现服务器没有设置 swap 空间。 swap 简介计算机的内存分为物理内存和虚拟内存。物理内存，即实际内存大小（RAM）；虚拟内存，是由磁盘虚拟出来的，在内存不够的时候可以起到一个代替物理内存的作用，也就是 swap。 当产生一个新进程的时候，机器会判断当前物理内存是否有空闲运行该进程，如果没有，则会根据优先级将物理内存中运行的一个或多个进程挂起，并将挂起的进程放到 swap 中等待，然后，把这个新进程放入物理内存中运行。等到物理内存中有进程结束释放空间之后，再将在 swap 中挂起等待的进程调到物理内存中运行。 当物理内存使用达到一个比例之后，机器就会使用 swap 作为临时内存使用。这个比例保存在 /proc/sys/vm/swappiness 中，大小从 0 到 100。0，表示最大限度使用内存。更改该比例的大小： 1echo 60 &gt; /proc/sys/vm/swappiness 当物理内存和 swap 内存都使用完的时候，就会出现 out of memory 之类的错误。 添加/开启/关闭 swap 创建一个 swap 文件 1dd if=/dev/zero of=/root/swap1 bs=1M count=1024 执行完之后就会产生文件 /root/swap1 为了安全起见，设置一下文件的权限 1chmod 600 /root/swap1 将文件变为 swap 文件 1mkswap /root/swap1 开启 swap 1swapon /root/swap1 该命令还可以有其它参数，如 -p 设定 swap 的优先级。 使 swap 开机生效/etc/fstab 文件主要存放文件系统的静态信息。在文件中添加： 1/root/swap1 none swap defaults 0 0 各个参数之间可以用空格或 tab 键隔开。 关闭 swap 1swapoff /root/swap1 参考 unix/linux: 2 ways to add swap space","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"linux command - find","slug":"linux/cmd_find","date":"2017-06-30T16:00:00.000Z","updated":"2019-02-26T08:12:20.626Z","comments":true,"path":"2017/07/01/linux/cmd_find/","link":"","permalink":"https://lizsgh.github.io/2017/07/01/linux/cmd_find/","excerpt":"","text":"findsearch for files in a directory hierarchy 1find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] -H, -L, -P选项 -H, -L, -P 用来控制软连接的处理。 -H: 默认行为，不搜索软连接下的目录或文件。 -L: 搜索软链接。 -P: 不搜索软链接下的目录或文件，除非 当没有指定 -H, -L, -P时，-H 是默认行为，即不搜索软链接下的目录和文件。同时指定多个选项，最后一个有效。如：find -H -L .，-H 无效，-L 有效。 -D debugopts, -Olevel -D debugopts: 打印诊断信息 -Olevel: 允许查询优化，level: 0, 1, 2, 3 starting-point查询开始路径，默认为当前目录 .。 expressionexpression 表达式可以由以下部分组成：tests, actions, global options, positional options, operators。 tests -name pattern按目录名或文件名查找。pattern 不能够有 /，否则无效，如：-name a/b 无效。 123find -name &quot;apps.py&quot; # 查找当前目录下的 apps.py 文件find -name &quot;apps&quot; # 查找当前目录下名称为 apps 的文件或目录find /home -name &quot;app*&quot; # 查找 /home 目录下名称匹配 app* 的文件或目录 -iname patterniname(insensitive name). 用法同 -name，只是 pattern 对大小写不敏感。 -path pattern按路径查找。pattern 是路径。 1234find -path &quot;apps&quot; # 无结果，因为 apps 不是路径find -path &quot;./apps&quot; # 查找当前目录下的 apps 目录或文件find -path &quot;./apps*&quot; # 查找当前目录下路径以 apps 开头的目录或文件find /home -path &quot;*apps*&quot; # 在 /home 目录下查找包含 apps 的目录或文件 -ipath patterninsensitive path, 用法同 -path, 只是 pattern 对大小写不敏感。 -regex pattern和 -path 差不多。 -user uname按照文件或目录所属用户查找。 -group gname按照文件或目录所属组查找。 更多选项查看 find --help 或 man find。 actions -exec command ;对搜索的结果执行命令 command。如果命令是用搜索结果作为参数的，可以用 {} 作为占位符。 12find -path &quot;./apps*&quot; -execfind -path &quot;./apps*&quot; -exec file &#123;&#125; \\; -ok command ;类似 -exec，不过在执行命令 command 之前先要经过用户同意 (y/n) operators (expr)优先操作符，和一般运算的 () 一样。 ! expr取反 expr1 expr2与，即 expr1 和 expr2，相当于 Python 表达式 expr1 and expr2。 expr1 -a expr2同 expr1 expr2 expr1 -and expr2同 expr1 expr2，但是不遵循 POSIX。 expr1 -o expr2或，即 expr1 或 expr2，相当于 Python 表达式 expr1 or expr2。 expr1 -or expr2同 expr1 -o expr2，但是不遵循 POSIX。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"cmd","slug":"cmd","permalink":"https://lizsgh.github.io/tags/cmd/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Python - multiprocessing","slug":"python/multiprocessing","date":"2017-06-30T16:00:00.000Z","updated":"2019-02-26T07:28:13.442Z","comments":true,"path":"2017/07/01/python/multiprocessing/","link":"","permalink":"https://lizsgh.github.io/2017/07/01/python/multiprocessing/","excerpt":"","text":"multiprocessingPython 的 multiprocessing 模块的使用和 threading 类似。 multiprocessing 模块包含了很多有用的子模块：12345678__all__ = [ &apos;Process&apos;, &apos;current_process&apos;, &apos;active_children&apos;, &apos;freeze_support&apos;, &apos;Manager&apos;, &apos;Pipe&apos;, &apos;cpu_count&apos;, &apos;log_to_stderr&apos;, &apos;get_logger&apos;, &apos;allow_connection_pickling&apos;, &apos;BufferTooShort&apos;, &apos;TimeoutError&apos;, &apos;Lock&apos;, &apos;RLock&apos;, &apos;Semaphore&apos;, &apos;BoundedSemaphore&apos;, &apos;Condition&apos;, &apos;Event&apos;, &apos;Queue&apos;, &apos;JoinableQueue&apos;, &apos;Pool&apos;, &apos;Value&apos;, &apos;Array&apos;, &apos;RawValue&apos;, &apos;RawArray&apos;, &apos;SUBDEBUG&apos;, &apos;SUBWARNING&apos;, ] multiprocessing.Process用于创建子进程，Process 对象提供了和threading.Thread类似的使用API。12def __init__(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None): pass group: target: 进程的执行方法，在 run() 方法内被调用。 name: 进程名称 args: 传给进程执行方法 (target) 的参数，默认 ()。位置参数和关键字参数都可以传，不过一定要注意顺序，传一个参数的时候要注意 (a,) kwargs: 传给进程执行方法 (target) 的参数，只能够传关键字参数，默认 {}。 daemon: Python3.3 新增参数。可以通过 daemon 参数来定义创建的进程是否为 daemon 进程。如果 daemon 为 True，则创建的进程为 daemon 进程，否则，继承创建进程的 daemon 属性。 start()启动进程 run()进程执行的主要方法，方法里面实际上是调用了 target 参数的函数。所以进程的执行函数可以通过 target 参数传进来给 run()，也可以重写 run() 方法。 join(timeout=None)阻塞当前程序，知道所有进程退出，一个进程可以被 join() 多次。timeout： None，会一直阻塞，直到全部被 join() 的进程执行完，才继续执行主体下面的代码。 &gt;=0 的 float 时间(seconds)：阻塞一定时间。0，即不阻塞。注意，经测试总阻塞时间为所有进程 timeout 的时间总和。1234process_list = [multiprocessing.Process(target=xxx) for _ in range(5)] # 创建 5 个进程map(lambda p: p.start(), process_list) # 启动进程map(lambda p: p.join(timeout=1), process_list) # 设置阻塞模式print(&apos;END&apos;.center(100, &apos;-&apos;)) 创建进程，并且设置了每个进程阻塞 1s。所以 print(&#39;END&#39;.center(100, &#39;-&#39;)) 语句会在全部进程执行完或者 5s 之后才去执行。 name获取或设置进程名称。 ident进程标识符(pid)，非零整数。如果进程还没有开始，则返回None。 pid即ident exitcode进程的退出状态码。如果子进程还没有退出，则返回None。 authkey获取或设置进程的认证码。 daemon获取或设置进程 daemon 属性，设置 daemon 属性要在 start() 之前才会生效。如果不设置，会继承创建进程的程序的 daemon 属性值。如果进程为 daemon 进程，则主程序结束退出的时候，daemon 进程也会结束。 12345process_list = [threading.Thread(target=xxx) for _ in range(5)] # 穿件 5 个进程map(lambda p: setattr(t, &apos;daemon&apos;, True), process_list)map(lambda p: p.start(), thread_list) # 启动进程time.sleep(5)exit() 程序创建了 5 个进程，并且都是 daemon 进程。所以，无论进程有没有执行完，主程序执行完 (5s后)，所有进程也会退出。 注意：因为 daemon 进程是会随着主程序的退出而强制结束的，所以，当 daemon 进程的一些操作可能会得不到安全的结束 (如：操作文件的时候)。 start(), join(), is_alive(), terminate() 和exitcode只能够在主进程调用。 is_alive()返回当前进程是否存活。 terminate()结束进程。12current_process = multiprocessing.current_process()current_process.terminate() 因此，multiprocessing 模块创建子进程的方式也是和 threading.Thread 模块一样： 方法一，通过 multiprocessing.Process 传 target 参数 123456def process_run(): &quot;&quot;&quot;The sub process mainly run function.&quot;&quot;&quot; passprocess = multiprocessing.Process(target=process_run)process.start()process.join() 方法二，通过继承 multiprocessing.Process 对象，重写 run 方法 123456class SubProcess(multiprocessing.Process): def run(self): passprocess = SubProcess()process.start()process.join() multiprocessing 模块其它常用函数 multiprocessing.current_thread()返回当前子进程的 Process 对象。 multiprocessing.active_children()返回还没有结束的子进程列表。 multiprocessing.cpu_count()返回当前系统的 CPU 数量。 进程间通信 管道(pipe)：也叫无名管道，管道是一种半双工通信，数据只能够单方面流动，而且只能够在具有亲缘关系(如：父子进程)的进程间使用。 命名管道(FIFO)：有名管道也是半双工通信，但是它允许在无亲缘关系的进程间通信。 消息队列(message queue)：一个消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了管道只能够承载无格式字节流以及缓冲区大小限制等问题。 共享内存(share memory)：共享内存就是映射一段能被其它进程访问的内存，这个内存由一个进程创建，但是可以被多个进程访问。共享内存是最快的 IPC 方式。 信号(signal)：通过想向进程发送信号来通知进程要做什么事情。 信号量(semaphore)：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某个进程在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一个进程的不同线程之间的同步手段。 套接字(socket)：socket 也是一种进程间的通信机制。 reference multiprocessing 模块提供了以下进程间通信的方式: multiprocessing.Queue123456789def process_run(queue): process = multiprocessing.current_process() queue.put(process.name)q = multiprocessing.Queue()process = multiprocessing.Process(target=processe_run, args=(q,), name=&apos;sub_process&apos;)process.daemon = Trueprocess.start()print(q.get()) # sub_process multiprocessing.PipePipe(duplex=True) 会创建一条管道，返回一对multiprocessing.Connection对象 (conn1, conn2) 分别表示管道连接的两端。 duplex=True: 表示管道是双向的，即 conn1 和 conn2 都可以接收和发送信息。 duplex=False: 表示管道是单向的，conn1 只能够接收信息，conn2只能够发送信息。 123456789101112131415def process_run(conn): process = multiprocessing.current_process() while True: msg = conn.recv() if msg == &apos;start&apos;: conn.send(&apos;%s is starting&apos; % process.name) breakconn1, conn2 = multiprocessing.Pipe()process = multiprocessing.Process(target=process_run, args=(conn2,))process.daemon = Trueprocess.start()time.sleep(3)conn1.send(&apos;start&apos;)conn1.recv() multiprocessing.Value(typecode_or_type, *args, lock=True)返回一个共享内存的ctypes对象。multiprocessing.Value()实际上是调用了multiprocessing.sharedctypes.Value()。可以通过value属性来访问共享内存的值。 typecode_or_type: 返回对象的类型。可以是ctypes的类型或特定的类型字符。 12345678typecode_to_type = &#123; &apos;c&apos;: ctypes.c_char, &apos;b&apos;: ctypes.c_byte, &apos;B&apos;: ctypes.c_ubyte, &apos;h&apos;: ctypes.c_short, &apos;H&apos;: ctypes.c_ushort, &apos;i&apos;: ctypes.c_int, &apos;I&apos;: ctypes.c_uint, &apos;l&apos;: ctypes.c_long, &apos;L&apos;: ctypes.c_ulong, &apos;f&apos;: ctypes.c_float, &apos;d&apos;: ctypes.c_double &#125; *args: *args 是传给指定 typecode_or_type 类型的值，可以理解为初始化值。注意，typecode_or_type 的长度，如: c 为一个字节，即只能够传一个字节的字符串Value(&#39;c&#39;, &#39;a&#39;)。 lock: keyword-only 参数。默认为True，会自动添加一个递归锁来保护共享内存的读写。如果False，在不添加锁，也可以传一个Lock或Rlock来代替默认的锁。 multiprocessing.Array(typecode_or_type, size_or_initializer, *, lock=True)Array 实际上调用的是 multiprocessing.sharedctypes.Array，用法类似 Value，只不过Value只能够保存一个相应的类型的值，而Array则可以保存一个数组相应类型的值。 typecode_or_type: 同Value。 size_or_initializer: 初始化共享内存数组的值或指定该数组的大小。如果为整数时，则指定数组的大小，同时各个元素初始化的值为0；当为序列时，则代表初始化的值，并且该序列的长度为共享数组的长度。 lock: 同Value 1234567891011121314def process_run(mv, ma): print(mv.value) mv.value = 1 for i in range(len(ma)): print(ma[i]) ma[i] = imv = multiprocessing.Value(&apos;i&apos;, 0)ma = multiprocessing.Array(&apos;i&apos;, 10)process = multiprocessing.Process(target=process_run, args=(mv, ma))process.start()process.join()print(mv.value)print(&#123;i: ma[i] for in in range(len(ma))&#125;) multiprocessing.managers通过multiprocessing木块的managers对象创建的数据可以在进程间共享，甚至可以和不同网络的不同机器上面的进程共享。 multiprocessing.Manager12345def Manager(): from multiprocessing.managers import SyncManager m = SyncManager() m.start() return m multiprocessing.Manager 返回一个 SyncManager 实例对象，用于创建已注册类型的共享数据(Queue, list, dict 等)。默认注册的类型：12345678910111213141516171819SyncManager.register(&apos;Queue&apos;, Queue.Queue)SyncManager.register(&apos;JoinableQueue&apos;, Queue.Queue)SyncManager.register(&apos;Event&apos;, threading.Event, EventProxy)SyncManager.register(&apos;Lock&apos;, threading.Lock, AcquirerProxy)SyncManager.register(&apos;RLock&apos;, threading.RLock, AcquirerProxy)SyncManager.register(&apos;Semaphore&apos;, threading.Semaphore, AcquirerProxy)SyncManager.register(&apos;BoundedSemaphore&apos;, threading.BoundedSemaphore, AcquirerProxy)SyncManager.register(&apos;Condition&apos;, threading.Condition, ConditionProxy)SyncManager.register(&apos;Pool&apos;, Pool, PoolProxy)SyncManager.register(&apos;list&apos;, list, ListProxy)SyncManager.register(&apos;dict&apos;, dict, DictProxy)SyncManager.register(&apos;Value&apos;, Value, ValueProxy)SyncManager.register(&apos;Array&apos;, Array, ArrayProxy)SyncManager.register(&apos;Namespace&apos;, Namespace, NamespaceProxy)# types returned by methods of PoolProxySyncManager.register(&apos;Iterator&apos;, proxytype=IteratorProxy, create_method=False)SyncManager.register(&apos;AsyncResult&apos;, create_method=False) 简单例子：123456789101112def process_run(l, d): p = multiprocessing.current_process() l.append(p.name) d[p.pid] = p.namem = multiprocessing.Manager()l, d = m.list(), m.dict()process = multiprocessing.Process(target=Process_run, args=(l, d))process.start()process.join()print(l)print(d) multiprocessing.managers.BaseManager([address[, authkey])Manager 的基类。 address: 同参数address start([initializer[, initargs]) 启动一个子进程来开启Manager。如果initializer不为空并且为可执行的对象创建子进程时会调用initializer(*initargs)。 connect() 连接Manager，一般用于客户端进程。 register(ypeid[, callable[, proxytype[, exposed[, method_to_typeid[, create_method]]]]]) 注册一个自定义类型或可执行对象。 get_server()返回Manager的Server对象。Sever对象支持serve_forever()。 shutdown()关闭启动Manager的进程，start()之后才有意义，可以多次调用stop()。 自定义Manager，注册共享的方法，并在网络端口上暴露：1234567from multiprocessing.managers import BaseManagerfrom Queue import Queueclass QueueManager(BaseManager): passQueueManager.register(&apos;get_queue&apos;, lambda:Queue())qm = QueueManager(address=(&apos;&apos;, 50000), authkey=&apos;queue_manager&apos;)qm.get_server().serve_forever() 首先定义自定义一个Manager，然后注册要使用的属性或方法。注意，register() 是类方法，并且第二个参数是可调用对象，所以传Queue()而不是Queue 其它进程访问，可以是本地也可以是不同网络的进程。client1:12345678from multiprocessing.managers import BaseManagerclass QueueManager(BaseManager): passQueueManager.register(&apos;get_queue&apos;)qm = QueueManager(address=(&apos;xxxx&apos;, 50000), authkey=&apos;queue_manager&apos;)qm.connect()q = qm.get_queue()q.put(&apos;hello&apos;) client2:12345678from multiprocessing.managers import BaseManagerclass QueueManager(BaseManager): passQueueManager.register(&apos;get_queue&apos;)qm = QueueManager(address=(&apos;xxxx&apos;, 50000), authkey=&apos;queue_manager&apos;)qm.connect()q = qm.get_queue()q.get() # &apos;hello&apos; multiprocessing.Pool进程池。Poll(processes=None, initializer=None, initargs=(), maxtasksperchild=None): processes: 进程数，如果为None, 则去os.cpu_count()/multiprocessing.cpu_count()的值。 initializer/initargs: 如果initializer不为None, 则进程池的所有进程在启动的时候都会执行initializer(*initargs)。 maxtasksperchild: apply(func[, *args[, **kwargs]])进程池里面的一个进程会执行func(*args, **kwargs)，并且apply会阻塞主进程直到执行完毕。用法同python2的apply(*args, **kwargs)，*args必须为sequence，**kwargs必须为字典。如： 12345def process_run(x, y=None): return pow(x, y or x)pools = multiprocessing.Pool(5)result = pools.apply(process_run, (2,), &#123;&apos;y&apos;: 3&#125;) apply_async(func[, *args[, **kwargs[, callback[, error_callback]]]]) 类似apply，不过apply_async是异步进行的，不会阻塞主进程，并且返回 multiprocessing.pool.AsyncResult 对象。 callback: 可传入一个参数的可调用对象，当func(*args, **kwargs)执行完毕有结果的时候，传入执行结果来调用。 error_callback: 可以传入一个参数的可调用对象，当func(*args, **kwargs)执行出错的时候，传入Exception实例来调用。 1234567891011121314def process_run(x, y=None): time.sleep(5) return pow(x, y or x)def callback(x): print(x)pools = multiprocessing.Pool(5)# no block, but the result is a multiprocessing.pool.AsyncResult objectresult = pools.apply_async(process_run, (x,), &#123;&apos;y&apos;: 3&#125;, callback=callback)# wait until the result is available or until timeout seconds pass.result.wait(10)# get the result valueresult.get() map(func, iterable[, chunksize]) 相当于并行的内置函数map()，iterable的每一个元素都会作为参数传给func，然后进程池分别调用进程去执行。 123456def process_run(x, y): return pow(x, y)pools = multiprocessing.Pool(5)result = pools.map(process_run, zip(range(10), range(10)))print(result) map_async(func, iterable[, chunksize[, callback[, error_callback]]])类似map，不过map_async是异步进行，不会阻塞主进程，并且返回 multiprocessing.pool.AsyncResult 对象。 callback和error_callback的用同apply_async。 Python2.7在类里面使用apply(),map()会出现bug：cPickle.PicklingError: Can’t pickle : attribute lookup builtin.function failed multiprocess.pool.AsyncResult进程池异步调用返回结果，即由apply_async和map_async调用的返回结果。 get([timeout]): 获取返回结果。 timeout为None: 默认，会阻塞到有执行结果返回。 timeout不为None：设置阻塞的秒数，当超时还没有结果返回时，会引起 multiprocessing.TimeoutError。 当异步执行出错时，exception 也会由get引起。 wait([timeout]): 等待，直到有执行结果返回或超过超时时间。 ready(): True/False，返回调用是否执行完毕。 successful(): 当调用程序执行完毕时，返回执行有没有出错(True/False)；当调用程序没有执行完毕时，会引起AssertionError。","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - threading","slug":"python/threading","date":"2017-05-31T16:00:00.000Z","updated":"2019-02-26T07:28:34.569Z","comments":true,"path":"2017/06/01/python/threading/","link":"","permalink":"https://lizsgh.github.io/2017/06/01/python/threading/","excerpt":"","text":"threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None) group: target: 线程的执行方法，在 run() 方法内被调用。 name: 线程名称 args: 传给线程执行方法 (target) 的参数，默认 ()。位置参数和关键字参数都可以传，不过一定要注意顺序，传一个参数的时候要注意 (a,) kwargs: 传给线程执行方法 (target) 的参数，只能够传关键字参数，默认 {}。 daemon: Python3.3 新增参数。可以通过 daemon 参数来定义创建的线程是否为 daemon 线程。如果 daemon 为 True，则创建的线程为 daemon 线程，否则，继承创建线程的 daemon 属性。 start() 启动线程 run() 线程执行的主要方法，方法里面实际上是调用了 target 参数的函数。所以线程的执行函数可以通过 target 参数传进来给 run()，也可以重写 run() 方法。 join(timeout=None) 阻塞当前程序，一个线程可以被 join() 多次。timeout： None，会一直阻塞，直到全部被 join() 的线程执行完，才继续执行主体下面的代码。 &gt;=0 的 float 时间(seconds)：阻塞一定时间。0，即不阻塞。注意，经测试总阻塞时间为所有线程 timeout 的时间总和。1234thread_list = [threading.Thread(target=xxx) for _ in range(5)] # 创建 5 个线程map(lambda t: t.start(), thread_list) # 启动线程map(lambda t: t.join(timeout=1), thread_list) # 设置阻塞模式print(&apos;END&apos;.center(100, &apos;-&apos;)) 创建线程，并且设置了每个线程阻塞 1s。所以 print(&#39;END&#39;.center(100, &#39;-&#39;)) 语句会在全部线程执行完或者 5s 之后才去执行。 name 获取或设置线程名称。 ident 线程标识符，非零整数。 daemon 获取或设置线程 daemon 属性，设置 daemon 属性要在 start() 之前才会生效。如果不设置，会继承创建线程的程序的 daemon 属性值。如果线程为 daemon 线程，则主程序结束退出的时候，daemon 线程也会结束。 12345thread_list = [threading.Thread(target=xxx) for _ in range(5)] # 穿件 5 个线程map(lambda t: setattr(t, &apos;daemon&apos;, True), thread_list)map(lambda t: t.start(), thread_list) # 启动线程time.sleep(5)exit() 程序创建了 5 个线程，并且都是 daemon 线程。所以，无论线程有没有执行完，主程序执行完 (5s后)，所有线程也会退出。 注意：因为 daemon 线程是会随着主程序的退出而强制结束的，所以，当 daemon 线程的一些操作可能会得不到安全的结束 (如：操作文件的时候)。 is_alive() 返回当前线程是否存活。 threading 模块创建线程有两种方法： 方法一，通过 threading.Thread 传 target 参数 123456def thread_run(): &quot;&quot;&quot;The thread mainly run function.&quot;&quot;&quot; passthread = threading.Thread(target=thread_run)thread.start()thread.join() 方法二，通过继承 threading.Thread 对象，重写 run 方法 123456class SubThread(threading.Thread): def run(self): passthread = SubThread()thread.start()thread.join() threading 模块其它常用函数 threading.current_thread() 返回当前的 Thread 对象。 threading.enumerate() 返回当前存活的 Thread 对象的列表。注意：返回的 Thread 对象包括后台线程。如：&lt;_MainThread&gt;///, etc. threading.active_count() 放回当前存活的 Thread 对象数量。注意：该数量包括了后台线程，其实就是 enumerate() 列表的数量。 threading.get_ident() Python3.3 新增，其实就是 Thread 对象的 ident 属性。 threading.main_thread() Python3.4 新增，返回主线程。 A primitive lock is a synchronization primitive that is not owned by a particular thread when locked. In Python, it is currently the lowest synchronization primitive available, implemented directly by _thread extension module. 原始锁不属于任何线程。一把原始锁只有两种状态：locked 和 unlocked。刚创建的锁属于 unlocked 状态。 threading.Lock() 用于生成原始锁的工厂方法。 acquire(block=True, timeout=-1) 获取一把线程锁 (即把锁从 unlocked 状态设置为 locked 状态)。返回 True/False。 block: True/False，设置申请获取线程锁的模式：阻塞(True)或非阻塞(False)。 True: 当为阻塞模式时，会一直阻塞直到获取到线程锁为止，然后返回 True。所以，在这个模式当一个线程多次获取线程锁的时候会造成死锁。 123lock = threading.Lock()lock.acquire() # 申请线程锁lock.acquire() # 再次申请线程锁的时候会造成死锁 False: 当为非阻塞模式时，如果没有获取到线程锁会立即返回 False。 timeout: Python3.2 新增，当 block=True 时有效，设置阻塞的超时时间。 release() 释放线程锁 (即把锁设置为 unlocked 状态)，没有返回值。因为线程锁不是属于某个专属线程的，所以，释放锁 (release()) 的时候不一定要在上锁的那个线程。 当 release 一把 unlocked 状态的锁的时候会引起 release unlocked lock 错误。 threading 模块中所有包含 acquire() 和 release() 的对象，如：Lock(), RLock(), Condition(), Semaphore() 都可以用上下文管理器 with 语句来操作。1234rlock = threading.RLock()with rlock: with rlock: ... A reentrant lock is a synchronization primitive that may be acquired multipart times by the same thread. 可重入锁可以被同一个线程多次获取。可重入锁有 “owning thread” 的概念，即当一个线程获取到可重入锁的时候，这把锁是属于这个线程的。 当一个线程获取到可重入锁的时候，再次 acquire 可重入锁会立即成功返回。 可重入锁的 acquire 和 release 都必须要在同一个线程中，即一个线程 acquire 了多少次可重入锁，就必须 release 多少次。 Python 的 RLock() 其实就是在 Lock() 上做了一层封装，在 RLock() 对象里面添加了一个 __owner 和 __count 分别用来记录可重入锁的所属者和 acquire 层数。 threading.RLock() 用于生成可重入锁的工厂方法。 acquire(blocking=True, timeout=-1) 同 threading.Lock.acquire() release() 减少可重入锁的递归 acquire 层数，当对应最后一个 acquire 时，释放可重入锁 (即把锁设置为 unlocked 状态)，没有返回值。 线程对可重入锁是有一个拥有概念的，线程的每个 acquire 都必须在同一个线程 release。 当 release 一把 unlocked 状态的锁的时候会引起 release unlocked lock 错误。 threading.RLock 使用例子：12345678910111213141516171819class test(object): def __init__(self): self.val = [] self.rlock = threading.RLock() def func(self): self.rlock.acquire() self.val.append(1) self.rlock.release() def run(self): self.rlock.acquire() self.func() self.rlock.release() def main(self): thread_list = [threading.Thread(target=self.func) for _ in range(5)] map(lambda t: t.start(), thread_list) map(lambda t: t.join(), thread_list) 线程使用了可重入锁来保证列表的线性安全，如果将 func() 和 run() 里面的 RLock() 换成 Lock() 就会造成线程死锁。 threading.Event() 线程间事件管理器。实际上就是线程之间的一个共享标记变量，线程可以任意改变这个变量的值(True/False)，其它线程根据变量的值等待或做其它事情。 is_set() 如果标志为True，则返回True。 set() 设置标志为True。 clear() 设置标志为False。 wait(timeout=None) 阻塞，直到标志为True，或者超时timeout。默认timeout=None，表示会一直阻塞。 12345678910111213141516171819import timeimport threadingdef thread_run(n, event): while True: print(n) n -= 1 time.sleep(1) if n &lt;= 0: break # finish, set the flag to True event.set()event = threading.Event()thread = threading.Thread(target=thread_run, args=(10, event))thread.daemon = Truethread.start()event.wait(timeout=5) # the main process will wait and block 5 secondsprint(&apos;hello&apos;) # after 5 seconds","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - webbrowser","slug":"python/webbrowser","date":"2017-05-11T16:00:00.000Z","updated":"2019-02-26T08:00:07.802Z","comments":true,"path":"2017/05/12/python/webbrowser/","link":"","permalink":"https://lizsgh.github.io/2017/05/12/python/webbrowser/","excerpt":"","text":"webbrowser - Convenient Web-browser controller webbrowser 可以在命令行使用1python -m webbrowser -t/-n URL -t: 在浏览器的新页面(tab)上打开 URL -n: 在浏览器的新的窗口打开 URL(if possible)。 例子：在浏览器打开 http://alizs.cc，在命令行输入：1python -m webbrowser -t &apos;http://alizs.cc&apos; webbrowser.open(url, new=0, autoraise=True)用系统默认的浏览器打开 url。 webbrowser.get(using=None)通过 using 的值，返回浏览器控制器对象。默认返回系统默认浏览器控制器对象。比如，系统默认的浏览器是 Chrome，现在想要用系统上安装的 FIrefox 浏览器打开 http://alizs.cc。 12firefox = webbrowser.get(&apos;firefox&apos;)firefox.open(&apos;http://alizs.cc&apos;) 已经预定义的浏览器类型，可以通过 get() 方法来获取。如果系统存在该类型浏览器，则会返回相应的浏览器控制器对象。 Type Name Class Name ‘mozilla’ Mozilla(‘mozilla’) ‘firefox’ Mozilla(‘mozilla’) ‘netscape’ Mozilla(‘netscape’) ‘galeon’ galeon(‘galeon’) ‘epiphany’ Galeon(‘epiphany’) ‘skipstone’ BackgroundBrowser(‘skipstone’) ‘kfmclient’ Konqueror() ‘konqueror’ Konqueror() ‘kfm’ Konqueror() ‘mosaic’ BackgroundBrowser(‘mosaic’) ‘opera’ Opera() ‘grail’ Grail() ‘links’ GenericBrowser(‘links’) ‘elinks’ Elinks(‘elinks’) ‘lynx’ GenericBrowser(‘lynx’) ‘w3m’ GenericBrowser(‘w3m’) ‘windows-default’ WindowsDefault ‘macosx’ MacOSX(‘default’) ‘safari’ MacOSX(‘safari’) ‘google-chrome’ Chrome(‘google-chrome’) ‘chrome’ Chrome(‘chrome’) ‘chromium’ Chromium(‘chromium’) ‘chromium-browser’ Chromium(‘chromium-browser’) webbrowser.register(name, constructor, instance=None)注册一个名为 name 的浏览器类型。注册成功之后，可以通过类型名 name 来 get() 该浏览器控制器对象。 name: 浏览器类型名称。 constructor: 可调用的对象名称，用来构建浏览器对象 instance。当 instance 不为 None 时，才有效。 instance: 浏览器对象。 例一，用 constructor 来注册浏览器类型： 1234567def custom_browser(): browser_path = &apos;/usr/bin/firefox&apos; return webbrowser.BackgroundBrowser(browser_path)webbrowser.register(&apos;custom_browser&apos;, custom_browser)controller = webbrowser.get(&apos;custom_browser&apos;)controller.open(&apos;http://alizs.cc&apos;) 例二，用 instance 来注册浏览器类型： 12345browser_path = &apos;/usr/bin/firefox&apos;custom_browser = webbrowser.BackgroundBrowser(browser_path)webbrowser.register(&apos;custom_browser&apos;, None, custom_browser)controller = webbrowser.get(&apos;custom_browser&apos;)controller.open(&apos;http://alizs.cc&apos;)","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"HTTP - Cookies","slug":"http/http_cookies","date":"2017-05-01T16:00:00.000Z","updated":"2019-02-26T07:32:17.088Z","comments":true,"path":"2017/05/02/http/http_cookies/","link":"","permalink":"https://lizsgh.github.io/2017/05/02/http/http_cookies/","excerpt":"","text":"HTTP Cookie (web cookie, browser cookie) 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向该服务器发起请求时附加在请求首部 Cookie 字段发送给服务器。 Cookie 主要用于以下三个方面： 会话状态管理 (如用户登录状态、购物车、游戏分数或其它需要记录的信息等) 个性化设置 (如用户自定义设置、主题等) 浏览器行为跟踪 (如跟踪分析用户行为等) Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。Cookie 的大小不超过 4KB，而且每次请求都会发送回服务器，带来额外的性能开销。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API或更加高级的IndexedDB。 创建 Cookie当服务器收到 HTTP 请求时，服务器可以通过响应头部的 Set-Cookie 字段将 cookies 发送给客户端浏览器。浏览器收到响应之后，通常会保存下 cookies，之后对该服务器的每一次请求中都通过请求头部的 Cookie 字段将相应的 cookies 附带发送到服务器。 Set-Cookie响应首部Set-Cookie被用来由服务器端向客户端发送 cookies。Syntax:12345678910111213Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt; Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Max-Age=&lt;non-zero-digit&gt;Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Path=&lt;path-value&gt;Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; SecureSet-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; HttpOnlySet-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; SameSite=StrictSet-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; SameSite=Lax// Multiple directives are also possible, for example:Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;; Secure; HttpOnly &lt;cookie-name&gt;=&lt;cookie-value&gt;cookies 键值对。 &lt;cookie-name&gt;，键名。可以是除了控制字符 (CTLs)、空格 (spaces) 或制表符 (tabs) 之外的任何 US-ASCII 字符。同时，不能够包含以下分隔字符：()&lt;&gt;@,;:\\&quot;/[]?={}。 &lt;cookie-value&gt;，键值。可以是除了控制字符 (CTLS)、空格 (whitespace)、双引号 (double quotes)、逗号 (comma)、分号 (semicolon) 和反斜杠 (backslash) 之外的任意 US-ASCII 字符。该值可以也可以用双引号括起来，即cookie-name=&quot;cookie-value&quot;。关于编码：许多应用会对 cookie 值按照 URL 编码 (URL encoding) 规则进行编码，按照 RFC 规范，这不是必须的。不过编码可以将不规范的值转化为符合要求的值。 __Secure-前缀，以__Secure-为前缀的 cookie，必须与secure属性一同设置，同时必须应用于安全页面 (HTTPS)。 __Host-前缀，以__Host-为前缀的 cookie，必须与secure属性一起设置，必须应用于安全页面 (HTTPS)，而且不能够设置domain属性 (这样就不会发送给子域)，同时path属性的值必须为/。123456789// 当响应来自于一个安全域（HTTPS）的时候，二者都可以被客户端接受Set-Cookie: __Secure-ID=123; Secure; Domain=example.comSet-Cookie: __Host-ID=123; Secure; Path=/// 缺少 Secure 指令，会被拒绝Set-Cookie: __Secure-id=1// 缺少 Path=/ 指令，会被拒绝Set-Cookie: __Host-id=1; Secure// 由于设置了 domain 属性，会被拒绝Set-Cookie: __Host-id=1; Secure; Path=/; domain=example.com Expires=&lt;date&gt;可选，指定 cookie 的有效日期，格式和Date首部字段一样。注意：该有效日期是指客户端上的日期，不是服务端。如： 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Max-Age=&lt;non-zero-digit&gt;可选，指定 cookie 的有效时间，值为非零整数，单位为秒。如Max-Age=60，表示 cookie 在 60 秒之后就会过期。 Domain=&lt;domain-value&gt;可选，指定 cookie 可以送达的主机。如果不指定，默认为当前文档访问地址 (Document.location) 的主机，但是不包括子域名。如果指定了Domain，在一般包括子域名。如，Domain=mozilla.org，则 cookie 也可以发送到子域名中 (如developer.mozilla.org)。 Path=&lt;path-value&gt;可选，指定 cookie 允许发送的 URL 路径。字符%x2F (/) 为路径分隔符，子路径也会被匹配。如Path=/docs，则/docs, /docs/Web/, docs/Web/HTTP等都会被匹配。 Secure可选，标记为Secure的 Cookie 只应通过被 HTTPS 协议加密的请求发送给服务器。但即便设置了Secure标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure标记无法提供确实的安全保障。从 Chrome 52 和 Firefox 52 开始，不安全的站点 (http:) 无法使用 Cookie 的Secure属性。 HttpOnly可选，设置了HttpOnly属性的 Cookie 不能使用 JavaScript 的 Document.cookie 属性、XMLHttpRequest或Request API 进行访问，以防范跨站脚本攻击 (XSS)。 CookieCookie 是请求首部，会将由服务器通过 Set-Cookie 响应首部发送过来的 cookies 发送到服务器。这个首部可能会被完全移除，例如在浏览器的隐私设置为禁止用 cookie。1Cookie: name=value[; name2=value2; name3=value3; ...] 如：1Cookie: PHPSESSID=298zf09hf012fh2; csrftoken=u32t4o3tb3gg43; _gat=1; 会话期 cookies (Session cookies)会话期 cookies ，即Set-Cookie中不设置过期日期 (Expires) 或有效时间 (Max-Age) 的 cookies。会话期 cookies 会在浏览器关闭时自动删除。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 cookies 也会被保留下来，就像浏览器从来没有关闭一样。1Set-Cookie: sessionid=38afes7a8; HttpOnly; Path=/ 持久化 cookies (Permanent cookies)持久化 cookies，即指定了过期日期 (Expires) 或有效时间 (Max-Age) 的 cookies。持久化 cookies 与客户端关闭与否无关，只有过期了才会失效。1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 第三方 cookies每个 cookie 都会有与之关联的域 (Domain)，如果 cookie 的域和页面相同，那么我们称这个 cookie 为第一方 cookie (first-part cookie)。如果 cookie 的域和页面的域不同，则称之为第三方 cookie (third-part cookie)。 如，网站 A 上引用了网站 B 的一个 JS 脚本，当浏览器打开网站 A 的时候，也会请求网站 B 的这个脚本，这时候，网站 B 可以创建 cookie 一起响应返回。浏览器会将网站 B 的 cookie 也保存下来 (浏览器没有禁止第三方 cookie 的情况下)，这个 cookie 相对网站 A 来说就是第三方 cookie，只有用户访问网站 B 的时候使用。 利用第三方 cookies 进行精准推送广告 (如百度联盟)： 用户使用百度搜索的时候，百度搜索引擎会记住你的搜索内容，并设置了一个用户标识 cookie (BAIDUID)。 当用户访问嵌有百度推广广告的网页的时候，广告模块 (如&lt;iframe src=&quot;http://pos.baidu.com/...&quot;&gt;) 会携带这个 cookie 一起发送到服务器。然后，服务器根据这个用户标识找到你搜索过的内容，生成相应的广告返回。 DNT (Do-Not-Track)DNT请求首部字段表明了用户对于网站追踪的意愿。0，表示用户同意目标站点追踪用户的个人信息；1，表示用户不愿意目标站点追踪用户的个人信息。 用户对DNT的设置，可以使用Navigator.doNotTrack属性进行读取。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"https://lizsgh.github.io/tags/http/"}],"keywords":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}]},{"title":"HTTP - Cross-Origin Resource Sharing (CORS)","slug":"http/http_cors","date":"2017-04-30T16:00:00.000Z","updated":"2019-02-26T07:32:01.125Z","comments":true,"path":"2017/05/01/http/http_cors/","link":"","permalink":"https://lizsgh.github.io/2017/05/01/http/http_cors/","excerpt":"","text":"HTTP access control (CORS)跨域资源共享 CORS 详解 出入安全原因，浏览器限制了脚本跨域 HTTP 请求。一般情况下，当脚本发出跨域 HTTP 请求的时候，浏览器根据返回的头部信息，判断是否拦截返回的结果。通常情况出现错误提示如：`Access to XMLHttpRequest at ‘xxx’ from origin ‘xxx’ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.即，HTTP 请求的返回被浏览器拦截了。在 Chrome 浏览器上可以用插件 ‘Moesif Origin &amp; CORS Changer’ 来处理。 CORS 简介跨域资源共享 (CORS)，是一种在 HTTP 头部附加相应的信息来使浏览器允许 web 应用有权限跨域 HTTP 请求资源的机制。当 HTTP 请求的资源与自身的协议、域名或端口不一样的时候，这个 HTTP 请求就是跨域 HTTP 请求 (cross-origin HTTP request)。如，从前端地址为 http://localhost:8080/ 的应用页面 API 地址为 http://localhost:8000 的数据的时候。 跨域资源共享 (CORS) 机制支持安全的跨域请求，使请求数据可以安全地在浏览器与服务器传输。现代的浏览器可以通过 XMLHttpRequest 或 FetCh API 使用 CORS 机制来处理跨域 HTTP 请求。当然，这些都是浏览器自动处理的，不需要用户参与，而且即使 CORS 请求失败，在 JavaScript 代码层也无法获取错误信息，只能够在浏览器控制台查看。 CORS 标准是通过在 HTTP 头部添加相应的信息来实现跨域资源共享的。浏览器根据头部信息来进行简单请求或 (simple requests) 预检请求 (preflighted requests)。 简单请求CORS 简单请求，即浏览器直接发出 CORS 请求 (在请求头部信息添加 Origin字段) 到服务器，如果响应头部不存在Access-Control-Allow-Origin字段，则说明请求源不在服务器允许的跨域白名单里或服务器不支持跨域请求。 若满足以下所有条件，则该请求为简单请求： 请求方法： HEAD GET POST 请求头部字段不超出： Accept Accept-Language Content-Language Content-Type，仅限于： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用XMLHttpRequest.upload属性访问。 请求中没有使用 ReadableStream 对象。 CORS 简单请求示例：123456GET /api/base/ HTTP/1.1Host: localhost:8000Connection: keep-aliveOrigin: http://localhost:8080User-Agent: Mozilla/5.0 ...Accept-Language: zh-CN,zh;... 响应头部信息：123456789HTTP/1.1 200 OKDate: Thu, 27 Dec 2017 20:35:23 GMTServer: WSGIServer/0.2 CPython/3.6Content-Type: application/jsonVary: Accept, Cookie, OriginAllow: GET, HEAD, OPTIONSX-Frame-Options: SAMEORIGINContent-Length: 560Access-Control-Allow-Credentials: true 响应状态为 200，但是响应头部中没有Access-Control-Allow-Origin，说明服务器不支持跨域 HTTP 请求资源。 当服务器添加跨域请求白名单之后，响应头部信息为：1234567891011HTTP/1.1 200 OKDate: Thu, 27 Dec 2017 20:42:23 GMTServer: WSGIServer/0.2 CPython/3.6Content-Type: application/jsonVary: Accept, Cookie, OriginAllow: GET, HEAD, OPTIONSX-Frame-Options: SAMEORIGINContent-Length: 560Access-Control-Allow-Credentials: trueAccess-Control-Allow-Origin: http://localhost:8080Access-Control-Expose-Headers: X-CSRFToken, X-SessionId 响应头部Access-Control-Allow-Origin的值为*或请求头部 Origin 字段的值，则说明服务器同意跨域资源共享。 预检请求预检请求，是在发送真正的跨域请求之前先向服务器发送一个请求方法为 OPTIONS 的 HTTP 请求，来检测服务器是否允许当前请求源的跨域资源请求。 当浏览器发现这满足预检请求条件的时候 (即非简单请求)，会自动发出一个预检请求：1234567891011OPTIONS /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 ...Accept-Language: zh-CN,zh;...Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveOrigin: http://localhost:8080Access-Control-Request-Method: POSTAccess-Control-Request-Headers: X-Custom-Header 预检请求使用OPTIONS方法 Origin，和简单请求字段一样，表示请求源； Access-Control-Request-Method，必须字段，告知服务器实际请求将使用的请求方法。 Access-Control-Request-Headers：告知服务器，实际请求将携带的额外头部信息。多个头部信息用逗号隔开。 预检请求的响应：12345678910111213HTTP/1.1 200 OKDate: Thu, 27 Dec 2017 20:55:23 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://localhost:8080Access-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-CSRFToken, X-SessionIdAccess-Control-Max-Age: 86400Vary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 以上响应表示服务器同意跨域资源请求。如果浏览器否定预检请求，会返回一个正常 HTTP 响应，但是没有 CORS 相关的头信息。 当预检请求通过之后，浏览器就会发出实际的跨域资源请求，就像简单请求一样。 Requests with credentials一般而言，对于跨域XMLHttpRequest或Fetch请求，浏览器不会发送身份凭证信息。如果要发送附带身份凭证的请求，需要在请求中打开XMLHttpRequest的withCredentials属性。12345var xhr = new XMLHttpRequest();xhr.withCredentials = true;// Vue2 的 axiosimport axios from 'axios'axios.defaults.withCredentials = true; 同时，需要服务器同意发送的请求附带 Cookie。服务器通过响应头部字段Access-Control-Allow-Credentials: true来告诉客户端可以发送 Cookies。 如果服务端的响应头部未携带Access-Control-Allow-Credentials: true，浏览器将不会把响应内容返回给请求的发送者；如果请求端不打开XMLHttpRequest的withCredentials属性，即使服务端同意发送 Cookie，浏览器也不会发送。 The HTTP request headers Origin指定请求源 ([scheme]://host[:port]，不包含任何路径信息)，服务器根据这个值判断是否同意跨域请求。注意：请求首部字段 Origin 不是 CORS 专属。 Access-Control-Request-Method用于预检请求，将实际请求所使用的 HTTP 方法告诉服务器。 Access-Control-Request-Headers用于预检请求，将实际请求所携带的额外首部字段告诉服务器。 The HTTP response headers Access-Control-Allow-Origin用于判断服务器是否同意或支持跨域资源分享。 如果简单请求或预检请求的响应头部不带Access-Control-Allow-Origin字段，则表示服务器不同意跨域请求，或不支持 CORS。即使服务器有正常的响应返回，浏览器为了安全考虑也会自动过滤掉请求的响应结果，抛出被 CORS 策略拦截的相关错误。 如果响应头部有Access-Control-Allow-Origin字段，该字段的值可以为*或请求首部字段Origin的值。当值不是*的时候，响应首部的Vary字段必须包含Origin，表示服务器对不同的请求源会返回不同的内容。 Access-Control-Allow-Credentials布尔值 (true/false)，表示服务器是否允许客户端发送带 Cookie 的 CORS 请求。一般而言，对于跨域XMLHtpRequest或Fetch请求，浏览器不会发送身份凭证信息。 Access-Control-Allow-Methods用于预检请求的响应，指明了实际请求所允许使用的 HTTP 方法。 1Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]... Access-Control-Allow-Headers用于预检请求的响应，指明实际请求中允许携带的头部字段。 1Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]... Access-Control-Expose-Headers在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能够获取到一些默认允许获取的响应头部字段：Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma。如果想要访问其它头部字段，则需要服务器端设置。如，Django 的corsheaders.middleware.CorsMiddle中间件，通过CORS_EXPOSE_HEADERS = (&#39;X-CSRFToken&#39;, &#39;X-SessionId&#39;)来设置。响应头部相应的会出现： 1Access-Control-Expose-Headers: X-CSRFToken, X-SessionId 这样，客户端就可以获取响应头部字段X-CSRFToken和X-SessionId了。 Access-Control-Max-Age用于预检请求的响应，告诉浏览器预检请求的结果能够被缓存多久。 1Access-Control-Max-Age: &lt;delta-seconds&gt; django-cors-headersDjango 可以通过安装django-cors-headers，通过使用相应的中间件来配置处理 CORS 请求。具体参考文档django-cors-headers。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"https://lizsgh.github.io/tags/http/"}],"keywords":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}]},{"title":"Linux service","slug":"linux/service","date":"2017-04-22T16:00:00.000Z","updated":"2019-02-26T08:32:52.887Z","comments":true,"path":"2017/04/23/linux/service/","link":"","permalink":"https://lizsgh.github.io/2017/04/23/linux/service/","excerpt":"","text":"Linux 系统的服务脚本放在 /etc/init.d 目录下。所以，想要添加服务，首先需要编写可执行服务的脚本，然后放到该目录下。具体编写，可以参照 /etc/init.d/ 目录下面的已有服务。 CentOSRedhat 提供了 chkconfig 命令来管理系统的服务： chkconfig --list：所有服务列表 chkconfig --list serviceName：只显示 serverName 服务 chkconfig serviceName on：开启 serverName 服务的自动启动 chkconfig serviceName off：关闭 serverName 服务的自动启动 chkconfig --add serviceName：添加服务 chkconfig --del serviceName：删除服务 UbuntuUbuntu 是没有 chkconfig 命令的，而是提供了另外的命令来实现管理服务： sudo update-rc.d serviceName defaults：添加服务，默认添加服务为自动启动，即 /etc/rc0.d/ 到 /etc/rc6.d 各级别里面都添加了服务的启动软链接。 sudo update-rc.d serviceName remove：删除服务，默认会删除所有级别的服务，即彻底删除服务。 如果，你想要配置各级别的启动情况，可以删除相应级别目录里面的服务软链接。 systemctl daemon-reload：修改过服务之后，用该命令来重新加载服务。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Python - urllib2/urllib.request","slug":"python/urllib2","date":"2017-04-01T16:00:00.000Z","updated":"2019-02-26T07:38:34.519Z","comments":true,"path":"2017/04/02/python/urllib2/","link":"","permalink":"https://lizsgh.github.io/2017/04/02/python/urllib2/","excerpt":"","text":"urllib2/urllib.request Python2.7: urllib2 Python3: urllib.request urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None)构造一个请求对象. url: 请求的有效URL. data: 请求的附加数据. Python3.3 之前, 请求的方法根据 data 判断.&#39;GET&#39; if data is None else &#39;POST&#39; data 的类型要对应 headers 中的 Content-Type 属性. 如果 data 不为空, 而且 headers 中又没有指定 Content-Type, 则默认为 application/x-www-form-urlencoded. 所以, 一般 HTTP POST 请求的数据要用 urllib.parse.urlencode() (python2 urllib.urlencode()) 来转换为 application/x-www-form-urlencoded 格式. headers: 请求的头部. 如 {&#39;Accept&#39;: &#39;text/html&#39;, &#39;Content-Type&#39;: &#39;multipart/form-data&#39;} origin_req_host unverifiable method: New in Python3.3, 请求的方法,如: HEAD, GET, POST. 在 Python3.3 之前,请求的方法由 data 决定 &#39;GET&#39; if data is None else &#39;POST&#39;. urllib.request.urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, cafile=None, capath=None, cadefault=False, context=None)Open the URL url, which can be either a string or a Request object. url: 请求的 URL,或构造好的请求对象 urllib.request.Request(). data: 请求的附加数据,同 urllib.request.Request() 的 data 参数. timeout: 请求的超时时间, 默认为 socket 的默认超时时间 _GLOBAL_DEFAULT_TIMEOUT. cafile, capath: HTTPS 请求的 CA 证书. 主要作为参数传给 ssl.create_default_context() context: ssl.SSLContext 实例 正常返回一个 HTTP 请求, 返回对象有以下方法: getcode(): HTTP 的响应状态码. geturl(): 当前返回内容的 URL,可以用来判断是否重定向. info(): HTTP 的响应头部信息. dict: 头部信息字典 get(name): 获取头部信息中名为 name 的值, 相当于 dict.get(name) getheader(name): 同 get(name) 返回的body内容可以通过read()读取. 简单例子:1234from urllib.request import Request, urlopenrequest = Request(&apos;http://www.lizs.cc&apos;)response = urlopen(Request, timeout=3) 注意, urlopen() 请求的返回对象如果不是 2xx 是会报错的. 如果想知道响应是否为 404 怎么办? 可以通过捕获 HTTP.Error 错误来获取.12345678910from urllib.request import Request, urlopen, HTTPErrorrequest = Request(&apos;http://www.lizs.cc&apos;)try: response = urlopen(Request, timeout=3)except HTTPError, err_response: response = err_responseprint(response.getcode()) # 响应状态码print(response.info()) # 响应的头部print(response.read()) # 响应的内容(主体) Handler 类模块处理器类，用来创建 opener。 urllib.request.build_opener(*handlers)创建 opener 对象. -*handlers, 创建 opener 所需的Handler. 如: build_opener(handler), build_opener(handler1, handler2), build_opener(*[handler1, handler2]) 创建 opener 的时候会自动加载以下默认 Handler: ProxyHandler, UnknownHandler, HTTPHandler, HTTPDefaultErrorHandler, HTTPRedirectHandler, FTPHandler, FileHandler, HTTPErrorProcessor. 如果提供的 *handler 中, 有默认Handler的子类(issubclass), 创建 opener 的时候将去掉相应的默认 Handler. urllib.request.install_opener(opener)将 opener 设置为默认 opener. 模块的一般使用步骤: 确定 Handler。 创建、安装 opener。 使用 urlopen() 完成请求。 不创建 opener 直接 urlopen() 会使用默认的 opener (使用默认 Handler)。 自定义 Handler 处理 HTTPError模块默认 Handler 对 HTTP 响应状态码不是 200 &lt;= code &lt; 300的，都 raise HTTPError 来处理的，有时候很不方便，我们可以自定义一个Handler来处理 HTTPError。 默认 Handler 中，HTTPDefaultErrorHandler 会 raise 所有 HTTPError。123class HTTPDefaultErrorHandler(BaseHandler): def http_error_default(self, req, fp, code, msg, hdrs): raise HTTPError(req.get_full_url(), code, msg, hdrs, fp) 重新定义处理 Handler：123class MyHTTPErrorHandler(urllib.request.HTTPDefaultErrorHandler): def http_error_default(self, req, fp, code, msg, hdrs): return urllib.request.HTTPError(req.get_full_url(), code, msg, hdrs, fp) 使用自定义的 Handler 来 urlopen:1234opener = urllib.request.build_opener(MyHTTPErrorHandler)urllib.request.install_opener(opener)request = urllib.request.Request(&apos;http://www.lizs.cc&apos;)response = urllib.request.urlopen(request, timeout=3) 因为，issubclass(MyHTTPErrorHandler, HTTPDefaultErrorHandler) == True，所以，HTTPDefaultErrorHandler 被去掉。 也可以通过定义 HTTPErrorProcessor 的子类来处理。因为，HTTPErrorProcessor 规定了响应状态码不为 200 &lt;= code &lt; 300 都是 HTTPError。12345678910111213141516class HTTPErrorProcessor(BaseHandler): &quot;&quot;&quot;Process HTTP error responses.&quot;&quot;&quot; handler_order = 1000 # after all other processing def http_response(self, request, response): code, msg, hdrs = response.code, response.msg, response.info() # According to RFC 2616, &quot;2xx&quot; code indicates that the client&apos;s # request was successfully received, understood, and accepted. if not (200 &lt;= code &lt; 300): response = self.parent.error( &apos;http&apos;, request, response, code, msg, hdrs) return response https_response = http_response 定义 Handler 将 404 响应状态码归类到正常状态。123456789101112class MyHTTPErrorProcessor(urllib.request.HTTPErrorProcessor): def http_response(self, request, response): code, msg, hdrs = response.code, response.msg, response.info() # According to RFC 2616, &quot;2xx&quot; code indicates that the client&apos;s # request was successfully received, understood, and accepted. if not (200 &lt;= code &lt; 300 or code == 404): response = self.parent.error( &apos;http&apos;, request, response, code, msg, hdrs) return response 当 HTTP 响应状态码为 200 &lt;= code &lt; 300 or code == 404 都不会 raise HTTPError.1234opener = urllib.request.build_opener(MyHTTPErrorProcessor)urllib.request.install_opener(opener)request = urllib.request.Request(&apos;http://www.lizs.cc/404&apos;)response = urllib.request.urlopen(request) HTTP Basic Authorization模块提供了 HTTPBasicAuthHandler(password_mgr=None) 来处理 HTTP Basic 认证。 password_mgr: 密码管理器，可以用 HTTPPasswordMgrWithDefaultRealm。 12345678910uri = &apos;http://www.lizs.cc&apos; # 需要 Basic 认证的urluser = &apos;admin&apos; # Basic 认证的用户名passwd = &apos;123456&apos; # Basic 认证的密码mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()mgr.add_password(None, uri, user, passwd)handler = urllib.request.HTTPBasicAuthHandler(password_mgr=mgr)opener = urllib.request.build_opener(handler)urllib.request.install_opener(opener)request = urllib.request.Request(uri)response = urllib.request.urlopen(request)","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Ubuntu install rpm packages","slug":"linux/ubuntu_install_rpm_packages","date":"2017-03-24T16:00:00.000Z","updated":"2019-02-26T13:04:03.825Z","comments":true,"path":"2017/03/25/linux/ubuntu_install_rpm_packages/","link":"","permalink":"https://lizsgh.github.io/2017/03/25/linux/ubuntu_install_rpm_packages/","excerpt":"","text":"rpm 和 deb rpm 包rpm 后缀的安装包，是可执行文件安装包，可以用 rpm 命令进行安装。RPM，RedHat Package Manager。 deb 包deb 后缀的安装包，debian 及其衍生版本的安装包（如 ubuntu），是可执行文件安装包。可以用 dpkg 命令进行安装。 alien alien - Convert and install an alien binary package. 先安装 alien 工具 1sudo apt-get install alien 直接使用 alien 安装 1sudo alien -i xxx.rpm 将 rpm 包转换为 deb 包再安装 123sudo alien -d xxx.rpm或sudo alien xxx.rpm # default is -d","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Linux - expect","slug":"linux/expect","date":"2017-03-20T16:00:00.000Z","updated":"2019-02-26T08:25:18.105Z","comments":true,"path":"2017/03/21/linux/expect/","link":"","permalink":"https://lizsgh.github.io/2017/03/21/linux/expect/","excerpt":"","text":"Expect, an extension to the Tcl (Tool Command Language) scripting language, and it is a scripting language to interface with programs such as FTP, telnet, fsck, ssh, and others that normally cannot be automated from a shell script. 使用情景Expect 可以实现自动交互的功能，所以，很常用的一种情景就是为我们自动输入密码。如：ssh 登录，git push/pull 等情景。 安装 Ubuntu 1sudo apt-get install expect CentOS 1sudo yum install expect Expect 需要 Tcl 编程语言的支持，所以必须先安装 Tcl。 实例Expect 脚本使用的是 Tcl 的语法。 批量更新 git 仓库的内容（git pull）1234567891011121314151617#!/usr/bin/expectset password &quot;123456&quot;foreach app &#123; /root/app/ic/ic-server/ /root/app/ic/ic-client/&#125; &#123; cd $app spawn git pull expect &#123; &quot;Username*&quot; &#123;send &quot;lizs\\r&quot;&#125; &quot;*assword*&quot; &#123; send $password interact &#125; &#125;&#125; 更多使用参考 Expect-wiki.","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Python - sphinx create documents","slug":"python/sphinx","date":"2017-01-17T16:00:00.000Z","updated":"2019-02-26T09:33:34.454Z","comments":true,"path":"2017/01/18/python/sphinx/","link":"","permalink":"https://lizsgh.github.io/2017/01/18/python/sphinx/","excerpt":"","text":"安装 前提，安装了 python 和 python-pip windows在 cmd 窗口中执行 pip install Sphinx ubuntu1sudo pip install Sphinx 创建 Sphinx 项目1sphinx-quickstart 设定文档的根目录： 12Enter the root path for documentation.&gt; Root path for the documentation [.]: 默认为 .，即当前目录，或者也可以新建目录 ./xxx。 是否分离 “_build” 文件夹 1234You have two options for placing the build directory for Sphinx output.Either, you use a directory &quot;_build&quot; within the root path, or you separate&quot;source&quot; and &quot;build&quot; directories within the root path.&gt; Separate source and build directories (y/n) [n]: y 设置 templates 和 static 文件夹的前缀，默认为``. 1234Inside the root directory, two more directories will be created; &quot;_templates&quot;for custom HTML templates and &quot;_static&quot; for custom stylesheets and other staticfiles. You can enter another prefix (such as &quot;.&quot;) to replace the underscore.&gt; Name prefix for templates and static dir [_]: 设置项目的名称和作者 123The project name will occur in several places in the built documentation.&gt; Project name: wiki-zhongniu&gt; Author name(s): lizs 设置项目的版本号 1234567Sphinx has the notion of a &quot;version&quot; and a &quot;release&quot; for thesoftware. Each version can have multiple releases. For example, forPython the version is something like 2.5 or 3.0, while the release issomething like 2.5.1 or 3.0a1. If you don&apos;t need this dual structure,just set both to the same value.&gt; Project version: v1.0&gt; Project release [v1.0]: // 默认为上面输入的 veision 设置项目的编写语言 123456If the documents are to be written in a language other than English,you can select a language here by its language code. Sphinx will thentranslate text that it generates into that language.For a list of supported codes, seehttp://sphinx-doc.org/config.html#confval-language.&gt; Project language [en]: zh_CN 设置源文件的后缀 123The file name suffix for source files. Commonly, this is either &quot;.txt&quot;or &quot;.rst&quot;. Only files with this suffix are considered documents.&gt; Source file suffix [.rst]: 设置文档首页的名称 12345One document is special in that it is considered the top node of the&quot;contents tree&quot;, that is, it is the root of the hierarchical structureof the documents. Normally, this is &quot;index&quot;, but if your &quot;index&quot;document is a custom template, you can also set this to another filename.&gt; Name of your master document (without suffix) [index]: 设置是否 epub 输出，默认即可 12Sphinx can also add configuration for epub output:&gt; Do you want to use the epub builder (y/n) [n]: 设置是否使用 Sphinx 扩展功能： 12Please indicate if you want to use one of the following Sphinx extensions:&gt; autodoc: automatically insert docstrings from modules (y/n) [n]: y 然后，选择需要的 extension。 创建 Makefile 和 Windows command file 123A Makefile and a Windows command file can be generated for you so that you only have to run e.g. `make html&apos; instead of invoking sphinx-build directly.&gt; Create Makefile? (y/n) [y]: y&gt; Create Windows command file? (y/n) [y]: y 生成 HTML 文件执行完以上步骤之后，就会在当前文件夹下生成一个目录为 xxx 的项目文件。进入文件夹里面，可以看到生成了 Makefile 文件。这时候，就可以用 make 命令来生成 html 文件了 1make html 执行完 make html 会在 _build 文件夹里面的 html 文件夹里可以看到生成的 html 文件。如果分离了 _build，html 文件会在 build 的 html 文件夹里面。","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - Virtualenv","slug":"python/virtualenv","date":"2017-01-01T16:00:00.000Z","updated":"2019-02-26T08:16:51.601Z","comments":true,"path":"2017/01/02/python/virtualenv/","link":"","permalink":"https://lizsgh.github.io/2017/01/02/python/virtualenv/","excerpt":"","text":"Reference: Virtualenv 安装1pip install virtualenv 创建虚拟环境1virtualenv ENV ENV: 需要创建的虚拟环境的路径。ENV 可以是全局路径，也可以是相对路径。 以上命令创建的 Python 虚拟环境是没有从系统的 Python 中继承任何 Python 库的，是一个新的 Python 环境。其它选项： -p PYTHON_EXE, --python=PYTHON_EXE默认创建的虚拟环境的 Python 版本是系统默认的 Python，但是可以通过添加该选项来指定虚拟环境的 Python 版本(前提是系统已有的 Python 版本)。 123virtualenv -p python3.5 ENV# orvirtualenv --python=python3.5 ENV --system-site-packages默认创建的虚拟环境是没有继承任何 Python 库的，如果需要继承系统默认 Python 的库，可以添加该选项： 1virtualenv --system-site-packages ENV --always-copy默认情况下，创建虚拟环境需要的文件很多都是从系统软连接过来使用的。如果想要直接复制那些文件到虚拟环境而不是使用软连接，可以添加该选项： 1virutalenv --always-copy ENV 更多参数选项可以参考 virtualenv，或 virtualenv --help。 激活虚拟环境激活虚拟环境，只需要 source 虚拟环境 ENV/bin/activate。如，虚拟环境目录为 /var/virtualenvs/scanner/，当前路径为 /home/lizs/：12cd /var/virtualenvs/scanner/source bin/activate 或1source /var/virtualenvs/scanner/bin/activate 成功激活之后，当前命令窗口的 python 就处于一个独立的虚拟环境的。pip freeze 可以看到当前的虚拟环境是没有安装任何 Python 的库的。 注意：在虚拟环境下，如果安装时候需要sudo权限 (如，sudo pip install Django)，virtualenv 是获取不到sudo权限的。即，用sudo提权时，执行的命令不再在当前虚拟环境。那么，当在 virtualenv 虚拟环境下需要sudo权限安装的时候要怎么做呢？可以这样做：1sudo $(which pip) install Django 执行 which pip 的时候还是在当前虚拟环境下，sudo加命令的绝对路径安装就会自动安装到当前虚拟环境下了。 退出激活状态如果想要退出激活状态的虚拟环境，可以执行：1deactivate 在非激活状态使用虚拟环境 使用虚拟环境的 python 和相应的库如果，想要在非激活状态使用用虚拟环境的 Python 执行 Python 文件，可以指定 Python 解析器的路径为 /path/to/ENV/bin/python。 使用全局环境的 python，并且添加虚拟环境中的 python 库在 python 环境下，或执行文件中添加以下内容： 12activate_this = &apos;/path/to/env/bin/activate_this.py&apos; execfile(activate_this, dict(__file__=activate_this)) 删除虚拟环境删除虚拟环境，非激活状态下直接删除虚拟环境下的文件即可：1rm -r ENV","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Linux - autossh + ssh proxy by socket5","slug":"linux/autossh_ssh_proxy","date":"2017-01-01T16:00:00.000Z","updated":"2019-02-26T08:14:32.416Z","comments":true,"path":"2017/01/02/linux/autossh_ssh_proxy/","link":"","permalink":"https://lizsgh.github.io/2017/01/02/linux/autossh_ssh_proxy/","excerpt":"","text":"ssh 设置 sockets 代理1ssh -qTfnN -D 1080 root@alizs.cc -q: Quiet modle. Causes most warning and diagnostic messages to be suppressed. -T: Disable pseudo-terminal allocation. -f: Requests ssh to go to background just before command execution. This is useful if ssh is going to ask for passwords or passphrases, but the user wants it in the background. This implies -n. -n: Redirects stdin from /dev/null (actually, prevents reading from stdin). This must be used when ssh is run in the background. -N: Do not execute a remote command. This is useful for just forwarding ports. -D: Specifies a local “dynamic” application-level port forwarding. `root@alizs.cc`: sockets 代理服务器 更多设置可以参考 ssh 这样就可以将请求通过 sockets5 代理地址 127.0.0.1:1080 转发到代理服务器 alizs.cc，完成翻墙了。不过，这种方式实现的代理，会存在 ssh 经常断开链接的问题。这时候，可以用 autossh 来解决。 使用 autossh 管理 ssh 进程 autossh 是一个用来启动并监控管理 ssh 的程序，在 ssh 断开的时候，autossh 会自动重启 ssh 进程。 安装 autossh (ubuntu)1sudo apt-get install autossh 使用方法：1autossh [-V] [-M monitor_port[:echo_port]] [-f] [SSH_OPTIONS] -M: specifies monitor port. Overrides the environment variable AUTOSSH_PORT. 0 turns monitoring loop off. Alternatively, a port for an echo service on the remote machine may be specified. -f: run in background (autossh handles this, and does not pass it to ssh). 后台运行，并且 -f 参数不会传给 ssh，因为 ssh 也有 -f 参数。比如，执行 autossh -M 0 -fqTnN -D 1080 root@alizs.cc 的时候，autossh 进程会启动一个 ssh 进程，并且 -qTnN -D 1080 root@alizs.cc 这些参数是会传给 ssh 的，但是 -f 不会传给 ssh。也就是说 ssh 进程会像这样：/usr/bin/ssh -qTnN -D 1080 root@alizs.cc。 -V: print autossh version and exit. 使用实例：1autossh -M 0 -fqTN -D 1080 root@alizs.cc -M: -M 0，表示通过 端口检测 ssh 的连接状态，断开后就会自动重连。 -f: 后台运行。 -qTN: 是 ssh 的参数。(autossh 不传 -f 给 ssh，-n 也就没意义了。) 运行以上命令之后，可以发现系统里多了两个进程，一个是 autossh，一个是 ssh。其中 ssh 是由 autossh 启动的，autossh 作为 ssh 的守护进程，监测 ssh 的状态，当 ssh 断开之后，会自动重启 ssh。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Algorithm - Basic","slug":"algorithm/basic","date":"2016-12-31T16:00:01.000Z","updated":"2018-09-12T07:45:26.526Z","comments":true,"path":"2017/01/01/algorithm/basic/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/algorithm/basic/","excerpt":"","text":"数学基础知识计量单位 B，字节 KB，千字节，2^10 = 1024 B MB，兆字节，2^20 B GB，吉字节，2^30 B 阶乘(factorial)阶乘n!，指从 1 到 n 之间所有整数的乘积，n为大于 0 的整数。如：15! = 1 * 2 * 3 * 4 * 5 特别地，0! = 1。 取模(modulus)取模，指获取整除后的余数。如：15 % 3 = 2 指数幂在数学上，我们把 n 个相同因数 a 相乘的积记做a^n。这种求几个相同因数的积的运算叫做乘方，乘方的结果叫做幂。在a^n中，a叫做底数，n叫做指数。a^n读作：a的n次方，或a的n次幂。 对数在数学中，对数是对求幂的逆运算。如果 N = a^x(a &gt; 0, a != 1)，那么数 x 就叫做以 a 为底 N 的对数(logarithm)，记作 x=logaN。其中，a叫做对数的底数，N叫做真数，x叫做以a为底N的对数。 对数在坐标上过定点 (1, 0)，即 x = 1 时，y = 0。 特别地，以 10 为底的对数称为常用对数(common logarithm)，记为 lg。 以无理数 e(e=2.71828) 为底的对数称为自然对数(natural logarithm)，记为 ln。 零没有对数。 在实数范围内，负数无对数；在复数范围内，负数有对数。 级数级数指将数列的项依次加起来的函数。1∑Un = U1 + U2 + ... + Un 算法分析渐近分析当我们估算一种算法的时间或者其他代价时，经常忽略其系数，只关注其增长率，这称为渐近分析法。准确的说，渐近分析是当输入规模很大，或者达到极限(微积分意义上)时，对一种算法的研究。实践证明忽略这些系数很有用，因此渐近分析也广泛应用于算法比较。 并不是任何情况都能忽略常数。当算法要解决的问题规模 n 很小时，系数就会起到举足轻重的作用。 上限算法运行时间的上限，用来表示该算法可能有的最高增长率。算法有最佳、最差、平均情况下的上限，一般估算最差情况下的上限。 算法增长率的上限，用大 O 表示。如果某种算法的增长率上限(最差情况下)是f(n)，那么就说这种算法“在集合 O(f(n)) 中”，或直接说“在 O(f(n))”中。 下限算法下限，表示最差、最佳、平均情况下的时间下限。用 Ω 表示，读作“大欧米伽”或“欧米伽”。 Θ当算法上限和下限相等时，可用 Θ 表示法，读作“西塔”。 算法最佳、最差、平均情况算法的上(下)限与给定输入规模(如n)的最差(佳)情况不同，上(下)限不是用来确定运行时间(对于给定的n值，即可确定具体的运行时间)的，而是用来确定运行时间的增长率(增长率只能在n值的一个范围内确定)。对于单个点是没有增长率概念的，增长率用于体现伴随输入规模变化的代价变化。 算法的每种输入规模(如n)都存在最佳和最差情况，所以，不要误认为当输入规模尽可能小时出现算法的最佳情况，当输入规模尽可能大时出现算法的最差情况。 理想情况下，当输入规模增大时，可以确定在最佳、最差和平均情况下的增长率。 基本数据结构线性表线性表是由称为元素(element)的数据项组成的一种有限且有序的序列。有序，是指线性表中的每一个元素都有自己的位置。每一个元素也都有一种数据类型。 线性表中不包含任何元素时，称为空表。当前存储的元素数目称为线性表的长度；线性表的开始结点称为表头(head)；结尾结点称为表尾(tail)。 线性表的实现有两种标准方法：顺序表(array-based list 或 sequential list)和链表(linked list)。 顺序表和链表的比较： 顺序表的缺点是大小事先固定，很容易造成空间不足或浪费的情况；优点是对于表中的每个元素没有浪费空间，而链表需要在每个结点上附加一个指针。 链表的优点是只有实际在链表中的对象需要空间，只要存在可用的内存空间分配，链表中的元素个数就没有限制。 一般规律，当线性表元素数目变化较大或者未知时，最好使用链表实现；而如果用户事先知道线性表的大致长度时，使用顺序表的空间效率会更高。 链表的增加/删除操作所需的时间仅为Θ(1)。而顺序表必须将其余的元素向前或向后移动，所需的平均时间和最差时间均为Θ(n)。对于许多应用，插入和删除是最主要的操作，仅就这个原因链表往往比顺序表更好。 链表分为单链表和双链表。双链表存储了两个指针(前驱和后继)，双链表与单链表相比唯一的缺点就是使用更多的空间，双链表的每一个结点需要两个指针。 字典计算机程序一般是用来存储和检索数据的。字典，一个简单的数据库接口，被定义成一个ADT，它提供在数据库中存储、查找和删除记录的功能。 字典用关键码(key)来描述一条数据库记录，并且该关键码是可比的(comparable)。有了这样的关键码，就能够在数据库中顺序地搜索并找出给定关键码值相匹配的记录。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://lizsgh.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://lizsgh.github.io/tags/algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://lizsgh.github.io/categories/Algorithm/"}]},{"title":"MySQL - DATABASE","slug":"mysql/database","date":"2016-12-31T16:00:00.000Z","updated":"2019-03-12T10:45:01.292Z","comments":true,"path":"2017/01/01/mysql/database/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/mysql/database/","excerpt":"","text":"SHOW DATABASES Syntax1SHOW &#123;DATABASES | SCHEMAS&#125; [LIKE &apos;pattern&apos; | WHERE expr] example:123SHOW DTATBASES;SHOW DATABASES LIKE 'django_%';SHOW DATABASES WHERE `Database` LIKE '%django_%'; CREATE DATABASE syntax1234CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [create_specification] ...create_specification: [DEFAULT] CHARACTER SET [=] charset_name [DEFAULT] COLLATE [=] collation_name example:1CREATE DATABASE IF NOT EXISTS `tests` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; ALTER DATABASE Syntax123456ALTER &#123;DATABASE | SCHEMA&#125; [db_name] alter_specification ...alter_specification: [DEFAULT] CHARACTER SET [=] charset_name | [DEFAULT] COLLATE [=] collation_name example1ALTER DATABASE `tests` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; DROP DATABASE Syntax1DROP &#123;DATABASE | SCHEMA&#125; [IF EXISTS] db_name example:1DROP DATABASE IF EXISTS `tests`;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://lizsgh.github.io/tags/mysql/"},{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}]},{"title":"MySQL - optimization","slug":"mysql/optimization","date":"2016-12-31T16:00:00.000Z","updated":"2019-03-16T11:11:41.433Z","comments":true,"path":"2017/01/01/mysql/optimization/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/mysql/optimization/","excerpt":"","text":"建表时选择合适的引擎 如果表只是以查询为主，很少修改，则可以选择 MyISAM 引擎。 数据库读写分离，读的服务器中的表可以用 MyISAM 引擎。 合理使用索引 对经常查询的列，或排序的列，使用索引。 对需要查询值中的关键字的列，使用 FULLTEXT 索引。 对经常查询的组合条件，建立组合索引。 尽量避免在WHERE子句中使用!=或&lt;&gt;操作，或对字段进行NULL值判断，这样会使索引失效，而扫描全表。 尽量用WHERE代替HAVING，因为HAVING是在查询出的结果中进行过滤，WHERE可以使用索引查询。 数据库结构优化 范式优化：比如消除冗余的列等。 拆分表：根据表的特性，必要时对表进行水平拆分和垂直拆分。 垂直拆分：对高并发请求的表，可以根据业务将表拆分，以分担 IO 压力。 水平拆分：对于数据量太大的表，可以考虑水平拆分。 主从复制，读写分离","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://lizsgh.github.io/tags/mysql/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}]},{"title":"Docker - Command-Line Interfaces (CLIs)","slug":"docker/command_line_interfaces","date":"2016-12-31T16:00:00.000Z","updated":"2019-02-26T07:31:10.223Z","comments":true,"path":"2017/01/01/docker/command_line_interfaces/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/docker/command_line_interfaces/","excerpt":"","text":"","categories":[{"name":"Docker","slug":"Docker","permalink":"https://lizsgh.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://lizsgh.github.io/tags/docker/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"https://lizsgh.github.io/categories/Docker/"}]},{"title":"Python - coding","slug":"python/coding","date":"2016-12-31T16:00:00.000Z","updated":"2019-02-26T12:40:18.190Z","comments":true,"path":"2017/01/01/python/coding/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/python/coding/","excerpt":"","text":"123456a, b, c = 1, 0, 2d = a if b else c # 21 &lt;= a &lt; 2 # True, 1 &lt; a and a &lt;2False == False == True # False, False == False and False == Trueor_val = 2 or 3 # 2and_val = 2 and 3 # 3 Python 可以同时给多个值赋值，只要 = 左右元素个数相同。实际上，就是 tuple packing(元组打包) 和 sequence unpacking(序列解包)。 Python 没有三元运算符 ? :，但是Python 2.5 新增了一个内置的条件表达式 a if b else c，即当 b 为真时，表达式的值为 a，否则，表达式的值为 c。 Python 链式比较，是两边的分别和中间的比较，不是顺序比较。如：False == False == True，是 False == False and False == True，而不是 (False == False) == True。 Python and 和 or 表达式的返回值为表达式最后执行的值，如：2 and 3 and 1 - 1 的值为 0，因为，表达式最后执行的是 1 - 1。和 PHP 不一样，PHP 返回表达式的对错判断 true/1 或 false/0。 List Comprehensions - 列表推导式/列表解析 123456args = [ x**2 for x in range(-10, 10) if x &gt; 0 ]# it is the same as:args = []for x in range(-10, 10): if x &gt; 0: args.append(x**2) example2:1234567args = [(x, y) for x in range(1, 10) for y in range(6, 10) if x != y]# it is the same as:args = []for x in range(1, 10): for y in range(6, 10): if x != y: args.append((x, y)) 123with open(&apos;xx&apos;, &apos;x&apos;) as fp: for line in iter(fp.readline, &apos;&apos;): # 遍历文件的每行直到为空 xxx 1234for i in range(10): print(i)else: print(&apos;The for is not completed&apos;) 当 for 完全遍历完迭代对象时，else 语句执行。The for statement","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - Built-in functions","slug":"python/builtin_function","date":"2016-12-31T16:00:00.000Z","updated":"2018-11-28T12:48:27.841Z","comments":true,"path":"2017/01/01/python/builtin_function/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/python/builtin_function/","excerpt":"","text":"overview Built-in Functions abs() delattr() hash() memoryview() set() all() dict() help() min() setattr() any() dir() hex() next() slice() ascii() divmod() id() object() sorted() bin() enumerate() input() oct() staticmethod() bool() eval() int() open() str() breakpoint() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() abs(x)返回数值x的绝对值，x可以为：整数和浮点数。如果x是复数，则返回复数的 magnitude，即复数与其共轭复数乘积的正平方根。如：12abs(2 + 2j) # (2 + 2j) * (2 - 2j) 的平方根2.8284271247461903 复数与其共轭复数的乘积运算： (a + bj) * (a - bj) == a ** 2 + b ** 2，因此，abs(a + bj) == math.sqrt(a ** 2 + b ** 2) all(iterable)当iterable中的所有元素为真，或iterable为空时，返回True。 any(iterable)当iterable中有任意一个元素为真时，返回True。 ascii(object)As repr(), return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by repr() using \\x, \\u or \\U escapes. This generates a string similar to that returned by repr() in Python 2. bin(x)将整数x转换为以0b开头的二进制字符串。x为整数或int对象(即该对象必须定义__index__()方法，并返回一个整数)。1234a = bin(3) # '0b11'b = bin(-3) # '-0b11'int(b, base=2)-3 bool([x])根据x的判断值，返回布尔值True或False。如果x为空，返回False。 bool是int的子类，但是，bool不能够被继承，因为bool的实例只有True和False。1234class A(bool): pass TypeError: type 'bool' is not an acceptable base type breakpoint(*args, **kws) New in version 3.7 bytearray([source[, encoding[, errors]]]) bytes([source[, encoding[, errors]]]) Python 2str(object=’’) -&gt; string.Return a nice string representation of the object. If the argument is a string, the return value is the same object. Python 3 bytes(): empty bytes object. bytes(int): bytes object of size given by the parameter initializated with null bytes (‘\\x00’). 12bytes(0) # b''bytes(3) # b'\\x00\\x00\\x00' bytes(iterable_of_ints): bytes 1bytes(range(3)) # b'\\x00\\x01\\x02' bytes(bytes_or_buffer): immutable copy of bytes_of_buffer. 123a = b'abc'b = bytes(a) # b'abc'a == b # True, i.e. id(a) == id(b) bytes(string, encoding[, errors]): bytes. 12a = 'abc' # Unicodebytes(a, 'utf-8') # b'abc' callable(object)判断 object 是否是可调用的，返回Ture/False。 callable函数只是检测object是否可调用，不管object调用是否成功。object为可调用对象时，调用的时候也可能调用失败；object为不可调用对象时，调用就一定失败。 1234567891011class A(object): pass class B(object): def __call__(self): return a # global name 'a' is not defined callable(A) # Truecallable(A()) # Falsecallable(B) # Truecallable(B()) # True 类对象都是可调用的，返回一个类实例。但是类的实例对象是否为可调用对象，取决于类是否定义了__call__()方法。 1234callable(int) # Truecallable(int()) # Falsecallable(bool) # Truecallable(bool()) # False New in version 3.2: This function was first removed in Python 3.0 and then brought back in Python 3.2. chr(i) Python 2: Return a string of one character with oridinal i (0 &lt;= i &lt; 256).Python 3: Return a Unicode string of one character with ordinal i (0 &lt;= i &lt;= 0x10ffff).返回 code point i 对应的 Unicode 的字符，0 &lt;= i &lt;= 0x10ffff。与 ord() 函数作用相反。12chr(65) # Aord('A') # 65 @classmethod compile(source, filename, mode, flags=0, dont_inherit=False, optimize=1)将source编译成 code 对象或 AST 对象。编译成的 Code 对象可以被exec或eval函数执行。 source: 可以是字符串、byte 字符串或 AST 对象。注意，source的内容要符合mode。 filename: 字符串类型，读取代码的文件名。如果不是从文件中读取，可以用一些具有标识性的字符串代替，如&#39;&lt;string&gt;&#39;。 mode: 指定代码编译的类型。 &#39;exec&#39;: 如果source是由一系列的 Python 语句组成的。 &#39;eval&#39;: 如果source是一条表达式，编译成的代码对象可以被eval函数执行。 &#39;single&#39;: 如果source由单一的交互式语句组成。(这种情况下，用exec也是可以的，不知道single的实际作用？！) 1234567891011code_object = compile('a = 1; b = a + 1', '&lt;string&gt;', 'exec')exec(code_object)a, b(1, 2)code_object = compile('1 + 1', '&lt;string&gt;', 'eval')eval(code_object)2code_object = compile('name = input(\"Input your name: \")', '&lt;string&gt;', 'single')exec(code_object)Input your name: lizsprint(name) complex([real[, imag]])返回实部real和虚部imag转换成的复数。 real和imag可以是任意的数值类型，如 int, float，complex 等。real还可以是 sting 类型，但imag永远不能够为 string 类型。real和imag的默认值都为 0。返回real + imag * 1j。 12345678910complex(1, 2.1)(1+2.1j) # 1 + 2.1 * 1j = (1+2.1j)complex(1+2j, 2)(1+4j) # (1+2j) + 2 * 1j = (1+4j)complex(1+2j, 2j)(-1+2j) # (1+2j) + 2j * 1j = (1+2j) - 2 = (-1+2j)complex(-1.1)(-1.1+0j) # -1.1 + 0 * 1j = (1.1+0j)complex()0j # 0 + 0 * 1j = 0j 当real为 string 时，real将转换为复数，imag不能有值。 123456complex('1')(1+0j)complex('1.1+1.2j')(1.1+1.2j)complex('1', '2')TypeError: complex() can't take second arg if first is a string 注意，当real为 string 时，real字符串中的+或-操作符前后不能够有空格。 12345678910complex('1 + 2j')ValueError: complex() arg is a malformed string complex('1 - 2j')ValueError: complex() arg is a malformed string complex('1 ')(1+0j)complex(' -2')(-2+0j)complex(' -2j')-2j delattr(object, name)删除对象object中的属性name。object为对象名称；name为对象的属性名称，字符串类型。实际上，delattr(x, &#39;foobar&#39;)相当于del x.foobar。 dict(kws)/dict(mapping, kws)/dict(iterable, **kws)字典的构建函数。 dict(): new empty dictionary dict(mapping): new dictionary initialized from a mapping object’s (key, value) pairs dict(iterable): new dictionary initialized as if via: 123d = &#123;&#125;for k, v in iterable: d[k] = v dict(**kwargs): new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2). dir([object])返回object的有效的属性名称的列表。如果object为空，则返回当前的局部作用域(局部变量)的名称。 dir([object])只是返回属性或变量的名称，locals()和globals()分别返回局部和全局符号表(一种映射关系，存储了键值对的数据结构)。 如果object定义了__dir__()方法，则dir(object)会调用object.__dir__()方法，__dir__()方法必须返回一个列表。 1234567891011class A(object): def __dir__(self): print('hello world') return ['a', 'b', 0] def name(self): return 'lizs'dir(A())hello world['a', 'b', 0] # in this case, just call __dir__() function, and doesn't has 'name' attribute. 如果object没有定义__dir__()方法，dir(object)会从object.__dict__属性，and from its type object. 1234567891011class B(object): def __init__(self): self.__dict__ = &#123;'a': 1, 'b': 2&#125; def c(self): passdir(B())['__class__', '__delattr__', '__dict__', '__doc__', ..., 'a', 'b', 'c']B().a1 dir([object])的默认机制是： 如果object是 Python 模块，则返回该模块的属性名称组成的列表。 如果object是 type 或 class 对象，则返回object的属性名称，和object基类的属性名称。 否则，则返回object的属性名称，object父类的属性名称，和object父类的基类的属性名称组成的列表。 divmod(a, b)divmod(a, b) -&gt; (a // b, a % b) enumerate(iterable, start=0)返回一个枚举对象，iterable必须是一个序列，或一个迭代器，或其它的迭代对象。12345seasons = ['Spring', 'Summer', 'Fall', 'Winter']list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]list(enumerate(seasons, start=1))[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] 相当于：12345def enumerate(sequence, start=0) n = start for elem in sequence: yield n, elem n += 1 eval(source, globals=None, locals=None)在globals和locals变量的环境下，返回表达式(Python expression)source执行的值。 source，可以是字符串 (Python expression)，也可以是一个 code objects (如 compile() 创建的 code object)。 globals，字典类型，当globals=None时，默认值为当前环境下的globals()。 locals，任意映射类型，当locals=None时，默认值为当前环境下的locals()。 globals和locals参数只能够通过位置参数传参。 12eval('int()', globals=&#123;'a': 1&#125;)TypeError: eval() takes no keyword arguments 如果globals字典参数中没有__builtins__键，则自动添加__builtins__，其值为builtins模块。 12eval('list(globals().keys()), list(locals().keys())', &#123;&#125;, &#123;&#125;)['__builtins__', &#123;&#125;] 如果只有globals参数，则locals参数的值默认为globals参数的值。 12eval('list(locals().keys())', &#123;'a': 1&#125;)['a', '__builtins__'] 当source为 code object 时，如果 code object 使用compile()创建时使用了exec作为参数mode的值，则返回None。 1234print(eval(compile('1 + 2', '&lt;string&gt;', 'eval')))3print(eval(compile('1 + 2', '&lt;string&gt;', 'None')))None 注意，print(&quot;hello world&quot;)只是在屏幕输出内容，表达式没有返回值的。 12345678a = print('hello world')hello world # 屏幕输出print(a)None # print 函数的返回值为 Nonea = eval(\"print('hello world')\")hello world # 屏幕输出print(a)None # eval 函数执行完的返回值为 None 因为source为 Python 表达式 (expression)，所以，当source为 Python 語句 (statement) 时會出錯。如：赋值语句 (=)。 12345eval('a = 1')File \"&lt;string&gt;\", line 1 a = 1 ^SyntaxError: invalid syntax 要执行 Python statements 可以使用 exec() 函数。 exec(source[, globals[, locals]])与eval相似，eval执行 Python 表达式或 code object 并会返回执行结果。exec函数会动态执行source，但返回None。 source可以是 string 或 code object。source可以是动态的 Python 语句，如a = 1; a += 1。 globals和locals: 用法和eval相同。 Python 2 exec不是函数，而是一个内置语句，不会返回值。 123456# Python 2+a = exec('a = 1; a + 1') File \"&lt;ipython-input-21-1d9129f9ba14&gt;\", line 1 b = exec('a = 1; a + 1') ^SyntaxError: invalid syntax Python 3 exec是内置函数，只返回None。 1234# Python 3+a = exec('1 + 1')print(a)None filter(function, iterable) (Python 2) filter(function or None, sequence) -&gt; list, tuple, or stringReturn those items of sequence for which function(item) is true. If function is None, return the items that are true. If sequence is a tuple or string, return the same type, else return a list. (Python 3) filter(function or None, iterable) –&gt; filter objectReturn an iterator yielding those items of iterable for which function(item) is true. If function is None, return the items that are true. filter函数过滤掉iterable中 item 经过function(item)调用返回不为真的 item。 当function为None时，返回iterable中为真的项。 Python2，如果iterable为 tuple 或 string 则返回原来的类型，其余类型返回 list；Python3 返回一个 filter object。 Python 2+: 1234567891011121314151617181920212223filter(int, [0, 1, 2])[1, 2]filter(int, (0, 1, 2))(1, 2)filter(int, &#123;0, 1, 2&#125;)[1, 2]filter(int, '012')'12'def f(x): print(x) return 65 &lt;= ord(x) &lt;= 90 filter(f, 'abAB')abAB'AB' # filter the 'ab'filter(None, [0, 1, 2])[1, 2]filter(None, (0, 1, 2))(1, 2)filter(None, '012')'012' 当iterable为字符串类型并且第一个参数不为None时，会遍历字符串中的每个字符作为 item 传给 function。 Python 3+: 1234567891011121314151617181920212223242526r1 = filter(int, [0, 1, 2])print(r1)&lt;filter object at 0x...&gt;list(r1)[1, 2]def func(x): print(x) return 65 &lt;= ord(x) &lt;= 90r2 = filter(func, 'abAB')next(r2)abA'A' # yielding 'A', beause function('A') == True.next(r2)'B'list(filter(None, (0, 1, 2)))[1, 2]list(filter(None, '012'))['0', '1', '2']list(filter(int, '012'))['1', '2']list(filter(bool, '012'))['0', '1', '2'] float([x])将x转换为浮点数。x可以是 string 或 int。 如果x是 string 类型，x应该是一个十进制数字的字符串，或(inf/Infinity)代表无穷大值，字符串前面可以包含+或-或空格字符。如果没有参数，则返回0.0。123456789101112131415161718float(1)1.0float(1.11)1.11float('1')1.0float('+1.11')1.11float(' -123\\n')-123.0float('1e-003')0.001float(' +1E6')1000000.0float('inf')inf # 正无穷大float('-Infinity')-inf # 负无穷大 format(value[, format_spec])返回value.__format__(format_spec)，format_spec默认值为空字符串。See the Format Specification Mini-Language section of help(‘FORMATTING’) fordetails. forzenset([iterable])创建一个 frozenset 对象。iterable为可迭代对象，如果iterable为空，则创建一个空值的 frozenset 对象。12345678frozenset()frozenset() # an empty frozenset objectfrozenset('abcde')frozenset(&#123;'a', 'b', 'c', 'd', 'e'&#125;)frozenset([0, 1, 2, 'abc'])frozenset(&#123;0, 1, 2, 'abc'&#125;)frozenset(0)TypeError: 'int' object is not iterable getattr(object, name[, default])获取object对象的属性名称为name的值，name必须为字符串类型。即getattr(object, name)相当于object.name。当object.name不存在时，如果指定default的值，则返回default的值；如果不指定default的值，则会引起AttributeError错误。12345678910111213141516class A(object): def __init__(self): self.name = 'lizs' self.age = 18 def address(self): return 'China'getattr(A(), 'name') 'lizs'getattr(A(), 'address')&lt;bound method A.address of &lt;__main__.A object at 0x...&gt;&gt;getattr(A, 'name')AttributeError: type object 'A' has no attribute 'name'getattr(A, 'name', 'lizs')'lizs' globals()返回全局符号表。 hasattr(object, name)判断object对象是否存在属性name，返回True或False。name，字符串类型，属性的名称。e.g. hasattr(People, &#39;age&#39;)相当于People.age。 实际上，hasattr(object, name)调用了getattr(object, name)，然后通过抓取错误来判断是否存在属性。 hash(object)获取object对象的哈希值。哈希值为整数，两个数值比较为相等时，它们的哈希值相同。123456hash(1), hash(1.0), hash(1+0j)(1, 1, 1)1 == 1.0 == 1+0jTrueid(1), id(1.0), id(1+0j)(94326139635240, 94326148389728, 139691410895376) help([object])打印object的帮助文档信息，当没有参数时，启动一个帮助系统的交互界面。 hex(x)将整数x转换为十六进制字符串(以0x开头的小写字母字符串)。1234hex(255)'0xff'hex(-42)'-0x2a' id(object)获取对象的 identity。在对象的生命周期中，identity 是一个具有唯一性的常数。在 CPython 解析器中，identity 就是该对象的内存地址。 input([prompt])从基础输入中读取一行信息，即input()读取到换行符结束。或用户自动出发结束，如Linux系统Ctrl + D。如果提示信息prompt给出，则在基础输出中显示。prompt显示的时候不会自动加换行。1234567input(\"Hi, what is your name: \")Hi, what is your name: lizs # 提示信息不会自动换行，输入信息 'lizs' 会随尾提示后面。'lizs'input(\"Hi, what is your name: \\n\")Hi, what is your name:lizs # input message'lizs' int([x])/int(x, base=10) 当没有参数时，返回 0，即int() == 0。 如果x定义了__int__()，则返回x.__int__()；如果x定义了__trunc__()，则返回x.__trunc__()。 当x为浮点数时，返回整数部分。 12int(1.9)1 当x不是数字的时候，或当指定base的值的时候，x只能是 string, bytes, bytearray 代表的整形字面量(integer literal)。这时x可以以+或-开头，或空格围绕。 12int(' - 101 ') # base=10-101 Python 3+ integer literal definitions: 12345678910integer ::= decinteger | bininteger | octinteger | hexintegerdecinteger ::= nonzerodigit ([\"_\"] digit)* | \"0\"+ ([\"_\"] \"0\")*bininteger ::= \"0\" (\"b\" | \"B\") ([\"_\"] bindigit)+octinteger ::= \"0\" (\"o\" | \"O\") ([\"_\"] octdigit)+hexinteger ::= \"0\" (\"x\" | \"X\") ([\"_\"] hexdigit)+nonzerodigit ::= \"1\"...\"9\"digit ::= \"0\"...\"9\"bindigit ::= \"0\" | \"1\"octdigit ::= \"0\"...\"7\"hexdigit ::= digit | \"a\"...\"f\" | \"A\"...\"F\" Python 2 integer literal definitions: 12345678910longinteger ::= integer (\"l\" | \"L\")integer ::= decimalinteger | octinteger | hexinteger | binintegerdecimalinteger ::= nonzerodigit digit* | \"0\"octinteger ::= \"0\" (\"o\" | \"O\") octdigit+ | \"0\" octdigit+hexinteger ::= \"0\" (\"x\" | \"X\") hexdigit+bininteger ::= \"0\" (\"b\" | \"B\") bindigit+nonzerodigit ::= \"1\"...\"9\"octdigit ::= \"0\"...\"7\"bindigit ::= \"0\" | \"1\"hexdigit ::= digit | \"a\"...\"f\" | \"A\"...\"F\" base表示x的进制数，如int(&#39;101&#39;, 8)表示101是一个八进制的字符串，转换为整数则为：1 * 8 ** 0 + 0 + 1 * 8 ** 2 == 65。base的有效值可以为 0 和 2-36。 当base=0时，意味着x按照 integer literal 转换。但 Python 2+ 与 Python 3+ 的integer literal 有些不同，如当x是以 0 开头时在 Python 3+ 是不合法的，但在 Python 2+ 中为 octinteger int(&#39;010&#39;, 0) == int(&#39;010&#39;, 8)。 当base为 2, 8, 16 时，x可以分别以0b/0B, 0o/0O和0x/0X开头。 当base的值大于 10 时，x可以用字母 a-z 或 A-Z 来表示 10 - 35 (注意，字母必须小于base，如当base=12时，x中只能够有字母a和b)。 12345678910111213141516int('101', 8)65int('101', 0) # decinteger101int('0b101', 0) # bininteger5int('0Xa0', 0) # hexinteger160int('a0', 0)ValueError: invalid literal for int() with base 0: 'a0'int('101', 2)5int('0B101', 2)5int('ab1', 12)1573 isinstance(object, classinfo)判断object是否是classinfo的实例，返回True/False。classinfo可以是一个类或一个由若干个类型组成的元组。当classinfo是元组时，只要object属于classinfo中任意一个类型的实例则返回True。123456isinstance(0, object)Trueisinstance(0, (str, int, dict))Trueisinstance(0, ('a', int))TypeError: isinstance() arg 2 must be a type or tuple of types issubclass(class, classinfo)判断class是否是classinfo的子类，返回True/False。classinfo可以是一个类或一个由若干个类组成的元组。当classinfo是元组的时候，只要class属于classinfo中任意一个类的子类则返回True。1234issubclass(int, object)Trueissubclass(int, (str, object, dict))True 与isinstance(object, classinfo)不同，issubclass(class, classinfo)的第一个参数class必须是一个类，并且class认为是其本身的子类。123456issubclass(0, object)TypeError: issubclass() arg 1 must be a classissubclass(int, int)Trueisinstance(int, int)False iter(object[, sentinel]) iter(collection) -&gt; iteratoriter(callable, sentinel) -&gt; iterator 当没有sentinel参数时，第一个参数只能够是 collection 对象，即支持迭代协议(__iter__()方法)和序列协议(__getitem__()方法)。 123i = iter([0, 1, 2])next(i) # 0next(i) # 1 当第二个参数不为空的时候，第一个参数必须是一个可调用对象。创建的迭代器在每次迭代的时候，会调用callable，当调用的返回值为sentinel时停止。 123with open('mydata.txt') as fp: for line in iter(fp.readline, ''): print(line) len(s)获取对象s的长度(元素个数)。12345678len('abc')3len(&#123;'a', 'b', 'c'&#125;)3len(dict(a=0, b=1, c=2))3len(range(10))10 list([iterable])list() -&gt; new empty listlist(iterable) -&gt; new list initialized from iterable’s items locals()获取当前局部符号表，即当前范围的局部变量组成的字典。 map(function, iterable[, iterable, ..]) (Python2.7) Apply function to every item of iterable and return a list of the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. If one iterable is shorter than another it is assumed to be extended with None items. If function is None, the identity function is assumed; if there are multiple arguments, map() returns a list consisting of tuples containing the corresponding items from all iterables (a kind of transpose operation). The iterable arguments may be a sequence or any iterable object; the result is always a list.(Python3+) Return an iterator that applies function to every item of iterable, yielding the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterable stops when the shortest iterable is exhausted. 将function应用于iterable的每一项，返回列表(Python3+，迭代对象)，列表(迭代对象)中的每一项都是function作用后的结果。注意：Python3+ 返回的是迭代对象。 如果有多个iterable，function将并行应用于iterable的每一项。也即是，所有iterable中相同序列的项同时作为参数传递给function运行。如： 12345678map(lambda x, y: x + y, [1, 2, 3], [4, 5, 6])[5, 7, 9] # Python3+ 返回迭代器&lt;map object&gt;map(lambda x: x * x, [1, 2, 3], [4, 5, 6])TypeError: &lt;lambda&gt;() takes exactly 1 argument (2 given)def func(*args): return argsmap(func, [1, 2, 3], [4, 5, 6], [7, 8, 9])[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 当iterable的个数(注意，不是iterable元素个数)与function函数的参数不一致时会出错。如： 12map(lambda x: x * x, [1, 2, 3], [4, 5, 6])TypeError: &lt;lambda&gt;() takes exactly 1 argument (2 given) 当有多个iterable并且iterable的元素数目不一致时：Python2，会以最长的为准，短自动用None补全。Python3+，以最短的为准，迭代完最短的iterable就会自动结束。 12345678def func(*args): return args# Python2.7map(func, [1, 2, 3], [4, 5, 6, 7])[(1, 4), (2, 5), (3, 6), (None, 7)]# Python3+list(map(func, [1, 2, 3], [4, 5, 6, 7]))[(1, 4), (2, 5), (3, 6)] 当function为None 123456# Python2map(None, [1, 2, 3], [4, 5, 6, 7])[(1, 4), (2, 5), (3, 6), (None, 7)]# Python3+list(map(None, [1, 2, 3], [4, 5, 6, 7]))TypeError: 'NoneType' object is not callable max() max(iterable, *[, key=func, default=obj])max(arg1, arg2, *args[, key=func]) 当只有一个位置参数的时候(即第一种模式)，这个参数只能是一个可迭代对象，函数会返回迭代对象中最大的一个元素。如：list, str, tuple 等。 1234max('0123')3max([0, 1, 2, 3])3 如果有两个或两个以上位置参数(即第二种模式)，则返回这些参数中最大的一个。注意，这些位置参数一定要可比较大小的，不然会出错。Python3 两个不同类型之间不可以比较大小。 12345678max(0, 1, 2)2# Python 2+max('a', 1, 2)'a' # 'a' &gt; 2 == True, in python 2# Python 3+max('a', 1, 2)TypeError: '&gt;' not supported between instances of 'str' and 'int' 除了位置参数之外，max()还有 keyword-only 参数key=func。key参数和list.sort()的key参数类似。key参数的值为接收一个参数的函数(如func(x))，iterable中的元素或各个位置参数会作为参数传给func函数处理，max()函数会根据func函数的返回值进行比较取最大值。 12345# Python 3max(['a', 0, 1, 97], key=lambda x: ord(x) if isinstance(x, str) else x)'a'max('a', 0, 98, key=lambda x: ord(x) if isinstance(x, str) else x)98 原本 Python 3+ 是不能够比较 str 和 int 的，但是key参数自动将字符串转换为了整数。同时，当比较的参数中有相同的时候，会返回第一个最大值(ord(&#39;a&#39;) == 97)。 Python 3.4 以上，第一种模式max(iterable, *[, key=func, default=obj])新增了一个 keyword-only 参数 default=obj。default参数可以指定当iterable为空的时候，函数返回的默认值。 12max('', default=1)1 min() min(iterable, *[, key=func, default=obj])min(arg1, arg2, *args[, key=func]) 用法和max()函数一样，功能相反，返回参数中的最小值。 memoryview(object)创建 memoryview 对象。123456789101112a = bytearray(1000000)sys.getsizeof(a)1000057b = memoryview(a)print(b)&lt;memory at 0x...&gt;print(sys.getsizeof(b))192print(b[1])0print(b[1:3])&lt;memory at 0x...&gt; next(iterator[, default])返回迭代器iterator的下一个元素，即调用iterator.__next__()的返回值。next()的第二个参数为iterator遍历结束时返回的默认值，否则当iterator迭代完的时候会引起StopIteration错误。12345678910a = iter(range(2))next(a) # 0next(a) # 1next(a) # StopIterationa = iter(range(3))next(a) # 0next(a, 3) # 1next(a, default=3) # TypeError: next() takes no keyword argumentsnext(a, 3) # 2next(a, 3) # 3 当给出第二个参数的时候，当迭代器迭代完毕的时候会返回这个默认值，而不会引起StopIteration错误。同时，next()的第二个参数是一个位置参数。 oct(x)将整数x转换为以0o开头的八进制(octal)字符串。x为整数或int对象(即该对象必须定义__index__()方法，并返回一个整数)。注意，Python 2+ 八进制字符串以0开头。1234oct(3) # 0o3oct(10) # 0o12int('0o12', 8)10 open() open(name[, mode[, buffering]])open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) ord(c)获取 Unicode 单个字符c的 code point。与chr(x)功能相反。1234ord('a')97chr(97)'a' pow(x, y[, z])当只有两个参数时，返回 x ** y；当由三个参数时，返回x ** y % z。 print() Python 2+: print()函数实际上是print表达式。Python 3+: print(value, …, sep=’ ‘, end=’\\n’, file=sys.stdout, flush=False) Python 2+，print()函数实际上是print表达式，所以，是没有关键字参数的，并且，多个位置参数时，是当做元组处理。 1234print('a', 'b')('a', 'b')print('a', 'b', sep='|')SyntaxError: invalid syntax Python 3+，print()函数不是关键字参数都会转换成字符串，并且组成一个由sep连接和end结尾的字符串输出。 sep=&#39; &#39;，关键字参数，表示当有多个位置参数时的连接符，默认值为空格。 end=&#39;\\n&#39;，关键字参数，表示添加到字符串结尾的字符。 file=sys.stdout, 关键字参数，必须是有wirite(string)方法的对象。 flush=False，关键字参数，表示是否刷新缓冲区。 12345print('a', 'b') # a bprint('a', 'b', sep='|') # a|bprint('a', 'b', sep='|', end='===') # a|b===with open('test.py', 'w') as fp: print('#!/usr/bin/env', 'python', file=fp) property(fget=None, fset=None, fdel=None, doc=None)创建一个 property 属性。fget是用来获取该属性值的相关函数，fset用来设置该属性值的函数，fdel是用来删除该属性的函数，doc是一个文档信息字符串。 12345class C(object): def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") 这样便通过property()创建了C对象的属性x。 以上操作也可以同 @property 装饰器更简单地实现：12345678910111213141516class C(object): def __init__(self): self._x = None @property def x(self): \"\"\"I am the 'x' property.\"\"\" return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x range() range(stop)range(start, stop[, step]) Python 2+, range()返回一个列表对象；Python 3+，range()返回的是一个 range 对象。 range()遵循左闭右开原则: [start, stop) 当只有一个参数的时候代表的是 stop，start 默认为 0，即 [0, stop)。 当有两个参数的时候，分别为 start 和 stop，即 [start, stop)。 第三个参数 step 代表步长，默认值为 1，。当 step 为负数的时候，start + step &lt; stop 才有意义。12345678910111213141516# python 2+range(10)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # 左闭右开 [0, 10)range(10, 0)[]range(0, 10, 2)[0, 2, 4, 6, 8]range(0, 10, -2)[]range(10, 0, -2)[10, 8, 6, 4, 2]range(0, -10, -2)[0, -2, -4, -6, -8]# python 3+range(10)range(0, 10) 当 step 为负数的时候，range(10, 0, -2)：12345610 8 # 10 - 26 # 8 - 24 # 6 - 22 # 4 - 20 # 2 - 2，左闭右开原则，舍弃 所以，list(range(10, 0, -2)) == [10, 8, 6, 4, 2]。 repr(object)Return the canonical string representation of the object. For many object types, including most builtins, eval(repr(obj)) == obj. A class can control what this function returns for its instances by defininga __repr__() method. reversed(seq)返回seq反转之后的生成器。123456789a = reversed('abcde')print(a)&lt;reversed at 0x...&gt;next(a)'e'next(a)'d'list(a)['c', 'b', 'a'] round(number[, ndigits])返回number四舍五入之后的结果，第二个参数ndigits表示精度。当没有第二个参数或为None时，返回number四舍五入之后的整数。123456789101112round(0.5)0round(1.5)2round(1.545, 0)2.0round(1.545, 1)1.5round(1.545, 2)1.54 # In python 1.545 actually is 1.54499999...round(1.545000001, 2)1.55 set([iterable])set() -&gt; new empty set objectset(iterable) -&gt; new set object Build an unordered collection of unique elements. setattr(object, name, value)Sets the named attribute on the given object to the specified value.setattr(x, &#39;y&#39;, v) is equivalent to x.y = v slice()slice(stop)slice(start, stop[, step]) Create a slice object. This is used for extended slicing (e.g. a[0:10:2])123456789101112a = 'abcdef's = slice(2)print(s)slice(None, 2, None)s1 = slice(1, 5)print(s1)slice(1, 5, None)s2 = slice(10, 1, -2)print(10, 1, -2)a[s] # 'ab'a[s1] # 'bcde'a[s2] # 'fd' sorted(iterable, *, key=None, reverse=False)返回iterable排序之后的列表。 关键字参数key，与max()，min()和list.sort()中的key参数一样，为只有一个参数的函数。如果指定了key=func，iterable中的每个元素 item 会作为唯一参数传递给func(item)，sorted()函数将根据func(item)的返回值进行比较，值越小越靠前。 关键字参数reverse，布尔值True或False，默认值为False。如果为True则将排序好的列表值反转。 1234sorted(('a', 0, 1, 96, 97, 98), key=lambda x: ord(x) if isinstance(x, str) else x)[0, 1, 96, 'a', 97, 98]sorted('abcde', reverse=True)['e', 'd', 'c', 'b', 'a'] @staticmethodConvert a function to be a static method. str str(object=’’) -&gt; strstr(bytes_or_buffer[, encoding[, errors]]) -&gt; str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object).encoding defaults to sys.getdefaultencoding().errors defaults to ‘strict’. sum(iterable[, start])返回iterable中各个元素的总和。如果，给出第二个参数start，则返回iterable + start的总和。1234sum(range(10))45sum(range(10), 10)55 super()super() -&gt; same as super(class, )super(type) -&gt; unbound super objectsuper(type, obj) -&gt; bound super object; requires isinstance(obj, type)super(type, type2) -&gt; bound super object; requires issubclass(type2, type)Typical use to call a cooperative superclass method:12345678class C(B): def meth(self, arg): super().meth(arg)This works for class methods too:class C(B): @classmethod def cmeth(cls, arg): super().cmeth(arg) Python 的super()函数可以用来调用父类的方法，并且有效解决了多重继承中父类方法被多次调用的问题。123456789101112131415161718192021222324252627class A(object): def __init__(self): print('A.__init__') class B(A): def __init__(self): A.__init__(self) print('B.__init__')class C(A): def __init__(self): A.__init__(self) print('C.__init__')class D(B, C): def __init__(self): B.__init__(self) C.__init__(self) print('D.__init__')D()A.__init__B.__init__A.__init__C.__init__D.__init__&lt;__main__.D at 0x7f7c5c410710&gt; 可以看到A被初始化了两次，这不是我们想要的。super()很完美的解决了这个问题。12345678910111213141516171819202122232425class A(object): def __init__(self): print('A.__init__')class B(A): def __init__(self): super().__init__() # super(B, self).__init__() print('B.__init__')class C(A): def __init__(self): super().__init__() # super(C, self).__init__() print('C.__init__')class D(B, C): def __init__(self): super().__init__() # super(D, self).__init__() print('D.__init__')D()A.__init__C.__init__B.__init__D.__init__&lt;__main__.DD at 0x7f6281c98c18&gt; 这次并没有重复的了，A, B, C, D都是只初始化了一次。super()会根据 MRO (method resolution search order) 来查找。12D.mro()[__main__.D, __main__.B, __main__.C, __main__.A, object] 开始执行D.__init__()的时候，遇到了super()/super(D, self)，则以当前类D (第一个遇到super的类) 的 MRO 来查找。如super(D, self)则查找 MRO 中 D 右侧的下一个对象 B，将 B 的__init__()绑定到当前的self(D()) 执行。 当执行B.__init__()的时候，又遇到了一个super()/super(B, self)，这时候还是以之前的 D.mro() 来查找，找到了 B 的下一个 C，继续执行。 当执行C.__init__()的时候，又遇到了一个super()/super(C, self)，还是以第一次的 D.mro() 来查找，找到了 C 的下一个 A，继续执行。 当执行A.__init__()的时候，没有super()。OK，执行完，依次返回：A.__init__(), C.__init__(), B.__init__(), D.__init__()。 再来看一个对比的例子：123456789101112131415161718192021222324252627282930class A(object): def __init__(self): print('A.__init__')class B(object): def __init__(self): print('B.__init__')class C(A): def __init__(self): super().__init__() # super(C, self).__init__() print('C.__init__')class D(A): def __init__(self): super().__init__() # super(D, self).__init__() print('D.__init__')class E(C, B, D): def __init__(self): super().__init__() # super(E, self).__init__() print('E.__init__')E.mro()[__main__.E, __main__.C, __main__.B, __main__.D, __main__.A, object]E()B.__init__C.__init__E.__init__&lt;__main__.E at 0x7f6281c9d3c8&gt; 首先执行E.__init__()，遇到super()/super(E, self)，则按照 E.mro() 来查找。找到了 E 的下一个 C。 执行C.__init__()的时候，遇到super()/super(C, self)，还是按照 E.mro() 来查找。找到了 C 的下一个 B。 执行B.__init__()的时候，没有super()，执行完依次返回: B.__init__, C.__init__, E.__init__。 从以上例子，可以很清楚super(type, obj)就是调用厨师 MRO 中type的下一个对象，并绑定到obj去执行。所以，我们可以指定特别的父类type。同时注意，isinstance(obj, type) == True。 上面的例子改一下 E：123456789101112class E(C, B, D): def __init__(self): super(B, self).__init__() print('E.__init__')E.mro()[__main__.E, __main__.C, __main__.B, __main__.D, __main__.A, object]E()A.__init__D.__init__E.__init__&lt;__main__.E at 0x7f6281c9dbe0&gt; 首先执行E.__init__()，遇到super(B, self)，则以 E.mro() 来查找，找到 B 的下一个 D。 执行D.__init__()的时候，遇到super()/super(D, self)，继续以 E.mro() 来查找 D 的下一个 A。 执行A.__init__()，没有super()，执行完，一次返回：A.__init__, D.__init__, E.__init__。 当super(type, type2)的第二个参数为 type 时，issubclass(type2, type)必须为True。用法和super(type, obj)类似。12345678910111213141516class A(object): @classmethod def cmeth(cls): print('A.cmeth')class B(A): @classmethod def cmeth(cls): super().cmeth() # super(B, cls).cmeth() print('B.cmeth')B.mro()[__main__.B, __main__.A, object]B.cmeth()A.cmethB.cmeth Python 3+, super() -&gt; same as super(class, ) tuple()tuple() -&gt; empty tupletuple(iterable) -&gt; tuple initialized from iterable’s items If the argument is a tuple, the return value is the same object. type()type(object) -&gt; the object’s typetype(name, bases, dict) -&gt; a new type type(object): 返回object的类型。 type(name, bases, dict): 创建一个新的对象。实际上，相当于用class创建类的动态格式，A = type(&#39;AName&#39;, (object,), dict(a=0, b=1))。 name，新建对象的名称，相当于__name__。 bases，元组类型，定义新对象继承的基类，即__bases__属性。 dict，字典类型，定义新对象的属性。123456789101112131415161718192021222324252627 class A(object): def __init__(self): self.name = 'lizs' self.age = 18 def a_func(self): pass class B(object): def __init__(self): self.height = 165 self.weight = 138 def b_func(self): passC = type('CName', (A, B), dict(address='China'))C__main__.CNameC.__name__'CName'C.__bases__(__main__.A, __main__.B)C.mro()[__main__.CName, __main__.A, __main__.B, object]dir(C)['__class__', ..., 'address', 'a_func', 'b_func']dir(C())['__class__', ..., 'address', 'age', 'name', 'a_func', 'b_func'] vars([object])vars([object]) -&gt; dictionary Without arguments, equivalent to locals().With an argument, equivalent to object.dict. zip(*iterables) Python2: zip(seq1[, seq2, seq3, …]) -&gt; [(seq1[0], seq2[0], seq3[0], …), (seq1[1], seq2[1], seq3[1], …), …]Python3: zip(iter1[, iterf2, iter3, …]) -&gt; zip object zip 函数将各个参数中相同序列的项组成元组，并返回元组组成的迭代器对象(Python 2返回列表)。当各个参数中元素个数不一致时(len(x))，以最短的参数为标准。 Python 3 中 zip 函数的实现实际上等于：1234567891011def zip(*iterable): sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) Examples:12345678# python 2zip(range(3), range(1, 10))[(0, 1), (1, 2), (2, 3)]# Python 3zip(range(3), range(1, 10))&lt;zip object at 0x...&gt;list(range(3), range(1, 10))[(0, 1), (1, 2), (2, 3)] import(name, globals=None, locals=None, fromlist=(), level=0)导入模块，import语句导入模块的时候就是调用了这个函数。其实想要以编程的方式导入模块，最好用importlib.import_module()。 name: 模块名称。 globals/locals: potentially using the given globals and locals to determine how to interpret the name in a package context. The standard implementation does not use its locals argument at all, and uses its globals only to determine the package context of the import statement. fromlist: list or tuple, the names of objects or submodules that should be imported from the module given by name. level: The level argument is used to determine whether toperform absolute or relative imports: 0 (python3 default value) is absolute, while a positive number is the number of parent directories to search relative to the current module. 12spam = __import__('spam') # &lt;module 'spam' from '/home/...'&gt;spam = __import__('spam.ham') # &lt;module 'spam' from '/home/...'&gt; 注意: 当name为package.module形式的时候，如果fromlist为空，返回的是最顶级的包 (即第一个点左边的包)；如果fromlist不为空，则返回package.module指定的最终模块。12spam = __import__('spam.meat.ham') # &lt;module 'spam' from '...'&gt;ham = __import__('spam.meat.ham', fromlist=('xx',)) # &lt;module 'ham' ...&gt;","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"},{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - pip","slug":"python/pip","date":"2016-12-31T16:00:00.000Z","updated":"2019-02-25T15:02:05.703Z","comments":true,"path":"2017/01/01/python/pip/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/python/pip/","excerpt":"","text":"pip reference InstallationInstalling in Ubuntu1234# python2sudo apt-get install python-pip# python3sudo apt-get install python3-pip Installing with get-pip.py1234# download get-pip.pycurl https://bootstrap.pypa.io/get-pip.py -o get-pip.py# then run the installpython get-pip.py pip 会安装在相应的 Python 版本中。123python2.7 get-pip.py# 如果环境变量中没有，添加到 /usr/binln -s /path/to/python2.7/bin/pip2.7 /usr/bin/pip2.7 Upgrading pip123pip install -U pip # or pip install --upgrade pip# upgrading pip3pip3 install -U pip # or python3 -m pip -U pip Running pip12pip &lt;pip arguments&gt;python -m pip &lt;pip arguments&gt; 默认情况下，使用的pip为系统默认的pip (如，/usr/bin/pip，/usr/local/bin/pip)，如果有多个版本的 Python，可以将相应的 pip 添加到系统PATH路径下，如：/usr/bin/python3 -&gt; /usr/local/python3/bin/pip。 当 Python 的 pip 不在系统PATH路径下的时候，也可以使用相应的 Python 调用模块的方式使用 pip：1python3.6 -m pip &lt;pip arguments&gt; Installing Packages123pip install some_package # latest versionpip3 install some_package==1.0.4 # specific versionpython3.7 -m pip install 'some_package&gt;=1.04' # minimum version Using a proxy server1pip install some_package --proxy &lt;[user:passwd@]proxy.server:port&gt; 如，在本地开了一个 SOCKS5 的代理服务器 (127.0.0.1:1080)：1pip install some_package --proxy localhost:1080 Requirements Files将当前 Python 环境的安装包导入到 requirements.txt：1pip freeze &gt; requirements.txt 从 requirements.txt 文件中安装包到当前 Python 环境：1pip install -r requirements.txt 从当前 Python 环境中卸载 requirements.txt 中的包：1pip uninstall -y -r requirements.txt 项目管理中，一般结合 virtualenv 工具使用。 Gitpip 工具也支持从 Git 仓库中克隆项目包。123pip install -e git://git.myproject.org/MyProject.git#egg=MyProjectpip install -e git+http://git.myproject.org/MyProject.git#egg=MyProjectpip install -e git+ssh://git.myproject.org/MyProject.git#egg=MyProject 也可以指定克隆的分支, commit hash 或 tag name：123pip install -e git://git.myproject.org/MyProject.git@master#egg=MyProjectpip install -e git://git.myproject.org/MyProject.git@v1.0#egg=MyProjectpip install -e git://git.myproject.org/MyProject.git@da39a3ee5e6b4b0d3255bfef95601890afd80709#egg=MyProject Django2+ 安装 xadmin：1pip install git+git://github.com/sshwsfc/xadmin.git@django2 注意，pip freeze生成的 requirements.txt 中相应的包为 xadmin==xx。当用pip install -r requirements.txt再次安装的时候会出错，需要修改requirements.txt：xadmin==xx -&gt; git+git://github.com/sshwsfc/xadmin.git@django2。 更多查看Requirements files Uninstalling Packages12pip uninstall some_packagepip uninstall -r requirements.txt Listing packages列出已经安装的包1pip list 查看已安装的包的具体信息：1pip show some_package Searching for Packages1pip search \"query\"","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"MySQL - Engines","slug":"mysql/engines","date":"2016-12-31T16:00:00.000Z","updated":"2019-03-15T19:00:36.238Z","comments":true,"path":"2017/01/01/mysql/engines/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/mysql/engines/","excerpt":"","text":"MyISAMMySQL 5.5.5 以前的版本，使用 MyISAM 作为默认存储引擎。MyISAM 提供高速存储和检索，以及全文搜索的能力。 每个 MyISAM 表在磁盘上存储成三个文件，文件名和表明相同，扩展名如下： .frm：存储表定义 .MYD：存储数据 (MYData) .MYI：存储索引 (MYIndex)数据文件(.MYD)和索引文件(.MYI)可以放置在不同目录，平均分配 IO，获取更快的速度。自定义数据文件和索引文件的路径，可以在创建表的时候使用DATA DIRECTORY和INDEX DIRECTORY语句来指定，文件路径需要使用绝对路径。 MyISAM 表支持三种不同的存储格式： 静态表静态表为默认的存储格式。静态表中的字段都是非变长字段，即每个记录都是固定长度的，因为静态表在存储的时候会根据列定义的宽度自动填补空格。但在访问的时候并不会得到这些空格，在返回数据之前会经这些空格处理掉。但要注意，在某些情况下可能需要返回字段后的空格，使用这种格式时后面的空格会被自动处理掉。静态表的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用空间通常比动态表多。 动态表动态表包含变长字段，这样存储的优点是占用空间少，但频繁的更新删除记录会产生空间碎片，需要定期执行OPTIMIZE TABLE或myisamchk -r来改善性能。而且动态表出现故障的时候恢复相对比较困难。 压缩表压缩表由 myisamchk 工具创建，占用非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。 InnoDB从 MySQL 5.5.5 开始, 使用 InnoDB 作为默认存储引擎。具有 ACID 特性： A: atomicity 原子性事务是一个原子操作单元，其对数据的修改，要么全都执行，要么都不执行。如果事务执行到一半出现错误，数据库就会回滚到事务开始执行的状态。 C: consistency 一致性在事务开始和结束后，数据库的完整性约束没有被破坏。如，A 向 B 转账，A 扣钱成功，则 B 必然收款成功。 I: isolation 隔离性同一时间，只允许一个事务请求同一数据，不同事务之间彼此没有任何干扰。 D: durability 持久性事务完成之后，它对数据的修改是永久性的，即使出现系统故障也能够保持。 MyISAM 与 InnoDB 比较 CURD 操作 如果表更新不频繁，以查询为主，则执行SELECT查询，MyISAM 速度更快。 如果表修改频繁，处于性能考虑，应该使用 InnoDB。 清空整张表的数据时 (DELETE FROM table_name)，InnoDB 是一行一行的删除，效率非常慢。所以，清空 InnoDB 表最好使用TRUNCATE table。 事务支持 MyISAM 不支持事务；InnoDB 支持事务，外键等。具有事务的提交 (commit)、回滚 (rollback) 和故障修复 (crash recovery) 的特性。 而且 InnoDB 的 AUTOCOMMIT 是默认开启的，即每条 SQL 语句会默认被封装成一个事务，自动提交。所以，允许的情况下，尽量将多条 SQL 语句放在 BEGIN TRANSACTION 和 COMMIT 之间，组成一个事务提交，这样可以减小数据库多次提交导致的开销。 存储结构 MyISAM：每个 MyISAM 表在磁盘上存储成三个文件 (.frm，存储表定义；.MYD，存储表数据；.MYI，存储表索引) InnoDB：所有表都保存在同一个数据文件中 (也可能是多个文件，或者是独立的表空间文件)，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB。 存储空间 MyISAM：支持三种不同的存储格式 (静态表、动态表和压缩表)，所以 MyISAM 存储空间可以更小。 InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓存池用于高速缓冲数据和索引。 锁差异 MySQL 表级锁有两种：表共享锁 (Table Read Lock) 和表独占写锁 (Table Write Lock)。 MyISAM：只支持表级锁，用户在操作 MyISAM 表时，SELECT, UPDATE, DELETE, INSERT语句都会给表自动加锁。MyISAM 表的读操作 (表共享锁) 不会阻塞其它线程对该表的读操作，但会阻塞对该表的写操作；MyISAM 表的读和写操作之间，以及写和写操作之间是串行的。即当一个线程对一个表加写锁 (表独占写锁) 后，其它线程的读和写操作都会阻塞，直到这个线程释放写锁。 MyISAM 表的写锁优先级比读锁高，即使读请求比写请求先到锁等待队列，写锁也会插到读请求之前。所以，MyISAM 引擎不太适合有大量更新操作和查询操作的表，大量的更新操作会造成查询操作很难获得读锁，从而大大影响查询操作。 InnoDB：支持行级锁，行锁大幅度提升了多用户并发操作的性能。 主键 MyISAM：MyISAM 表允许没有任何索引和主键，而且索引都是保存行的地址。 InnoDB：如果没有设定主键或非空唯一索引，会自动生成一个 6 字节的主键，数据是主索引的一部分，附加索引保存的是主索引的值。 表的行数 MyISAM：保存有表的总行数，SELECT COUNT(*) FROM table_name; 会直接取出该值。 InnoDB：没有保存表的总行数，SELECT COUNT(*) FROM table_name; 会遍历整张表。 因为 MyISAM 保存的是整张表的总行数，所以当添加条件查询表行数的时候，MyISAM 和 InnoDB 查询处理方式都一样 SELECT COUNT(*) FROM table_name WHERE ...。 MEMORYMEMORY 存储引擎，直接将数据保存到内存中，所以速度非常快。但是，MEMORY 表只能使用不变长度的字段，所以BLOG和TEXT不能够使用。VARCHAR是一种可变的类型，但因为它在 MySQL 内部当做长度固定不变的CHAR类型，所以可以使用。 MEMORY 引擎使用场景： 因为存储在内存，所以表数据量不能太大 内存中保存的数据不具备持久性，而且稳定性不高，所以数据容易丢失所造成的影响不大的情况 MEMORY 引擎支持 HASH 索引和 B-tree 索引。 ARCHIVEARCHIVE 引擎仅仅支持基本的插入和查询，MySQL 5.5 之后，开始支持索引功能。ARCHIVE 拥有很好的压缩机制，使用 zlib 压缩库，在记录被请求是会实时压缩，所以经常被用来当做仓库使用。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://lizsgh.github.io/tags/mysql/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}]},{"title":"Docker - Install Docker (CE) for Ubuntu","slug":"docker/installation","date":"2016-12-31T16:00:00.000Z","updated":"2019-02-26T07:30:49.421Z","comments":true,"path":"2017/01/01/docker/installation/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/docker/installation/","excerpt":"","text":"Get Docker CE for Ubuntu 安装前准备工作 Ubuntu 系统要求安装 Docker CE，需要 64 位的以下版本的 Ubuntu 系统： Bionic 18.04 (LTS) Xenial 16.04 (LTS) Trusty 14.04 (LTS) 卸载旧版本 Docker旧版本的 Docker 名为 docker 或 docker-engine。 1sudo apt remove docker docker-engine docker.io 安装 Docker CE1. 更新系统软件源1sudo apt-get update 2 安装让 apt 工具支持 HTTPS 的相关库12345sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 3. 添加官方 GPG 密钥1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 4. 设置 Docker 的稳定版仓库（amd64）1234sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 5. 安装 Docker CE12sudo apt-get updatesudo apt-get install docker-ce 安装 Docker Compose Install Docker Compose 方法一 用以下命令下载 Docker Compose，将 $dockerComposeVersion 代替为要下载的版本。1curl -L https://github.com/docker/compose/releases/download/$dockerComposeVersion/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 如，下载 1.14.0 版本的 Docker Compose：1curl -L https://github.com/docker/compose/releases/download/1.14.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose https://github.com/docker/compose/releases 更改下载的 /usr/local/bin/docker-compose 文件权限： 1sudo chmod +x /usr/local/bin/docker-compose 测试是否安装成功 1docker-compose --version 方法二通过 Python 的 pip 来安装：1sudo pip install docker-compose 配置 DaoCloud 加速器Docker Hub 提供众多镜像，你可以从中自由下载数十万计的免费应用镜像， 这些镜像作为 docker 生态圈的基石，是我们使用和学习 docker 不可或缺的资源。为了解决国内用户使用 Docker Hub 时遇到的稳定性及速度问题 DaoCloud 推出永久免费的新一代加速器服务。 首先，在 DaoCloud 注册个人账号，登录之后在个人 dashboard 右上角，头像左边有一个火箭标志的加速器图标，点击进去，安装介绍操作就可以了。","categories":[{"name":"Docker","slug":"Docker","permalink":"https://lizsgh.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://lizsgh.github.io/tags/docker/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"https://lizsgh.github.io/categories/Docker/"}]},{"title":"MySQL - Index","slug":"mysql/indexes","date":"2016-12-31T16:00:00.000Z","updated":"2019-03-13T07:41:02.581Z","comments":true,"path":"2017/01/01/mysql/indexes/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/mysql/indexes/","excerpt":"","text":"索引简介MySQL 索引是一中特殊的文件，它们包含着对数据表所有记录的引用指针。就像书本的目录一样，在没有索引的情况下，数据库会遍历所有相关记录，找出符合条件的记录；而有索引之后，数据库会先在索引中查找，再定位到具体的物理位置去除数据信息。 查看表中的索引信息：1SHOW INDEX FROM `table_name` \\G; 索引的优缺点优点： 索引可以加快数据库检索速度 缺点： 索引本身也是表，因此会占用存储空间。 数据库的添加、修改、删除等操作的效率会降低，因为同时需要维护索引表。 索引分类常见的索引有：普通索引、主键索引、唯一索引、组合索引、全文索引、空间索引等。 普通索引普通索引是最基本的索引，一个列组成一个索引，基本没有任何限制，一张表中可以有多个普通索引。普通索引主要是为了加快查找速度。 创建表的时候同时创建普通索引： 12345 CREATE TABLE `users` ( `id` int(11) NOT NULL,`name` varchar(32) NOT NULL,INDEX `index_name` (name(16)) ); 在name创建普通索引index_name，(16)表示用name列的前 16 个字符创建索引，不指定长度 (如INDEX index_name (name))，则使用列的完整值。建立索引的时候，很多时候不必要使用相应列定义的长度，如果前一部分的值具有唯一性，则只截取前面一部份值影响也不大 (如这里的name一般不会超过 10 个字符)。这样会加速索引查询速度，而且还减少索引文件的大小，提高插入修改的速度等。 创建表之后添加索引： 123CREATE INDEX `index_name` ON users(name(32));# orALTER TABLE `users` ADD INDEX index_name(`name`); 删除索引： 1DROP INDEX `index_name` ON `users`; 唯一索引唯一索引，与普通索引类似。不过，索引列的值必须唯一，但可以为空值，而且每列的空值可以有多个。 创建表的时候指定唯一索引： 12345 CREATE TABLE `users` ( `id` int NOT NULL,`name` varchar(32) NOT NULL,UNIQUE `index_name` (`name`), ); 创建表之后添加索引： 123CREATE UNIQUE INDEX `index_name` ON `users` (`name`);# OrALTER TABLE `users` ADD UNIQUE `index_name` (`name`); 主键索引即主键，一张表中只能够有一个主键，并且不允许重复值和空值。主键索引可以加速查找和唯一约束。 创建表的时候添加主键索引： 12345678910 CREATE TABLE `users` ( `id` int(11) NOT NULL AUTO_INCREMENT,`name` varchar(32) NOT NULL,PRIMARY KEY (`id`) ); # Or CREATE TABLE `users` ( `id` int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,`name` varchar(32) NOT NULL ); 创建表之后添加主键索引： 1ALTER TABLE `users` ADD PRIMARY KEY(`id`); 普通索引、唯一索引和主键索引比较： 三者都是单列索引，即索引只能由一列组成 主键索引，每张表只能有一个，不能为空值，而且值不能够重复 唯一索引，每张表可以有多个，可以设置为空值，而且每列可以出现多个空值，但是不为空的值不能重复。 普通索引，基本没什么限制。每张表可以有多个，而且不为空的值能够重复。 全文索引当需要根据文本中的关键字来检索的时候，普通的索引就无效了，如果不用索引而且数据量很大的话，全表检索将消耗太多的时间，这时候，可以使用 FULLTEXT 索引。 如上面的users表，当插入大量的数据的时候，执行查找语句：123SELECT * FROM `users` WHERE `name` LIKE 'lizs%' \\G;# 当检索关键字的时候，普通索引并不生效SELECT * FROM `users` WHERE `name` LIKE '%lizs%' \\G; 这时候，就需要使用 FULLTEXT 索引了。 只有InnoDB (MySQL5.6开始支持)和MyISAM的CHAR，VARCHAE和TEXT列支持 FULLTEXT 索引。MySQL 5.7.6 开始支持中文的全文索引。 创建表的时候添加全文索引： 123456 CREATE TABLE `users` ( `id` int NOT NULL AUTO_INCREMENT,`name` varchar(32) NOT NULL,PRIMARY KEY (`id`),FULLTEXT (`name`), ); 创建表之后添加索引： 123CREATE FULLTEXT INDEX `index_name` ON `users` (`name`);# OrALTER TABLE `users` ADD FULLTEXT `index_name` (`name`); 组合索引 (复合索引) MySQL 查询只会使用一个索引，所以当频繁使用多个列作为查询条件的时候，建立多个索引来优化查询速度也只有前面一个有效，查询速度优化不理想。这时候，可以考虑使用组合索引。 组合索引遵循最左前缀原则。如，组合索引(a, b, c)只有查询条件为a, a, b, a, b, c才会使用索引。1234SELECT * FROM table_name WHERE b='x' AND c='x'; # Extra: Using whereSELECT * FROM table_name WHERE a='x'; # Extra: Using index conditionSELECT * FROM table_name WHERE a='x' AND b='x'; # Extra: Using index conditionSELECT * FROM table_name WHERE a='x' AND b='x' AND c='x'; # Extra: Using index condition 组合索引中，如果列中含有 NULL 值，那么这一列对于此组合索引就是无效的。所以，在数据库设计时，对于需要有可能使用组合索引的列，不要设置默认值为 NULL。 创建表的时候添加组合索引： 1234567 CREATE TABLE `users` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(32) NOT NULL,`city` varchar(32) NOT NULL,PRIMARY KEY (`id`),INDEX index_name_city (name(16), city) ); 创建表之后添加索引： 123CREATE INDEX index_name_city ON `users` (name(16), city(16));# OrALTER TABLE `users` ADD INDEX index_name_city (name(16), city(16)); 删除索引：1DROP INDEX index_name ON table_name; 索引的使用什么时候使用索引？ 经常作为查询条件在WHERE子句中出现的列最好建立索引 经常用来排序在ORDER BY子句中出现的列最好建立索引 查询中与其它表关联的字段，外键关系建立索引 高并发条件下倾向组合索引 什么时候不要使用索引？ 经常增删改的列 有大量重复值的列 表数据不多的情况下也不建议使用索引 索引使用注意事项 组合索引中，如果列中含有 NULL 值，那么这一列对于此组合索引就是无效的。所以，在数据库设计时，对于需要有可能使用组合索引的列，不要设置默认值为 NULL。 定义索引的时候，如果可能应该指定前缀长度。如果索引列的值的前一部份具有唯一性，合理指定索引的前缀长度，不但可以提高查询速度，还可以提高插入修改的速度，而且还节省了索引占用的磁盘空间。 MySQL 查询只使用一个索引。因此，如果WHERE子句中使用了索引的话，ORDER BY排序子句就不会使用索引了。或者多列排序的时候，只有前面一个索引生效，所以在一定要使用多列排序的情况下，最好创建组合索引。 在查询条件中使用&lt;&gt;，IS NULL会导致索引失效 在查询中使用OR连接多个查询条件会导致索引失效，这时候可以分多次SELECT，然后用UNION ALL连接起来。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://lizsgh.github.io/tags/mysql/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}]},{"title":"常用设计模式","slug":"others/design_pattern","date":"2016-12-31T16:00:00.000Z","updated":"2019-03-08T14:04:18.994Z","comments":true,"path":"2017/01/01/others/design_pattern/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/others/design_pattern/","excerpt":"","text":"设计模式分类设计模式大概分为 23 种，分三大类： 创建型模式 (Creational Patterns) 结构型模式 (Structural Patterns) 行为型模式 (Behavioral Patterns) 创建型模式创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建那些对象时更加灵活。 工厂模式 (Factory Pattern) 抽象工厂模式 (Abstract Factory Pattern) 单例模式 (Singleton Pattern) 创建者模式 (Builder Pattern) 原型模式 (Prototype Pattern) 简单工厂模式简单工厂模式不是 23 种设计模式里的一种，一般用于小项目或具体产品很少扩展的情况。它由三种角色组成： 抽象产品 具体产品 工厂类 1234567891011121314151617181920212223242526272829303132333435363738394041from abc import ABCMeta, abstractmethodclass Car(metaclass=ABCMeta): \"\"\"Abstract product.\"\"\" @abstractmethod def price(self): passclass Bmw(Car): \"\"\"Implemented product.\"\"\" def price(self): return '$100,000'class Byd(Car): \"\"\"Implemented product\"\"\" def price(self): return '$10,000'class Factory(object): \"\"\"Factory\"\"\" def produce(self, car_type): if car_type == 'bmw': return Bmw() elif car_type == 'byd': return Byd() else: return Noneclass Client(object): def main(self, *args, **kws): # BMW car Factory().produce('bmw').prince() # BYD car Factory().produce('byd').prince() 简单工厂模式实现了产品类与客户端分离，但当用户需要添加更多产品的时候，就要修改工厂类的代码了，工厂类并不符合 OOP 开放封闭原则。 工厂模式意图：定义一个创建对象的接口，让其子类自己决定实例化哪个工厂类，工厂模式使其创建过程延迟到子类进行。主要解决：接口选择的问题。优点：扩展性高，符合开闭原则。缺点：每增加一个产品，都要增加一个具体产品类和具体工厂类，使得系统中类的个数不断增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。角色： 抽象产品类 具体产品类 抽象工厂类 具体工厂类 1234567891011121314151617181920212223242526272829303132333435363738394041import abcclass Car(classmeta=abc.ABCMeta): @abc.abstractmethod def price(self): passclass Bmw(Car): def price(self): return '$10,000'class Byd(Car): def price(self): return '$1,000'class Factory(classmeta=abc.ABCMeta): @abc.abstractmethod def produce(self): passclass BmwFactory(Factory): def produce(self): return Bmw()class BydFactory(Factory): def produce(self): return Byd()class Client(object): def main(self, *args, **kws): # BMW car bmw = BmwFactory().produce() # BYD car byd = BydFactory().produce() 抽象工厂模式意图：创建一系列相关或相互依赖产品 (产品族)。当系统中的产品有多于一个的产品族，而系统只消费其中某一族的产品的时候。主要解决：接口选择的问题。优点：当客户端需要使用某一产品族的产品的时候，直接调用具体产品类接口，使用非常方便。缺点：产品族扩展相对麻烦。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import abcclass Mouse(metaclass=abc.ABCMeta): @abc.abstractmethod def price(self): passclass DellMouse(Mouse): def price(self): return '$10'class HpMouse(Mouse): def price(self): return '$15'class Keyboard(metaclass=abc.ABCMeta): @abc.abstractmethod def price(self): passclass DellKeyboard(Keyboard): def price(self): return '$100'class HpKeyboard(Keyboard): def price(self): return '$150'class Factory(metaclass=abc.ABCMeta): @abc.abstractmethod def create_mouse(self): pass @abc.abstractmethod def create_keyboard(self):class DellFactory(Factory): def create_mouse(self): return DellMouse() def create_keyboard(self): return DellKeyboard()class HpFactory(Factory): def create_mouse(self): return HpMouse() def create_keyboard(self): return HpKeyboard()class client(object): def main(self): # HP product hp = HpFactory() hp_mouse = hp.create_mouse() hp_keyboard = hp.create_keyboard() # Dell product dell = DellFactory() dell_mouse = dell.create_mouse() dell_keyboard = dell.create_keyboard() 单例模式意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。主要解决：一个全局使用的类频繁地创建与销毁。优点：在内存中只有一个实例，减少了内存的开销，同时避免了对资源的多重占用 (如写 文件操作)。缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎样实例化。使用场景： 要求生产唯一序列号。 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 12345678910111213141516171819202122# Python implement singleton with __new__class Singleton(object): def __new__(cls, *args, **kwargs): if not hasattr(cls, '_instance'): cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs) return cls._instance# Python implement singleton with metaclassclass SingletonBase(type): def __init__(self, *args, **kwargs): _instance = None super().__init__(self, *args, **kwargs) def __call__(self, *args, **kwargs): if not self._instance: self._instance = super().__call__(self, *args, **kwargs) return self._instanceclass Singleton(metaclass=SingletonBase): pass 创造者模式意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。主要解决：在软件系统中，系统由若干部件组完，这些部件不变，但是组合方式经常变化。何时使用：一些基本部件不变，但其组合经常变化的时候。角色： 产品类 抽象建造者 具体建造者 指挥者 (director) 优点： 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品。 每一个具体建造者都相对独立，而与其它的具体建造者无关，因此可以很方便地替换具体建造者或新增具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。 可以更加精密地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 增加新的具体建造者无需修改原有类库的代码，指挥者类针对抽象建造者类编程，而不是具体建造者类，符合依赖倒置原则。缺点： 产品之间差异性很大的情况：建造者模式所创建的产品类一般具有较多的共同点，其组成部分相似，如果产品之间的差异很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 产品内部变化很复杂的情况：如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import abcclass Meal(object): \"\"\"meal product class\"\"\" food = None drink = Noneclass MealBuilder(metaclass=abc.ABCMeta): \"\"\"Abstract builder\"\"\" def __init__(self): self.meal = Meal() @abc.abstractmethod def add_food(self): pass @abc.abstractmethod def add_drink(self): pass def get_meal(self): return self.mealclass MealA(MealBuilder): \"\"\"Implement builder\"\"\" def add_food(self): self.meal.food = 'childken burger' def add_drink(self): self.meal.drink = 'coke'class MealB(MealBuilder): \"\"\"Implement builder\"\"\" def add_food(self): self.meal.food = 'veg burger' def add_drink(self): self.meal.drink = 'pepsi'class Waiter(object): \"\"\"director\"\"\" def create(self, meal): meal.add_food() meal.add_drink() return meal.get_meal()class Client(object): def main(self): # meal A a = MealA() meal_a = Waiter(a).get_meal() # meal B b = MealB() meal_b = Waiter(b).get_meal()","categories":[{"name":"Others","slug":"Others","permalink":"https://lizsgh.github.io/categories/Others/"}],"tags":[{"name":"others","slug":"others","permalink":"https://lizsgh.github.io/tags/others/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"https://lizsgh.github.io/categories/Others/"}]},{"title":"Cordova plugin - JPush","slug":"cordova/cordova_jpush","date":"2016-11-30T16:00:00.000Z","updated":"2019-02-26T07:53:52.169Z","comments":true,"path":"2016/12/01/cordova/cordova_jpush/","link":"","permalink":"https://lizsgh.github.io/2016/12/01/cordova/cordova_jpush/","excerpt":"","text":"本地通知 本地通知：本地通知不依赖网络，无网络条件下依旧可以触发；可以定时发出通知。 Cordova 本地通知，可以用插件 cordova-plugin-local-notification 实现。 1234# Plugin Registrycordova plugin add de.appplant.cordova.plugin.local-notification# Githubcordova plugin add https://github.com/katzer/cordova-plugin-local-notifications cordova-plugin-local-notification 插件wiki。 远程实时通知 远程通知：依赖网络，可以根据需要实时推送通知。 当在某种情况下，你需要向 APP 用户推送消息，而且该用户又没有打开 APP 的时候（后台运行）。你怎样才能够发出消息通知用户呢？ 极光推送提供了一个 Cordova 通知插件 jpush-phonegap-plugin，即使 APP 在后台运行状态，也可以实现实时推送通知的功能。 Cordova 插件 jpush-phonegap-plugin 安装 (Android) 先在极光推送官网注册一个账号，然后，在极光开发者服务创建一个应用 （因为，在安装插件的时候会用到 AppKey）。 应用名称：填 Cordova 配置文件config.xml 中的 &lt;name&gt; 即可。 应用包名（Android）：填 Cordova 配置文件 config.xml 中的 &lt;widget&gt; 中的 id 即可。 Cordova 应用中添加插件：cordova-plugin-device 和 jpush-phonegap-plugin。要用到 cordova-plugin-device 插件。 123456# cordova-plugin-devicecordova plugin add cordova-plugin-device# jpush-phonegap-plugincordova plugin add jpush-phonegap-plugin --variable APP_KEY=AppKey# or githubcordova plugin add https://github.com/jpush/jpush-phonegap-plugin.git --variable APP_KEY=AppKey 注意：AppKey 就是在极光开发者服务中创建应用之后，在应用信息中的 AppKey。 jpush-phonegap-plugin 使用jpush-phonegap-plugin 在需要在 cordova deviceready 的时候初始化才能够使用。初始化之后，正常情况下，会根据设备产生一个 registration ID（相对不同设备具有唯一性）。我们可以将这个 registration ID 保存到服务器端，通过这个 registration ID 对特定用户发送通知。也可以，通过设置 tag 等来实现。更多使用可以查看官方文档：JPush 官方文档 插件的一些常用 Cordova 监听事件，如： jpush.receiveNotification：Cordova APP 在接收到 jpush 远程通知的时候触发事件。 jpush.openNotification：点击通知栏的 jpush 远程通知的时候触发事件。 1234567891011121314151617181920212223242526272829303132333435jQuery(function($) &#123; var cordovaJS = &#123; // Application constructor initialize: function() &#123; document.addEventListener(&apos;devicerady&apos;, this.onDeviceReady.bind(this), false); document.addEventListener(&apos;jpush.openNotification&apos;, this.jPushOpenNotification.bind(this), false); &#125;, // Application deviceready event onDeviceReady: function() &#123; this.jPushInitEvent(); &#125;, jPushInitEvent: function() &#123; window.plugins.jPushPlugin.init(); // Setting the notification max showing number window.plugins.jPushPlugin.setLatesNotificationNum(5); &#125;, // The event when user click notification jPushOpenNotification: function(receiveObj) &#123; // When click notification, show the message with alert button // Requirement to install cordova plugin: cordova-plugin-dialogs navigator.notification.alert(receiveObj.alert); &#125; &#125;; cordovaJS.initialize(); // Get registration ID window.plugins.jPushPlugin.getRegistrationID(function(id) &#123; // The var id is the registration ID // So you can do something to save it to server here. &#125;);&#125;); 正常情况下，初始化完之后，我们就可以在极光推送后台创建的项目中手动发送通知了（发送通知的时候，通知内容一定要填，不然设备不会显示通知）。但是，这不是我们想要的。通常，我们需要在服务器后台根据一定的条件自动触发推送条件，并且推送到特定的用户设备上。插件官方提供了服务端 SDK，我们可以通过安装相应的 SDK，通过调用相关的接口来实现服务器端发送通知的功能。如，Python： 安装 Python SDK 1pip/pip3 install jpush 通过安装的 jpush 模块编写发送通知功能， jpush_client.py： 123456789101112131415161718192021222324252627282930import jpushclass JPushClient(object): &quot;&quot;&quot;jPush client for Instrument Connect Requirements: the jpush module must be installed (pip/pip3 install jpush). More info: https://docs.jiguang.cn/jpush/server/3rd/python_sdk/ &quot;&quot;&quot;def __init__(self, app_key, master_secret, *args, **kwargs): # AppKey and Master Secret from jiguang project self.app_key = app_key self.master_secret = master_secretdef push_notification(self, registration_id, content, *args, **kwargs): &quot;&quot;&quot;Push notification to user via jPush client: :param registration_id: a list of registration id which binding the user phone :param content: the notification content that will be send to user :return: &quot;&quot;&quot; # Init a jPush object _jpush = jpush.JPush(self.app_key, self.master_secret) # Create a push notification push = _jpush.create_push() # Setting push audience push.audience = jpush.audience(&#123; &apos;registration_id&apos;: registration_id &#125;) # Setting push platform push.platform = jpush.all_ # Setting notification content push.notification = jpush.notification(alert=content) push.send() 调用编写好的接口，发送通知： 12345678from xxx.jpush_client import JPushClient# AppKey and Master Secret from your jiguang projectapp_key = &apos;your project AppKey&apos;master_secret = &apos;your project Master Secret&apos;# A list of registration id that you want to send the notification toregistration_id = [&apos;xxx&apos;, &apos;xxx&apos;]content = &apos;hello&apos;JPushClient(app_key, master_secret).push_notification(registration_id, content) 更多 Python SDK 的使用可以查看 ipush-api-python-client","categories":[{"name":"Cordova","slug":"Cordova","permalink":"https://lizsgh.github.io/categories/Cordova/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Cordova","slug":"Cordova","permalink":"https://lizsgh.github.io/categories/Cordova/"}]},{"title":"Ubuntu Desktop Entry","slug":"linux/ubuntu_desktop_entry","date":"2016-11-12T16:00:00.000Z","updated":"2019-02-26T08:29:34.704Z","comments":true,"path":"2016/11/13/linux/ubuntu_desktop_entry/","link":"","permalink":"https://lizsgh.github.io/2016/11/13/linux/ubuntu_desktop_entry/","excerpt":"","text":"Linux Desktop Entry 文件以 .desktop 为后缀，保存了程序启动配置信息。类似 Windows 下的快捷方式。Desktop Entry 文件一般存放在 /usr/share/applications 目录下。 jetbrains-phpstorm.desktop12345678910[Desktop Entry]Version=1.0Type=ApplicationName=PhpStormIcon=/opt/PhpStorm-2016.2/bin/webide.pngExec=&quot;/opt/PhpStorm-2016.2/bin/phpstorm.sh&quot; %fComment=Develop with pleasure!Categories=Development;IDE;Terminal=falseStartupWMClass=jetbrains-phpstorm 配置参数 Version：可选，版本号 Type：必选，Desktop Entry 文件的类型。常见类型有 Application 和 Link Application：表示当前 Desktop Entry 文件为一个应用程序 Link：表示当前 Desktop Entry 文件指向一个 URL Encoding：可选，指定当前 Desktop Entry 文件中字符串的编码方式 Name：必选，应用程序名称。在 GUI 中看到的是该名称，而不是文件名称。如 jetbrains-phpstorm.desktop 看到是名称是 PhpStorm，而不是 jetbrains-phpstorm Comment：可选，当前应用的描述 Exec：可选，只有在 Type=Application 时，才有意义。表示启动应用程序要执行的命令 URL：可选，只有在 Type=URL 时，才有意义。定义该 Desktop Entry 文件指向的 URL Icon：可选，图标 Categories：可选，只有在 Type=Application时，才有意义。指定该应用程序在菜单中显示的类型 Terminal：可选，布尔值，指定该应用程序是否需要在 Terminal 中运行。 更多配置参数可以参考 Desktop Entry Specification","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Shell 函数返回值","slug":"linux/shell_method_return_value","date":"2016-10-26T16:00:00.000Z","updated":"2019-02-26T09:11:41.671Z","comments":true,"path":"2016/10/27/linux/shell_method_return_value/","link":"","permalink":"https://lizsgh.github.io/2016/10/27/linux/shell_method_return_value/","excerpt":"","text":"如果 shell 函数中没有 return 返回值，则函数的返回值是该函数的执行状态：0，成功；1，失败。注意，shell 函数 return 返回的值只能够是整数 。 想要在 shell 函数中返回特定的值，可以通过将需要返回的值输出到标准输出中来传递给主程序变量。 12345678910111213#!/bin/shdo_check() &#123; if ps -ef | grep php5-cgi | grep -v grep &gt; /dev/null then echo &quot;php5-cgi is running...&quot; else echo &quot;php5-cgi is not running...&quot;&#125;RESULT=`do_check`echo RESULT # 输出：php5-cgi is running 或 php5-cgi is not runningecho $? # 如果函数成功执行，输出 0；否则，输出 1 因为，shell 赋值默认为字符串，所以要用命令替换符(`)。否则，RESULT 的值为字符串 do_check。$?：上个命令的退出状态，或函数的返回值","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://lizsgh.github.io/tags/shell/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Ubuntu crontab","slug":"linux/ubuntu_crontab","date":"2016-10-25T16:00:00.000Z","updated":"2019-02-26T13:19:42.846Z","comments":true,"path":"2016/10/26/linux/ubuntu_crontab/","link":"","permalink":"https://lizsgh.github.io/2016/10/26/linux/ubuntu_crontab/","excerpt":"","text":"cron 是 linux 下的一个定时执行工具。启动、关闭：123$ service cron start$ service cron stop$ service cron restart 设置开机启动，在 rc.local 脚本添加 shell 命令：1service cron start rc.local 文件的位置因为版本问题，可能不一样。/etc/rc.local /etc/rc.d/rc.local crontab 命令1234567usage: crontab [-u user] file crontab [ -u user ] [ -i ] &#123; -e | -l | -r &#125; (default operation is replace, per 1003.2) -e (edit user's crontab) -l (list user's crontab) -r (delete user's crontab) -i (prompt before deleting user's crontab) 比如，删除 lizs 用户的定时任务：12lizs@lizs-pc:/etc$ crontab -u lizs -i -rcrontab: really delete lizs&apos;s crontab? (y/n) n crontab 添加定时任务修改默认编辑器：select-editor首先打开编辑页面 crontab -e，用以下方式添加任务：1t1 t2 t3 t4 t5 command t1，分钟（0 - 59） t2，小时（0 - 23） t3，日期（1 - 31） t4，月份（1 - 12） t5，星期（0 - 6, 0 代表星期日） command，要执行的任务，如访问某个网址：curl https://www.baidu.com 除了以上参数之外还有几个特殊符号： *，代表所有取值范围内的数字 /，代表每的意思，如*/2表示每 2 个单位 -，代表从某个数值到某个数值，如3-10表示从 3 到 10 ,，分开几个离散的数字，如 2,23 示例：1234// 每天晚上 23:3030 23 * * * curl https://www.baidu.com// 每天中午 12 点到晚上 11 点，每隔两个小时和早上 8 点0 12-23/2,8 * * * /home/lizs/app/backup.sh","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Shell 通配符","slug":"linux/shell_通配符","date":"2016-10-24T16:00:00.000Z","updated":"2019-02-26T09:11:29.223Z","comments":true,"path":"2016/10/25/linux/shell_通配符/","link":"","permalink":"https://lizsgh.github.io/2016/10/25/linux/shell_通配符/","excerpt":"","text":"*：代表任意长度的任意字符。 ?：代表一个任意字符。 []：代表一个指定范围内的字符。比如，[abc123]，代表abc123中的一个字符。 [^]：代表一个指定范围外的字符。比如，[abc123]，代表除了abc123之外的一个字符。 123$ touch file file1 file2 file3 file123$ lfile file1 file123 file2 file3 * 12$ l file*file file1 file123 file2 file3 ? 12$ l file?file1 file2 file3 [] 12$ l file[123456]file1 file2 file3 [^] 12$ l file[^12]file3","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://lizsgh.github.io/tags/shell/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Shell 变量","slug":"linux/shell_variable","date":"2016-10-22T16:00:00.000Z","updated":"2019-02-26T09:15:12.764Z","comments":true,"path":"2016/10/23/linux/shell_variable/","link":"","permalink":"https://lizsgh.github.io/2016/10/23/linux/shell_variable/","excerpt":"","text":"定义变量 定义时，变量名前面不能够加 $ 变量名与 = 之间不能够有空格 变量名，首字符必须为字母（[A-Za-z]+），中间不能够有空格，不能够使用标点符号，不能够使用 bash 里的关键字，可以使用下划线（_）。 使用变量 在变量名前面加 $ 即可。 变量名可以选择用花括号括（{}）起来，主要是为了帮助解析器识别变量的边界。 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 12345#!/bin/shname=&quot;lizs&quot;readonly namename=&quot;lzs&quot; 运行以上脚本将会报错：name: is read only 删除变量 使用 unset 命令可以删除变量 unset 不能够删除只读变量 12345#!/bin/shname=&quot;lizs&quot;unset nameecho $name 运行以上命令的输出为空","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://lizsgh.github.io/tags/shell/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Shell 输入输出","slug":"linux/shell_input_output","date":"2016-10-21T16:00:00.000Z","updated":"2019-02-26T09:19:30.479Z","comments":true,"path":"2016/10/22/linux/shell_input_output/","link":"","permalink":"https://lizsgh.github.io/2016/10/22/linux/shell_input_output/","excerpt":"","text":"Shell 读取输入用 read 简单的输入示例：read.sh 1234#!/bin/bashread nameecho &quot;welcome $name&quot; 执行结果： 123$ ./read.shlizs // shell 脚本会等待输入变量值wecome lizs 带提示的输入，可以在前面 echo 一句话，或者用 -p 来实现： 123#!/bin/shread -p &quot;please input your name: &quot; nameecho &quot;welcome $name&quot; 执行效果和上面一样。 输入多个变量， 123#!/bin/shread -p &quot;please input your name: &quot; firstname lastnameecho &quot;welcome lastname&quot; 执行结果： 123$ ./read.shplease input your name: hello worldwelcome hello world","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://lizsgh.github.io/tags/shell/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"SDK environment to deploy Cordova apps for Android devices","slug":"cordova/cordova_env","date":"2016-09-30T16:00:00.000Z","updated":"2019-02-26T07:30:21.814Z","comments":true,"path":"2016/10/01/cordova/cordova_env/","link":"","permalink":"https://lizsgh.github.io/2016/10/01/cordova/cordova_env/","excerpt":"","text":"Cordova - Develop for platforms (Android) Installing the RequirementsJava Development Kit (JDK)首先安装 JDK 8。 方法一：从官网下载安装包安装(JDK8)。 下载相应平台的安装包，如：Ubuntu的jdk-8u191-linux-x64.tar.gz。 解压到/usr/local/lib/jvm/目录下 (目录自定义)，假如解压之后目录为：/usr/local/lib/jvm/jdk1.8.0_191。 全局配置，添加文件/etc/profile.d/jvm。(也可以配置当前用户~/.bashrc)。 1234export JAVA_HOME=/usr/local/lib/jvm/jdk1.8.0_191export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=.:$&#123;JAVA_HOME&#125;/bin:$PATH 再source /etc/profile，使配置生效。 检查是否安装成功。 1234$ java -versionjava version \"1.8.0_191\"Java(TM) SE Runtime Environment (build 1.8.0_191-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) 方法二：使用 PPA 源安装 123sudo add-apt-repository ppa:webupd8team/javasudo apt updatesudo apt install oracle-java8-installer 安装过程中，安装器会提示你是否同意 Oracle 的服务协议。 Gradle从 Cordova 6.4.0 开始，Cordova 需要安装 Gradle。 从官网上下载 Gradle 安装包，解压到/opt/gradle/。 添加/opt/gradle/bin/到PATH环境变量，/etc/profile。1export PATH=$PATH:/opt/gradle/bin Android SDK 方法一：直接下载 Android SDK 安装包，解压到/home/lizs/Android/sdk/ (目录自定义)。然后，配置环境变量，添加/etc/profile.d/android.sh： 12export ANDROID_HOME=/home/lizs/Android/sdkexport PATH=.:$&#123;ANDROID_HOME&#125;/tools:$&#123;ANDROID_HOME&#125;/platform-tools:$PATH 方法二：安装 Android Studio 的时候安装 Android SDK (我使用的就是这个方式，下载 SDK 的时候速度超级快)。 从 https://developer.android.google.cn/studio/下载 Android Studio 的安装包，解压到/opt/android-studio/。 进入/opt/android-studio/bin/目录执行安装脚步./studio.sh进行安装。 安装的时候选择自定义安装，可以指定 Android SDK 安装路径 (Android SDK Location)，如/home/lizs/Android/sdk/。 安装完毕，打开 Android Studio 可以在顶部菜单栏Tools-&gt;Create Desktop Entry创建快捷方式。 Ubuntu18.04 也可以直接从Ubuntu Software中心安装 Android Studio。 配置环境变量，和方法一一样。 同意 Android SDK 服务协议。如果这时候创建并运行 Cordova 项目cordova run android，出现没有接受 Android SDK 服务协议的错误 (You have not accepted the license agreements of the following SDK components)，需要同意 Android SDK 服务协议：进入目录$ANDROID_HOME/tools/bin/，执行sdkmanager --licenses，一直输入y回车。","categories":[{"name":"Cordova","slug":"Cordova","permalink":"https://lizsgh.github.io/categories/Cordova/"}],"tags":[{"name":"cordova","slug":"cordova","permalink":"https://lizsgh.github.io/tags/cordova/"}],"keywords":[{"name":"Cordova","slug":"Cordova","permalink":"https://lizsgh.github.io/categories/Cordova/"}]},{"title":"Data model","slug":"python/data_model","date":"2016-09-30T16:00:00.000Z","updated":"2019-02-25T12:00:06.648Z","comments":true,"path":"2016/10/01/python/data_model/","link":"","permalink":"https://lizsgh.github.io/2016/10/01/python/data_model/","excerpt":"","text":"Objects, values and typesAll data in a Python program is represented by objects or by relations between objects.Every object has an identity, a type and a value. Python 对象创建之后，identity 是不会变的，你可以将它看成该对象在内存中的地址。 Python 的 is 操作符比较的就是对象的 identity，== 比较的是 value。 Python 的内置函数 id() 可以获取一个整数，代表了该对象的 identity。CPython 和 IPython id() 获取的是内存的地址。 Python 对象的 type 也是不可以改变的，可以用内置函数 type() 获取对象的 type。 Python 对象根据 value 是否可以改变分为：可变对象(mutable)和不可变对象(immutable)。 常见的 mutable 对象：list, dict, bytearray, set, etc；immutable 对象：int, float, complex, str, tuple, bytes, frozeset, etc。 如果 immutable 对象中包含了 mutable 对象，该 mutable 对象的 value 是可变的。如： 123456789101112131415&gt;&gt;&gt; a = []&gt;&gt;&gt; id(a)140537664498648&gt;&gt;&gt; b = (a, 1)&gt;&gt;&gt; b([], 1)&gt;&gt;&gt; id(b)140537664384752&gt;&gt;&gt; a.append(0)&gt;&gt;&gt; b([0], 1)&gt;&gt;&gt; id(a)140537664498648&gt;&gt;&gt; id(b)140537664384752 For immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed. 新建的 immutable 对象可能是已经存在 imutable 对象的一个引用，新建的 mutable 对象是一个新的对象。 123456789101112&gt;&gt;&gt; a = &apos;abcde&apos;&gt;&gt;&gt; b = &apos;abcde&apos;&gt;&gt;&gt; id(a)140537664090832&gt;&gt;&gt; id(b)140537664090832&gt;&gt;&gt; c = []&gt;&gt;&gt; d = []&gt;&gt;&gt; id(c)140537664333368&gt;&gt;&gt; id(d)140537664498648 对于 int 类型的 imutable 对象，值在 -5 - 256 之间的时候，新建对象都是引用。 12345678910111213141516&gt;&gt;&gt; a = -6&gt;&gt;&gt; b = -6&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a = -5&gt;&gt;&gt; b = -5&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a = 256&gt;&gt;&gt; b = 256&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a = 257&gt;&gt;&gt; b = 257&gt;&gt;&gt; a is bFalse 注意：c = d = []，mutable 对象 c 和 d 是引用关系，指向同一个对象。 12345678&gt;&gt;&gt; c = d = []&gt;&gt;&gt; id(c)140537664175712&gt;&gt;&gt; id(d)140537664175712&gt;&gt;&gt; e = c&gt;&gt;&gt; id(e)140537664175712 Python Garbage Collection","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"},{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - Set","slug":"python/set","date":"2016-08-31T16:00:00.000Z","updated":"2019-02-25T15:03:09.518Z","comments":true,"path":"2016/09/01/python/set/","link":"","permalink":"https://lizsgh.github.io/2016/09/01/python/set/","excerpt":"","text":"set A set object is an unordered collection of distinct hashable objects. Like other collections, sets support x in set, len(set), and for x in set. Being an unordered collection, sets do not record element position or order of insertion. Accordingly, sets do not support indexing, slicing, or other sequence-like behavior. There are currently two built-in set types, set and frozenset. set([iterable]) - Return a set. The elements of a set must be hashable, bue the set type itself is mutable. The contents can be changed using methods like add() and remove(). Since set type is mutable, it has no hash value and cannot be used as either a dictionary key or an element of another set.123set((0, 1)) # set([0, 1])set(&apos;abc&apos;) # set([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])set([&apos;abc&apos;]) # set([&apos;abc&apos;]) Non-empty sets(not frozensets) also can be created by placing a comma-separated list of elements within braces, for example: {&#39;jack&#39;, &#39;lizs&#39;}, in addition to the set constructor. frozenset([iterable]) - Return a frozenset. The elements of frozenset must be hashable and the frozenset type is immutable and hashable. its contents cannot be altered after it is created, it can therefore be used as a dictionary key or as an element of another set. len(S) # set/frozenset Return the member of elements in set s (cardinality of s). x in s # set/frozenset x not in s # set/frozenset isdisjoint(other) # set/frozenset Return True if the set has no elements in common with other.Sets are disjoint if and only if their intersection is the empty set. issubset(other) set &lt;= other Test whether every element in set is in other. set &lt; other Test whether the set is a proper subset of other, that is set &lt;= other and set != other. issuperset(other) set &gt;= other Test whether every element in other is in the set. set &gt; other Test whether the set is a proper superset of other, that is, set &gt;= other and set != other. s.union(*other) set | other Return a new set with elements from the set and all others. s.intersection(*other) set &amp; other Return a new set with elements common to the set and all others. s.difference(*others) set - other Return a new set with elements in the set that are not in the others. s.symmetric_difference(other) set ^ other Return a new set with elements in either the set or other but not both. s.copy() Return a new set with a shallow copy of s. Note, the non-operator versions of union(), intersection(), difference(),and symmetric_difference(), issubset(), and issupperset() methods willaccept any iterable as an argument. In contrast, their operator based counterpartsrequire their arguments to be sets. Instance of set are compared to instances of frozenset based on their members.e.g. set(&#39;abc&#39;) == frozenset(&#39;abc&#39;) return True and so does set(&#39;abc&#39;) in set([frozenset(&#39;abc&#39;)]) Binary operations that mix set instances with frozenset return the type of first operand.e.g. frozenset(&#39;ab&#39;) | set(&#39;bc&#39;) returns an instance of frozenset The following table lists operations available for set that do not apply to immutable instances of frozenset: s.update(*other) set |= other Update the set, adding elements from all others. s.intersection_update(*other) set &amp;= other Update the set, keeping only elements found in it and all others. s.difference_update(*other) set -= other Update the set, removing the elements found in others. s.symmetric_difference_update(*other) set ^= other Update the set, keeping only elements found in either set, but not in both. s.add(elem) # set Add element elem to the set. s.discard(elem) Remove element elem from the set if it is present. s.remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. s.pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. s.clear() Remove all elements from the set. Note, the non-operator versions of update(), intersection_update(),difference_update(), symmetric_difference_update() methods will acceptany iterable as an argument.","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"},{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - Dictionary","slug":"python/dictionary","date":"2016-08-31T16:00:00.000Z","updated":"2019-02-25T12:06:33.811Z","comments":true,"path":"2016/09/01/python/dictionary/","link":"","permalink":"https://lizsgh.github.io/2016/09/01/python/dictionary/","excerpt":"","text":"class dict(object): dict() -&gt; new empty dictionary. dict(**kwargs) -&gt; new dictionary initialized with thename=value pairs in the keyword argument list. e.g. dict(a=1, b=2). dict(mapping, **kwargs) -&gt; new dictionary initialized from amapping object’s (key, value) pairs. e.g. {&#39;a&#39;: 1}, dict({&#39;a&#39;: 1}). dict(iterable, **kwargs) -&gt; new dictionary iterable object.Each item in the iterable must itself be an iterable with exactly two objects.e.g. dict([(&#39;a&#39;, 1)]), dict([(&#39;a&#39;, 1), (&#39;b&#39;, 2)]). If the key is duplicated, the value from the keyword argument replacesthe value from the positional argument.e.g. dict([(&#39;a&#39;, 0), (&#39;b&#39;, 2)], a=1, c=3) &lt;=&gt; {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3} len(d) del d[key] iter(d) Return an iterator over the keys of the dictionary.This is the shortcut for iter(d.keys())(Python3)/iterkeys()(Python2). Create d.copy() Return a shallow copy of the dictionary. d.fromkeys(seq[, value]) Create a new dictionary with keys from seq and all of values set to value.fromkeys() is a class method that return a new dictionary. value defaults to None. Delete d.clear() Remove all items from the dictionary. d.pop(key[, default]) If the key in the dictionary, remove it and return its value, else return default.If default is not given and key is not in the dictionary, a KeyError is raised. d.popitem() Remove and return a arbitrary (key, value) pair from dictionary.If the dictionary is empty, calling popitem() raises a KeyError. Update d.update([other]) Update the dictionary with the key/value pairs from other,overwriting the existing keys. Return None.update() accepts either another dictionary object or an iterable ofkey/value pairs (as tuple or other iterables of length two).If the keyword arguments are specified, the dictionary is then updatedwith those key/value pairs: d.update(red=1, blue=2). d.setdefault(key[, default]) If the key in the dictionary, return its value. If not, insert key witha value of default and return default, default defaults to None. Retrieve d.get(key[, default]) Return the value for key if key is in the dictionary, else default.If default is not given, it defaults to None, so that this method never raises a KeyError. Python3 d.keys() Return a new view of the dictionary’s keys. d.values() Return a new view of the dictionary’s values. d.items() Return a new view of the dictionary’s items ((key, value) pairs). Dictionaries compare equal if and only if they have the same (key, value) pairs.Order comparisons(‘&lt;’, ‘&lt;=’, ‘&gt;’, ‘&gt;=’) raise TypeError. Python2 d.keys() Return a copy of dictionary’s list of keys. d.values() Return a copy of dictionary’s list of values. d.items() Return a copy of dictionary’s list of (key, value) pairs. d.viewkeys() Return a new view of the dictionary’s keys. d.viewvalues() Return a new view of the dictionary’s values. d.viewitems() Return a new view of the dictionary’s items ((key, value) pairs). d.iterkeys() Return a iterator over the dictionary’s keys. d.itervalues() Return a iterator over the dictionary’s values. d.iteritems() Return a iterator over the dictionary’s (key, value) pairs. d.has_key(key) Test for the presence of key in the dictionary.has_key() is deprecated in favor of key in d. Dictionary view objectsThe objects returned by dict.keys(), dict.values() and dict.items()(Python2: dict.viewkeys(), dict.viewvalues() and dict.viewitems()) are view object. They provide a dynamic view on the dictionary’s entries, which means thatwhen dictionary change, the view reflects these changes.123456# Python3d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3, &apos;d&apos;: 4&#125;keys = d.keys()print(keys) # [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]del d[&apos;d&apos;]print(keys) # [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] len(dictview) Return the number of entries in the dictionary. iter(dictview) Return an iterator over the keys, values or items(represented as tuples of (key, value)) in the dictionary. Iterating views while adding or deleting entries in the dictionary mayraise a RuntimeError or fail to iterate over all entries. x in dictview Return True if x is in the underlying dictionary’s keys, values oritems (in the latter case, x should be a (key, value) tuple). Keys and items views are set-like since their entries are unique and hashable.Values views are not treated as set-like since the entries are generally not unique.For set-like views, all of the operations defined for the set are available(e.g. &amp;, |, -, ^).","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"},{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - String","slug":"python/string","date":"2016-08-31T16:00:00.000Z","updated":"2019-02-25T14:30:17.107Z","comments":true,"path":"2016/09/01/python/string/","link":"","permalink":"https://lizsgh.github.io/2016/09/01/python/string/","excerpt":"","text":"str Strings are immutable sequences of Unicode code points. String literals that are part of single expression and have only whitespacebetween them will be implicitly converted to a single string literal.That is, (&#39;hello&#39; &#39; &#39; &#39;world&#39;) == &#39;hello world&#39;. str(object=&#39;&#39;)str(object=b&#39;&#39;, encoding=&#39;utf-8&#39;, errors=&#39;strict&#39;) # Python3 object, if object is not provided, returns the empty string. str.capitalize() str.center(width[, fillchar]) str.count(sub[, start[, end]]) str.decode([encoding[, errors]]) str.encode([encoding[, errors]]) str.endswith(suffix[, start[, end]]) str.expandtabs([tabsize]) str.find(str[, start[, end]]) str.format(*args, **kwargs) str.index(sub[, start[, end]]) str.isalnum() str.isalpha() str.isdigit() str.islower() str.isspace() str.istitle() str.isupper() str.join(iterable) str.ljust(width[, fillchar]) str.lower() str.lstrip([chars]) str.partition(sep) str.replace(old, new[, count]) str.rfind(sub[, start[, end]]) str.rindex(sub[, start[, end]]) str.rjust(width[, fillchar]) str.rpartition(sep) str.rsplit([sep[, maxsplit]]) str.rstrip([chars]) str.split([sep[, maxsplit]]) str.splitlines([keepends]) str.startswith(prefix[, start[, end]]) str.strip([chars]) str.swapcase() str.title() str.maketrans(x[, y[, x]]) str.translate(table[, deletechars]) str.upper() str.zfill(with)","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"},{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - Tuple","slug":"python/tuple","date":"2016-08-31T16:00:00.000Z","updated":"2019-02-25T15:11:15.420Z","comments":true,"path":"2016/09/01/python/tuple/","link":"","permalink":"https://lizsgh.github.io/2016/09/01/python/tuple/","excerpt":"","text":"tuple Tuples are immutable sequences. tuple([iterable]) The constructor builds a tuple whose items are the same andin the same order as iterable‘s items. iterable may be a sequence,a container that supports iteration, or an iterable object. If iterable is already a tuple, it is returned unchanged. Empty tuple: (), tuple() Singleton tuple: &#39;a&#39;,, (‘a’,) Multiple elements tuple: &#39;a&#39;, 0, (&#39;a&#39;, 0), tuple(iterable) t.count(x) return number of occurrences of x, if no x in the tuplea 0 value will be returned. t.index(x, start=None, stop=None) Return first index of x. Raises ValueError if the x is not present. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class tuple(object): &quot;&quot;&quot; tuple() -&gt; empty tuple tuple(iterable) -&gt; tuple initialized from iterable&apos;s items If the argument is a tuple, the return value is the same object. &quot;&quot;&quot; def count(self, value): # real signature unknown; restored from __doc__ &quot;&quot;&quot; T.count(value) -&gt; integer -- return number of occurrences of value &quot;&quot;&quot; return 0 def index(self, value, start=None, stop=None): # real signature unknown; restored from __doc__ &quot;&quot;&quot; T.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present. &quot;&quot;&quot; return 0 def __add__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return self+value. &quot;&quot;&quot; pass def __contains__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return key in self. &quot;&quot;&quot; pass def __eq__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return self==value. &quot;&quot;&quot; pass def __getattribute__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return getattr(self, name). &quot;&quot;&quot; pass def __getitem__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return self[key]. &quot;&quot;&quot; pass def __getnewargs__(self, *args, **kwargs): # real signature unknown pass def __ge__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return self&gt;=value. &quot;&quot;&quot; pass def __gt__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return self&gt;value. &quot;&quot;&quot; pass def __hash__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return hash(self). &quot;&quot;&quot; pass def __init__(self, seq=()): # known special case of tuple.__init__ &quot;&quot;&quot; tuple() -&gt; empty tuple tuple(iterable) -&gt; tuple initialized from iterable&apos;s items If the argument is a tuple, the return value is the same object. # (copied from class doc) &quot;&quot;&quot; pass def __iter__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Implement iter(self). &quot;&quot;&quot; pass def __len__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return len(self). &quot;&quot;&quot; pass def __le__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return self&lt;=value. &quot;&quot;&quot; pass def __lt__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return self&lt;value. &quot;&quot;&quot; pass def __mul__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return self*value.n &quot;&quot;&quot; pass @staticmethod # known case of __new__ def __new__(*args, **kwargs): # real signature unknown &quot;&quot;&quot; Create and return a new object. See help(type) for accurate signature. &quot;&quot;&quot; pass def __ne__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return self!=value. &quot;&quot;&quot; pass def __repr__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return repr(self). &quot;&quot;&quot; pass def __rmul__(self, *args, **kwargs): # real signature unknown &quot;&quot;&quot; Return self*value. &quot;&quot;&quot; pass","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"},{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - List","slug":"python/list","date":"2016-08-31T16:00:00.000Z","updated":"2019-02-25T14:47:07.088Z","comments":true,"path":"2016/09/01/python/list/","link":"","permalink":"https://lizsgh.github.io/2016/09/01/python/list/","excerpt":"","text":"list list() new empty list list(iterable) new list initialized from iterable’s items The constructor builds a list whose items are the same andin the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration,or an iterator object. If iterable is already a list, a copy is made and returned,similar to iterable[:]. e.g. list(&#39;abc&#39;) =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],list(range(2)) =&gt; [0, 1], list([0, 1]) =&gt; [0, 1]. Create l.copy() # New in Python3 Return a shallow copy of l. l.append(p_object) Append object to the end of l. l.insert(index, p_object) Insert object before index. l.extend(iterable) Extend list by appending elements from iterable. Delete l.pop([index]) Remove and return item at index (default last).Raises IndexError if list is empty or index is out of range. l.remove(value) Remove first occurrence of value.Raises ValueError if the value is not present. l.clear() # New in Python3 Return a shallow copy of l. Retrieve l.count(value) Return number of occurrences of value. l.index(value, [start[, stop]]) Return first index of value. Update l.reverse() Reverse IN PLACE. e.g. 1234l = [0, 1, 2]l.reverse() # No list return, but reverse in placeprint(l)[2, 1, 0] l.sort([key, reverse]) Sorts the list l in place. sort() accepts two arguments that can only be passed by keyword (keyword-only arguments). Error: l.sort(lambda x: x == 2), l.sort(lambda x: x == 2, True) True: l.sort(key=lambda x: x == 2), l.sort(key=lambda x: x == 2, reverse=True) key, specifies a function of one argument that is used to extract acomparision key from each list element (e.g. key=str.lower). The smaller of the key function return value, the corresponding item is more forward.And the True indicate int 1, False indicate int 0.1234567l = [5, 1, 2, 4, 0]l.sort(key=lambda x: x == 2)print(l)[5, 1, 4, 0, 2] # 2 =&gt; True(1); others =&gt; False(0)l.sort(key=lambda x: x)print(l)[0, 1, 2, 4, 5] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156class list(object): &quot;&quot;&quot; list() -&gt; new empty list list(iterable) -&gt; new list initialized from iterable&apos;s items &quot;&quot;&quot; def append(self, p_object): &quot;&quot;&quot; L.append(object) -&gt; None -- append object to end &quot;&quot;&quot; pass def clear(self): # New in Python3 &quot;&quot;&quot; L.clear() -&gt; None -- remove all items from L &quot;&quot;&quot; pass def copy(self): # New in Python3 &quot;&quot;&quot; L.copy() -&gt; list -- a shallow copy of L &quot;&quot;&quot; return [] def count(self, value): &quot;&quot;&quot; L.count(value) -&gt; integer -- return number of occurrences of value &quot;&quot;&quot; return 0 def extend(self, iterable): &quot;&quot;&quot; L.extend(iterable) -&gt; None -- extend list by appending elements from the iterable &quot;&quot;&quot; pass def index(self, value, start=None, stop=None): &quot;&quot;&quot; L.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present. &quot;&quot;&quot; return 0 def insert(self, index, p_object): &quot;&quot;&quot; L.insert(index, object) -- insert object before index &quot;&quot;&quot; pass def pop(self, index=None): &quot;&quot;&quot; L.pop([index]) -&gt; item -- remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. &quot;&quot;&quot; pass def remove(self, value): &quot;&quot;&quot; L.remove(value) -&gt; None -- remove first occurrence of value. Raises ValueError if the value is not present. &quot;&quot;&quot; pass def reverse(self): &quot;&quot;&quot; L.reverse() -- reverse *IN PLACE* &quot;&quot;&quot; pass def sort(self, key=None, reverse=False): &quot;&quot;&quot; L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE* &quot;&quot;&quot; pass def __add__(self, *args, **kwargs): &quot;&quot;&quot; Return self+value. &quot;&quot;&quot; pass def __contains__(self, *args, **kwargs): &quot;&quot;&quot; Return key in self. &quot;&quot;&quot; pass def __delitem__(self, *args, **kwargs): &quot;&quot;&quot; Delete self[key]. &quot;&quot;&quot; pass def __eq__(self, *args, **kwargs): &quot;&quot;&quot; Return self==value. &quot;&quot;&quot; pass def __getattribute__(self, *args, **kwargs): &quot;&quot;&quot; Return getattr(self, name). &quot;&quot;&quot; pass def __getitem__(self, y): &quot;&quot;&quot; x.__getitem__(y) &lt;==&gt; x[y] &quot;&quot;&quot; pass def __ge__(self, *args, **kwargs): &quot;&quot;&quot; Return self&gt;=value. &quot;&quot;&quot; pass def __gt__(self, *args, **kwargs): &quot;&quot;&quot; Return self&gt;value. &quot;&quot;&quot; pass def __iadd__(self, *args, **kwargs): &quot;&quot;&quot; Implement self+=value. &quot;&quot;&quot; pass def __imul__(self, *args, **kwargs): &quot;&quot;&quot; Implement self*=value. &quot;&quot;&quot; pass def __init__(self, seq=()): &quot;&quot;&quot; list() -&gt; new empty list list(iterable) -&gt; new list initialized from iterable&apos;s items # (copied from class doc) &quot;&quot;&quot; pass def __iter__(self, *args, **kwargs): &quot;&quot;&quot; Implement iter(self). &quot;&quot;&quot; pass def __len__(self, *args, **kwargs): &quot;&quot;&quot; Return len(self). &quot;&quot;&quot; pass def __le__(self, *args, **kwargs): &quot;&quot;&quot; Return self&lt;=value. &quot;&quot;&quot; pass def __lt__(self, *args, **kwargs): &quot;&quot;&quot; Return self&lt;value. &quot;&quot;&quot; pass def __mul__(self, *args, **kwargs): &quot;&quot;&quot; Return self*value.n &quot;&quot;&quot; pass @staticmethod def __new__(*args, **kwargs): &quot;&quot;&quot; Create and return a new object. See help(type) for accurate signature. &quot;&quot;&quot; pass def __ne__(self, *args, **kwargs): &quot;&quot;&quot; Return self!=value. &quot;&quot;&quot; pass def __repr__(self, *args, **kwargs): &quot;&quot;&quot; Return repr(self). &quot;&quot;&quot; pass def __reversed__(self): &quot;&quot;&quot; L.__reversed__() -- return a reverse iterator over the list &quot;&quot;&quot; pass def __rmul__(self, *args, **kwargs): &quot;&quot;&quot; Return self*value. &quot;&quot;&quot; pass def __setitem__(self, *args, **kwargs): &quot;&quot;&quot; Set self[key] to value. &quot;&quot;&quot; pass def __sizeof__(self): &quot;&quot;&quot; L.__sizeof__() -- size of L in memory, in bytes &quot;&quot;&quot; pass __hash__ = None","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"},{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"MySQL 字符集与校对规则","slug":"mysql/character_set","date":"2016-08-20T16:00:00.000Z","updated":"2019-02-26T08:53:44.584Z","comments":true,"path":"2016/08/21/mysql/character_set/","link":"","permalink":"https://lizsgh.github.io/2016/08/21/mysql/character_set/","excerpt":"","text":"字符集 CHARACTE SET 字符（character）是各种文字和符号的总称，包括各国文字、标点符号、图形符号、数字等。 字符集（character set）是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同。 常见字符集：ASCII、GBK、UTF8、Unicode 等等。 MySQL 字符集转换过程 MySQL Server 收到请求时，将请求数据从 character_set_client 转换为 character_set_connection 然后，character_set_connection 转换为 MySQL 内部操作字符集。MySQL 内部操作字符集： 如果 column 指定了字符集，则使用 column 指定的字符集 如果 column 没有指定字符集，则使用 table 的字符集 如果 table 也没有指定字符集，则使用 database 的字符集 如果 database 也没有指定字符集，则使用 character_set_server 的值 最后，将操作结果从内部操作字符集转换为 character_set_results。 常见问题 乱码 当 character_set_client 与事实不符的时候。比如，character_set_client 明明是 utf8 的，但是，将它当成 GBK 去转换。 当 character_set_results 与客户端页面的字符集不一致的时候。 当数据保存到数据库之后，改变了内部操作字符集或者 character_set_connection。比如： 数据表字符集设置为 utf8，插入时使用 MySQL 的默认设置（character_set_client、character_set_connectiong 和 character_set_results 都为 latin1）。插入之后，改变 character_set_connection 为 utf8. 插入时，转换过程：latin1 -&gt; latin1 -&gt; utf8。3 字节的 latin1 转换为 6 字节的utf8。 查询时，转换过程：utf8 -&gt; utf8 -&gt; latin1。6 字节的 utf8 原封不动返回。因此，肯定是会乱码的。 所以，如果插入数据到查询数据过程中没有更改过 MySQL 字符集，但是出现了乱码，一般情况都是页面字符集和 character_set_results 不一致造成的。 数据丢失字符集也有大小的，当 character_set_client &lt; character_set connection 或者 character_set_connectino &lt; 内部字符集(数据保存的字符集格式) 时，字符转换过程中，除了乱码，还可能会出现字符丢失。 字符集乱码还可以调回来，但是数据丢失是找不回来的。 MySQL 字符集设置 column 1234CREATE TABLE `member` ( `name` varchar CHARACTER SET utf8);ALTER TABLE `member` CHANGE `name` varchar(25) CHARACTER SET utf8; table 1234CREATE TABLE `member` ( ...) DEFAULT CHARSET utf8;ALTER TABLE `member` DEFAULT CHARSET utf8; CHARSET 和 CHARACTER SET 一样，CHARSET 是简写。 database 1set character_set_database = utf8; character_set_server 1set character_set_server = utf8; character_set_connection 1set character_set_contion = utf8; character_set_results 1set character_set_results = utf8; 如果 character_set_client、character_set_connection和character_set_results 都一样时，可以用 set names 语句来代替：1set names utf8; 校对规则/校对集 COLLATE 校对规则，字符集内用于比较字符的规则。 一个字符集可以有多个校对规则。如，字符集 utf8 的校对规则：utf8_general_ci、utf8_bin 等等。 不同的校对规则，字符集内的字符排序不一样。如，utf8 字符集用 utf8_general_ci 校对规则，A 排在 b 前面。但是如果用 utf8_bin 校对规则， b 会排在 A 前面。 每个字符集有一个默认校对规则。如，utf8 默认校对规则为 utf8_general_ci。 校对规则命名约定：以字符集名称开头，以 ci(大小写不敏感)、cs(大小写敏感)、或 bin(二元) 结尾。 MySQL 校对规则设置 column 1234CREATE TABLE `member` ( `name` varchar(25) CHARACTER SET utf8 COLLATE utf8_general_ci);ALTER TABLE `member` CHANGE COLUMN `name` CHARACTER SET utf8 COLLATE utf8_general_ci; table 1234CREATE TABLE `member` ( ...) DEFAULT CHARSET utf8 COLLATE utf8_general_ci;ALTER TABLE `member` DEFAULT CHARSET utf8 COLLATE utf8_general_ci;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://lizsgh.github.io/tags/mysql/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}]},{"title":"Ubuntu deploy OpenVPN","slug":"linux/ubuntu_deploy_openvpn","date":"2016-07-13T16:00:00.000Z","updated":"2019-02-26T13:16:10.771Z","comments":true,"path":"2016/07/14/linux/ubuntu_deploy_openvpn/","link":"","permalink":"https://lizsgh.github.io/2016/07/14/linux/ubuntu_deploy_openvpn/","excerpt":"","text":"参照 OpenVPN文档 大概流程： 安装 OpenVPN 生成 PKI：CA 证书和密钥、服务器端证书和密钥、客户端证书和密钥、迪菲·赫尔曼密钥 服务器端配置 客户端配置 OpenVPN Server安装 OpenVPN1apt-get install openvpn easy-rsa OpenVPN PKI构建 OpenVPN 配置的第一步是建立一个公钥基础设施（PKI）。PKI 包括： 一个主证书颁发机构（CA）的证书（即公钥）和密钥，用于签名服务器和客户端的证书（English：a master Certificate Authority (CA) certificate and key which is used to sign each of the server and client certificates.） OpenVPN Server 证书（公钥）和密钥 OpenVPN Client 证书（公钥）和密钥 1、CA 设置，生成证书和密钥 用安装的 easy-rsa 包来制作 CA/服务器端/客户端的证书和密钥 1cp -r /usr/share/easy-rsa/ /etc/openvpn/ 设置默认的基本参数： /etc/openvpn/easy-rsa/vars 12345678export KEY_COUNTRY=&quot;CN&quot;export KEY_PROVINCE=&quot;GuangDong&quot;export KEY_CITY=&quot;FoShan&quot;export KEY_ORG=&quot;easecloud&quot; # organization 组织export KEY_EMAIL=&quot;*@easecloud.cn&quot;export KEY_OU=&quot;easecloud&quot; # organization unit 单位export KEY_NAME=&quot;easecloudVPN&quot;export KEY_CN=&quot;ecVPN&quot; # common name for all keys 常用名 生成 CA 证书和密钥 123source vars./clean-all./build-ca # 生成 CA 证书和密钥 执行 ./build-ca时，可以一直回车，默认使用 vars 的设置。执行完之后，就会生成 CA 证书（keys/ca.crt）和密钥（keys/ca.key）。 运行 ./build-ca 时可能报错： 错误一:error on line 198 of /etc/openvpn/easy-rsa/openssl-1.0.0.cnf139749463725728:error:0E065068:configuration file routines:STR_COPY:variable has no value:conf_def.c:618:line 198 错误二:error on line 220 of /etc/openvpn/easy-rsa/openssl-1.0.0.cnf140566456841888:error:0E065068:configuration file routines:STR_COPY:variable has no value:conf_def.c:618:line 220 解决：分别注释到 openssl-1.0.0.cnf 文件中 198 和 220 行的内容 subjectAltName=$ENV::KEY_ALTNAMES 2、服务器端证书和密钥，迪菲·赫尔曼密钥 生成服务器端的证书和密钥 1./build-key-server myservername myservername：服务器证书名称，如：easecloudVPN 执行：一直回车，直到 Sign the certificate?[y/n]y，1 out of 1 certificate requests certified, commit? [y/n]y 执行完之后，我们就可以得到服务器证书（keys/easecloudVPN.crt）和密钥（keys/easecloudVPN.key）。 同时，为 OpenVPN 服务器生成迪菲·赫尔曼密钥 1./build-dh 执行完 ./build-dh 之后，会根据 /easy-ras/vars 的 KEY_SIZE 参数来生成相应的 Diffie Hellman 参数文件（keys/dh-2048.pem） 迪菲·赫尔曼密钥交换（Diffie–Hellman key exchange，简称“D–H”） 是一种安全协议。它可以让双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。 3、客户端证书和密钥生成客户端证书。一般，不同的客户端各自创建自己的客户端证书和密钥。12cd /etc/openvpn/easy-rsa/./build-key clientName clientName：客户端证书名称，如：lizs 执行：一直回车，直到 Sign the certificate?[y/n]y，1 out of 1 certificate requests certified, commit? [y/n]y 执行完之后，我们就可以得到客户端证书（keys/lizs.crt）和密钥（keys/lizs.key） 先将以下证书拷贝到 OpenVPN Client 所在环境，等下配置客户端 OpenVPN 要用到 ca.crt lizs.crt lizs.key 服务器配置 先将生成的相关证书复制到 /etc/openvpn/ 12cd keys/cp easecloudVPN.crt easecloudVPN.key ca.crt dh2048.pem /etc/openvpn/ 安装了 OpenVPN 之后会自动带有一些服务器端和客户端的简单配置的例子。 123ls -l /usr/share/doc/openvpn/examples/sample-config-files/-rw-r--r-- 1 root root 3427 Dec 2 2014 client.conf # 客户端配置-rw-r--r-- 1 root root 4141 Dec 2 2014 server.conf.gz # 服务器端配置 服务器端配置，我们可以使用例子中的配置 server.conf.gz，将它复制到 /etc/openvpn/ 目录下解压就可以使用了 12cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz /etc/openvpn/gunzip /etc/openvpn/server.conf.gz 接下来，编辑 server.conf 1234ca ca.crt # 刚生成的 CA 证书cert easecloudVPN.crt # 刚生成的服务器端证书key easecloudVPN.key # 刚生成的服务器端密钥dh dh2048.pem # 刚生成的 Diffie Hellman 参数文件 编辑 sysctl 配置文件 /etc/sysctl.conf 并且重新加载 12#net.ipv4.ip_forward=1 # defaultnet.ipv4.ip_forward=1 # we just need to uncomment it 重新加载 sysctl 1sysctl -p /etc/sysctl.conf 开启服务器端 OpenVPN 1service openvpn start 检查 OpenVPN 是否创建了一个 tun0 接口（可以查看 server.conf 配置文件中的 dev 参数） 12345678$ ifconfig tun0tun0 Link encap:UNSPEC HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 inet addr:10.8.0.1 P-t-P:10.8.0.2 Mask:255.255.255.255 UP POINTOPOINT RUNNING NOARP MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:100 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) OpenVPN Client安装 OpenVPN1sudo apt-get install openvpn 客户端配置 先将服务器端生成的相关证书文件复制到 /etc/openvpn/ 目录下 ca.crt：CA 证书 lizs.crt：客户端证书 lizs.key：客户端密钥 客户端配置也可以使用 OpenVPN 自带的客户端配置例子 client.conf，将其复制到 /etc/openvpn 1sudo cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/ 编辑客户端配置文件 /etc/openvpn/client.conf: 1234remote 123.123.123.123 1194ca ca.crt # 服务器端生成的 CA 证书cert lizs.crt # 客户端证书key lizs.key # 客户端密钥 其中123.123.123.123为 OpenVPN Server 所在服务器的 IP 或域名。 开启 OpenVPN Client 1service openvpn@client start 检查 OpenVPN 是否创建了一个 tun0 接口（可以查看 server.conf 配置文件中的 dev 参数） 1ifconfig tun0 如果没有成功开启，重启服务器端的 OpenVPN 和 客户端的 OpenVPN 试试看。 附 windows openvpn client 安装 OpenVPN GUI 首先，将服务器生成的相关证书复制到安装目录的 config 文件夹下面。 ca.crt：CA 证书 lizs.crt：客户端证书 lizs.key：客户端密钥 修改配置文件。同样，使用自带的配置例子 sample-config/client.ovpn。将其复制到 config 目录下，然后编辑： 12345dev tun # 和服务器的保持一致remote 123.123.123.123 1194ca ca.crt # 服务器端生成的 CA 证书cert lizs.crt # 客户端证书key lizs.key # 客户端密钥 其中123.123.123.123为 OpenVPN Server 所在服务器的 IP 或域名。 最后以管理员身份运行 OpenVPN。启动之后，右键菜单栏 OpenVPN 图标，connect。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Python - Class","slug":"python/class","date":"2016-06-01T16:00:00.000Z","updated":"2019-02-26T12:20:04.931Z","comments":true,"path":"2016/06/02/python/class/","link":"","permalink":"https://lizsgh.github.io/2016/06/02/python/class/","excerpt":"","text":"类定义 类的定义就像函数的定义，要先执行才能生效。 类定义之后，就会创建一个新的命名空间， 作为局部作用域。所有的赋值和函数名会成为命名空间的局部变量。 类定义正常退出时，一个类对象就创建了。 Python 类中的方法的第一个参数通常是self，这是一个约定。如果不遵循这个约定，对其他 Python 程序员而言你的代码可读性就会变差，而且有些浏览器程序也可能遵循此约定编写的。self 是类方法的第一个参数，它就是类的实例对象自己，当调用方法时：A().func() 等同于 A().func(A)然后，类中的方法就可以通过 self 来调用该方法外面的方法或者变量了。这和 C++ 中隐式的 this 类似。 类对象类对象支持两种操作： Attribute References and Instantiation (属性引用和实例化)类的 Attribute References 使用 Python 中标准的属性引用语法：obj.name。类的 Instantiation 使用函数的符号。可以假设类对象是一个不带参数的函数，该函数返回这个类的一个新实例。x = A()123456789101112131415161718192021&gt;&gt;&gt; class A : &apos;&apos;&apos;A simple example class&apos;&apos;&apos; a = 0 def func(self) : b = self.a + 1 print(b)&gt;&gt;&gt; A.a0&gt;&gt;&gt; A().a0&gt;&gt;&gt; A.func # 直接引用类 A 中的函数 func，注意，如果类 A 不需要传参，这样就是实例化之后的引用了。&lt;function A.func at 0x000000D5EB96E8C8&gt;&gt;&gt;&gt; A().func # 实例化类 A 之后，引用函数 func&lt;bound method A.func of &lt;__main__.A object at 0x000000D5EB9716D8&gt;&gt;&gt;&gt;&gt; A().func() # 实例化类 A 之后，调用函数 func1&gt;&gt;&gt; A.__doc__&apos;A simple example class&apos;&gt;&gt;&gt; A().__doc__&apos;A simple example class&apos; 实例化操作将创建一个空的对象。很多类希望创建的对象可以自定义一个初始状态，因此，可以在类中定义一个名为 __init__() 的特殊方法。类似其它语言的构造函数__construct()。1234567891011121314&gt;&gt;&gt; class B : a = 0 def __init__(self, m) : self.a = m def func(self) : b = self.a print(b)&gt;&gt;&gt; B.a0&gt;&gt;&gt; B().func()TypeError: __init__() missing 1 required positional argument: &apos;m&apos;&gt;&gt;&gt; B(1).func()1 Class Variable and Instance Variable (类变量和实例变量)Class Variable shared by all Instances, Instance Variable unique to each Instance.12345678910111213141516&gt;&gt;&gt; class A : a = [0] def __init__(self, m) : self.a.append(m) # &apos;a&apos; 为 Class Variable def func(self) : b = self.a # &apos;a&apos; 为 Class Variable print(b)&gt;&gt;&gt; B = A(1)&gt;&gt;&gt; B.func()[0, 1]&gt;&gt;&gt; C = A(2)&gt;&gt;&gt; C.func()[0, 1, 2]&gt;&gt;&gt; B.func()[0, 1, 2] __init__() 和 func() 里面的 a 都是引用了函数外面的 a，所以都是 Class Variable，对所有 Instance 都是共享的。 123456789101112131415161718&gt;&gt;&gt; class A : a = 0 def __init__(self, m) : self.a = m # &apos;a&apos; 为 Instance Variable def func(self) : b = self.a print(b)&gt;&gt;&gt; B = A(1)&gt;&gt;&gt; B.func()1&gt;&gt;&gt; C = A(2)&gt;&gt;&gt; C.func()2&gt;&gt;&gt; B.func()1&gt;&gt;&gt; A.a, B.a, C.a(0, 1, 2) __init__() 中对 a 进行赋值操作，就相当于创建了一个局部的 a (B.a、C.a)。所以，在__init__() 里面对 a 的操作是与外面 a 无关的。类中的 __init__() 函数用于创建实例化类的变量 a (B.a、C.a)，因此，func() 函数中就会用实例化对象自己创建的 a。当实例化对象没有从新定义自己的 a 的时候，就会用继承的共享的 a。如果想要在初始化的时候改变 Class Variable a，可以这样：12345678910111213&gt;&gt;&gt; class A : a = 0 def __init__(self, m) : A.a = m # 直接指定 &apos;a&apos; 的类名 def func(self) : b = self.a # 因为实例化类中没有创建新的 &apos;a&apos;，所以 &apos;a&apos; 是继承类 A 的 Class Variable print(b)&gt;&gt;&gt; B = A(1)&gt;&gt;&gt; B.func()1&gt;&gt;&gt; A.a, B.a(1, 1)","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Django tutorial 1","slug":"python/django_tutorial_1","date":"2016-05-31T16:00:00.000Z","updated":"2019-02-26T12:22:21.675Z","comments":true,"path":"2016/06/01/python/django_tutorial_1/","link":"","permalink":"https://lizsgh.github.io/2016/06/01/python/django_tutorial_1/","excerpt":"","text":"Install Django1pip install Django 查看是否安装成功：1python -m django --version Creating a project1django-admin startproject mysite 运行命令将会在当前目录下创建名为mysite的项目，项目名称应避免使用 Python 内置的模块名称或 Django 组件名称，如，django, test等。mysite项目结构如下：1234567mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py mysite：外层mysite目录，只是项目的外壳容器，可以随便重命名，不影响 Django 项目；内层mysite，名称不能更改，因为，当导入这个目录下的内容的时候，会用到这个包名 (如import mysite.urls)。 manage.py：Django 项目管理的命令行工具。详细查看django-admin and manage.py。 mysite/__init__.py：声明 Python 包的空文件。 mysite/settings.py：项目配置文件。详细查看Django settings。 mysite/urls.py：配置项目 URLs 的文件。详细查看URL dispatcher。 mysite/wsgi.py：WSGI 服务器入口文件。 The development server在项目的根目录，即外层mysite目录下，执行：1python manage.py runserver 可以看到：1234567891011Performing system checks...System check identified no issues (0 silenced).You have 15 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.Run 'python manage.py migrate' to apply them.December 06, 2018 - 16:39:26Django version 2.1.3, using settings 'mysite.settings'Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. 现在已经启动了 Django 自带的轻量级的服务器，可以通过地址http://127.0.0.1:8000/来访问。(注意，这个服务器只适合平时开发环境使用。) Changing the port默认情况下，runserver命令使用8000端口。但是，你可以启动服务器的时候指定端口： 1python manage.py runserver 8080 # http://127.0.0.1:8080 Changing the address同样可以指定服务器的访问地址，不过指定地址的时候一定要同时指定端口，如： 1python manage.py runserver 0:8000 # 0.0.0.:8000 0 为地址0.0.0.0的缩写，如果只指定地址会出错，如python manage.py runserver 127.0.0.1。 Creating app项目中的功能需求可以合理地拆分成一个个功能性的 app，同一个 app 可以重用到不同的项目中，一个项目可以包含多个 app。Django 提供了startapp命令创建 Django 项目的基本 app。Django 项目的 app 可以放在 Python 路径的任何地方，不过最好放在项目的根目录下 (即外层mysite目录下) 这样不同 app 之间或者和项目包 (内层mysite) 之间导入的时候，就可以作为高层模块直接导入。也就是说，可以直接import app_name或import mysite。 在项目根目录下 (外层mysite)，执行：1python manage.py startapp polls 成功执行完之后，会在当前目录下生成一个名为polls的 app 包：123456789polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py Write your first view接着编写 polls app 的第一个视图页面。在polls/views.py中编辑：12345from django.http import HttpResponsedef index(request): return HttpResponse(\"Hello, world. You're at the polls index.\") 添加视图到相应 URL，添加 app 的 URL 配置文件polls/urls.py:1234567from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),] 再将 polls 的 URL 配置添加到项目的 URL (mysite/urls.py)中去：12345678from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('polls/', include('polls.urls')), path('admin/', admin.site.urls),] 现在，开启服务器python manage.py runserver，然后访问http://localhost:8000/polls/就可以看到上面编辑的视图内容了。","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://lizsgh.github.io/tags/django/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - slice","slug":"python/slice","date":"2016-04-30T16:00:00.000Z","updated":"2019-02-26T12:28:02.936Z","comments":true,"path":"2016/05/01/python/slice/","link":"","permalink":"https://lizsgh.github.io/2016/05/01/python/slice/","excerpt":"","text":"List Slice： list[start:end:step] start，切片的开始位置，包括 start，注意列表是从索引 0 开始的。 end，切片的结束位置，不包括 end。 step，切片的步长。默认为 1。 1&gt;&gt;&gt; li = [0, 1, 2, 3, 4, 5] start 为空，则默认为 0；end 为空，则默认切片到列表的最后，即 len(li) + 1： 123456&gt;&gt;&gt; li[:][0, 1, 2, 3, 4, 5]&gt;&gt;&gt; li[:3][0, 1, 2]&gt;&gt;&gt; li[3:][3, 4, 5] step 不能够为 0. 1234&gt;&gt;&gt; li[::0]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: slice step cannot be zero 当 step &gt; 0 时，切片是从从左到右进行的。所以，在没有超出边界时，start 要在 end 的左边，否则返回值为空 12345678910&gt;&gt;&gt; li[4:0][]&gt;&gt;&gt; li[0:-1][0, 1, 2, 3, 4]&gt;&gt;&gt; li[:-5][0]&gt;&gt;&gt; li[-6:1][0]&gt;&gt;&gt; li[-6:5:2][0, 2, 4] 当 step &lt; 0 时，切片是从右到左进行的。所以，在没有超出边界时，start 要在 end 的右边，否则返值为空。 123456&gt;&gt;&gt; li[0:4:-1][]&gt;&gt;&gt; li[5:0:-1] # exclude end[5, 4, 3, 2, 1]&gt;&gt;&gt; li[::-1] # 经典应用：反转字符串[5, 4, 3, 2, 1, 0] 注意：无论 step &gt; 0，还是 step &lt; 0，切片都是包含 start，而不包含 end。 边界问题： start 超出左边界，则从索引 0 开始 12&gt;&gt;&gt; li[-7:][0, 1, 2, 3, 4, 5] end 超出右边界，则切片到最后结束，即len(li) 12&gt;&gt;&gt; li[:100][0, 1, 2, 3, 4, 5] start 和 end，一个超出左边界一个超出右边界要看 step 的值正负来判断 12345678&gt;&gt;&gt; li[-10:10][0, 1, 2, 3, 4, 5]&gt;&gt;&gt; li[10:-10][]&gt;&gt;&gt; li[-10:10:-1][]&gt;&gt;&gt; li[10:-10:-1][5, 4, 3, 2, 1, 0] start 和 end 都超出了左边界或者都超出了右边界，则为空 1234&gt;&gt;&gt; li[-10:-20][]&gt;&gt;&gt; li[10:20][]","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - Scope and namespace","slug":"python/scope_and_namespace","date":"2016-04-30T16:00:00.000Z","updated":"2019-02-26T12:32:02.641Z","comments":true,"path":"2016/05/01/python/scope_and_namespace/","link":"","permalink":"https://lizsgh.github.io/2016/05/01/python/scope_and_namespace/","excerpt":"","text":"NamespaceA namespace ia a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries.命名空间是从名称到对象的映射。当前，命名空间主要通过 Python 字典来实现。Examples of namespaces are: The set of built-in names (containing functions such as abs(), and built-in exception names)内置名称集(包括内置函数，如 abs()，和内置异常的名称) The global names in a module模块中的全局名称 The local names in a function invocation函数调用中的局部名称 and so on. 不同命名空间的名称没有任何关系。例如，两个不同模块都可以定义函数 func()，而不会产生混淆。只要在使用的时候加上模块名作为前缀引用它们就可以了。 module.func，module 是一个模块对象，func 是这个模块的一部分内容(function)，我们称之为 属性。也就是说，func 是 module 的一个属性。 各个命名空间创建的时间是不一样的，而且有着不同的生命周期： 内置名称的命名空间在 Python 解析器启动时创建，永远不会被删除 模块的全局命名空间在读入模块定义时创建。通常情况下，模块命名空间也会一直保存到解析器退出。 函数的局部命名空间在函数调用时创建，在函数返回或者引发了一个函数内部没有处理的异常时删除。 Scope作用域 是 Python 程序中可以直接访问命名空间的代码区域。直接访问，是指用没有前缀的引用在命名空间中找到相应的名称。如，abs(-1)，abs属于直接访问。属性访问，是指需要用点分.模式来指定属性的访问。如，module.func()。 在 Python 程序运行中，至少有 4 个 scopes 是存在的。 Local(innermost)，包含局部变量。如，function 内部的变量。 Enclosing，包含了非局部(non-local)也非全局(non-global)的变量。例如，两个嵌套函数，内层函数可能搜索外层函数的 namespace，但该 namespace 对内层函数而言既非局部也非全局。 Global(next-to-last)，当前脚本的最外层。如，当前模块的全局变量。 Built-in(outtermost)，Python builtin module。Containing bulit-in functions / built-in values / keywords and so on. 著名的 ‘LEGB-rule’，即 scope 的搜索顺序： Local -&gt; Enclosing -&gt; Global -&gt; Built-in 首先，搜索最里面包含局部命名的作用域 其次，从里向外搜索所有父函数的作用域，其中的命名既非局部也非全局。(该域不一定存在) 接着，再往上搜索的作用域是当前模块全局命名的作用域，即函数定义所在的模块的命名空间 最后，搜索的是包含内置命名的命名空间作用域 对于最终都没有搜索到的命名，Python 会抛出一个 NameError 异常。 Example1:1234567891011&gt;&gt;&gt; def outer() : a = 0 b = 1 def inner() : print(a) print(b) inner()&gt;&gt;&gt; outer()01 当执行 inner() 的时候，发现 Local 作用域里面没有 a 和 b，就会往上层搜索 Example2:123456789101112&gt;&gt;&gt; def outer() : a = 0 b = 1 def inner() : print(a) # non-local namespace &apos;a&apos; b = 2 print(b) # Locale namespace &apos;b&apos; inner()&gt;&gt;&gt; outer()02 Example3:123456789101112&gt;&gt;&gt; def outer() : a = 0 b = 1 def inner() : print(a) # Local namespace &apos;a&apos; print(b) # Local namespace &apos;b&apos; b = 2 inner()&gt;&gt;&gt; outer()0UnboundLocalError: local variable &apos;b&apos; referenced before assignment Python 局部变量不能够在定义之前引用 总结： 局部赋值语句通常会隐式地创建一个局部变量，即便该变量名已存在于赋值语句发生的上一层作用域中。 如果没有 global 关键字声明变量，对一个变量的赋值总是认为该变量存在于最内层(innermost)的作用域中 local non-local global local：一般在没有说明的情况下赋值都默认为 local 的。nonlocal：默认情况下变量的作用范围是local的，nonlocal 能够将变量绑定为local到global(excluding)之间作用域。i.e.，如果你说明了一个 nonlocal 变量，这个命名的作用域就是从本地到整个模块之间(excluding global)。比如，函数外有一个变量 a，函数内说明一个 nonlocal a 变量，则函数里面的这个 a 其实就是函数外面的 a 的值。如果，对函数里面的 a 赋值，则调用这个函数之后，函数外面的 a 的值就已经改变了。global：说明全局变量，这个变量的作用域是整个模块。1234567891011121314151617181920212223&gt;&gt;&gt; def scope_test() : def do_local() : spam = &apos;local spam&apos; def do_nonlocal() : nonlocal spam spam = &apos;nonlocal spam&apos; def do_global() : global spam spam = &apos;global spam&apos; spam = &apos;test spam&apos; do_local() print(&apos;After local assignment: &apos;, spam) # print nonlocal &apos;spam&apos; do_nonlocal() print(&apos;After nonlocal assignment: &apos;, spam) # print nonlocal &apos;spam&apos;, but it has been change do_global() print(&apos;After global assignment: &apos;, spam) # print nonlocal &apos;spam&apos;, the function just change the global &apos;spam&apos;&gt;&gt;&gt; scope_test()After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spam&gt;&gt;&gt; print(&apos;In global scope: &apos;, spam)In global scope: global spam The Scope and Namespace of Class1234567891011121314&gt;&gt;&gt; class A : a = 0 def func(self) : b = a + 1 print(b)&gt;&gt;&gt; A.func # 查看类中 func 函数的属性&lt;function A.func at 0x00000038A3AF4488&gt;&gt;&gt;&gt; A().func&lt;bound method A.func of &lt;__main__.A object at 0x000000D5EB971400&gt;&gt;&gt;&gt;&gt; A.func()TypeError: func() missing 1 required positional argument: &apos;self&apos;&gt;&gt;&gt; A().func() # 执行类中 func 函数NameError: name &apos;a&apos; is not defined Python 类中的方法的第一个参数通常是self，这是一个约定。如果不遵循这个约定，对其他 Python 程序员而言你的代码可读性就会变差，而且有些浏览器程序也可能遵循此约定编写的。self 是类方法的第一个参数，它就是类的实例对象自己，当调用方法时：A().func() 等同于 A().func(A)然后，类中的方法就可以通过 self 来调用该方法外面的方法或者变量了。这和 C++ 中隐式的 this 类似。 类的定义就像函数定义，要先执行才能生效。所以，定义了一个类无论有没有错误(不包括定义类时出现语法错误)，都不会报错。因此，查看类的 attribute 时(如，A.func A().func)，无论这个类有没有错误，都不会报错。但是当执行这个类的时候(如，A().func())，如果错误就会报错。同时，因为类中的方法有参数 self，所以，在实例化类的时候要加括号A()。self 表示传进去的时类本身，所以可以不用填，但括号一定要。如果，定义的类中不用传参，实例化类的时候是可以不用括号的。 12345678910&gt;&gt;&gt; class B : a = 0 def func() : b = &apos;hello&apos; print(b)&gt;&gt;&gt; B.a0&gt;&gt;&gt; B.func()hello 类定义时，会创建一个新的命名空间，作为局部作用域。因此，在类中定义的变量(第一层)和函数名会成为这个新命名空间的局部变量。定义一个函数也会创建一个命名空间，因此，在类中定义一个函数时，这个函数里面的变量是属于这个函数命名空间的。类的命名空间的变量不能够直接调用函数内的变量，函数内也不能过直接调用类命名空间的变量。如果想要调用该方法外面的变量或者方法，可以通过 self 来实现 12345678&gt;&gt;&gt; class A : a = 0 def func(self) : b = self.a + 1 print(b)&gt;&gt;&gt; A().func()1 List Comprehension (列表推导式/列表解析)[expression for varible in iterable] or list(expression for varible in iterable)Generator Expression (生成器表达式)(expression for varible in iterable)List Comprehension 和 Generator Expression 都会创建一个新的 namespace，里面的 varible 的作用域只是在这个命名空间。所以，当执行完一个 List Comprehension 或 Generator Expression 的时候，里面的 varible 都不会存留下来。123456789101112&gt;&gt;&gt; [i for i in range(0, 10, 2)][0, 2, 4, 6, 8]&gt;&gt;&gt; print(i)NameError: name &apos;i&apos; is not defined&gt;&gt;&gt; list(i for i in range(0, 10, 2))[0, 2, 4, 6, 8]&gt;&gt;&gt; print(i)NameError: name &apos;i&apos; is not defined&gt;&gt;&gt; (i for i in range(0, 10, 2))&lt;generator object &lt;genexpr&gt; at 0x000000734276DDB0&gt;&gt;&gt;&gt; iNameError: name &apos;i&apos; is not defined 因此，在 List Comprehension 或者 Generator Expression 调用外部的变量也会出错。12345&gt;&gt;&gt; class A : a = 3 b = list(a + i for i in range(10)) # &apos;i&apos; 输入 range(10)，&apos;a&apos; 没有定义NameError: name &apos;a&apos; is not defined","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Python - module","slug":"python/module","date":"2016-04-30T16:00:00.000Z","updated":"2019-02-26T12:33:28.633Z","comments":true,"path":"2016/05/01/python/module/","link":"","permalink":"https://lizsgh.github.io/2016/05/01/python/module/","excerpt":"","text":"Import Module 主程序和模块程序在同一目录下：– folder:—- test.py—- module.py test.py12345def func1() : print(&apos;Hello World!&apos;)def func2() : print(&apos;Python3&apos;) module.py12345def func1() : print(&apos;Python3&apos;)def func2() : print(&apos;Hello World!&apos;) test.py import module.py在 test.py 文件中或者运行 test.py 时加入 import module，则 test.py import 了整个 module.py。1234============ RESTART: C:\\Users\\lizs\\Desktop\\Python3_test\\test.py ============&gt;&gt;&gt; import module # import 整个模块&gt;&gt;&gt; module.func2() # 调用模块下的内容的时候要在前面加模块名和点分连接(module.func2())Hello World! 也可以 import 模块中的个别内容，如：123&gt;&gt;&gt; from module import func1 # import module 模块中的 func1&gt;&gt;&gt; func1() # 调用的时候就不用加模块名称了(module.func1())Python3 也可以 from module import *，但是这种方式不会导入下划线_开头的名称。一般情况下不赞成使用这种方法。注意，出于性能考虑，每个模块在每个解析器会话中只导入一次。因此，如果你修改了已经导入的模块，你必须重启解析器。或者，如果你就是想交互式的测试一下更改的模块，可以使用 importlib.reload(module)。module.reload() has been deprecated since version 3.4.12345678910111213# module.py 添加了 func3()&gt;&gt;&gt; module.func3() # 更新之后直接调用AttributeError: module &apos;module&apos; has no attribute &apos;func3&apos;&gt;&gt;&gt; import module # 再次 import，无效&gt;&gt;&gt; module.func3()AttributeError: module &apos;module&apos; has no attribute &apos;func3&apos;&gt;&gt;&gt; from module import func3 # 无效ImportError: cannot import name &apos;func3&apos;# 使用 importlib.reload(module) 重新导入&gt;&gt;&gt; improt importlib&gt;&gt;&gt; importlib.reload(module)&gt;&gt;&gt; module.func3()module 主程序在模块所在目录的父(或祖辈)目录。folder：– test.py– package:—- module.py test.py12345def func1() : print(&apos;Hello World!&apos;)def func2() : print(&apos;Python3&apos;) module.py12345def func1() : print(&apos;Python3&apos;)def func2() : print(&apos;Hello World!&apos;) 首先，要模块所在的目录(Package，包)创建一个 init.py 文件。然后再 import：123&gt;&gt;&gt; import package.module # Import 整个 module.py，要用点分连接 Package 和 Module&gt;&gt;&gt; package.module.func1() # 调用是要完整的 package.module.func() 模式Python3 123&gt;&gt;&gt; from package.module import func1() # 这种方式 import 只需要 module.py 文件下的func&gt;&gt;&gt; func2()Hello World! # 调用也是只需要 func 名称 + sys.path是python的搜索模块的路径集，是一个list。可以在python 环境下使用sys.path.append(path)添加相关的路径，但在退出python环境后自己添加的路径就会自动消失了! 使用下面方法将路径永久添加到sys.path: 方法一：使用pth文件，在 /Lib/site-packages文件中创建.pth文件，将模块的路径写进去，一行一个路径， 方法二：使用PYTHONPATH环境变量，在这个环境变量中输入相关的路径，不同的路径之间用逗号（英文的)分开，如果PYTHONPATH 变量还不存在，可以创建它! 远程目录通过分布式文件系统挂载后，找出路径用上述方法即可。 12345678910需要解决一个问题，避免由于之前存在一个同名模块导致加载失败import sys;if not &quot;/home/a/&quot; in sys.path: sys.path.append(&quot;/home/a/&quot;)if not &apos;b&apos; in sys.modules: b = __import__(&apos;b&apos;)else: eval(&apos;import b&apos;) b = eval(&apos;reload(b)&apos;)","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"WeChat redpack SDK","slug":"php/wechat_redpack","date":"2016-04-26T16:00:00.000Z","updated":"2019-02-26T08:42:05.142Z","comments":true,"path":"2016/04/27/php/wechat_redpack/","link":"","permalink":"https://lizsgh.github.io/2016/04/27/php/wechat_redpack/","excerpt":"","text":"调用请求说明 请求 URL：https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack 是否需要证书：是 请求方式： POST 请求参数（必填） 字段名 字段 示例值 类型 说明 随机字符串 nonce_str 5K8264ILTKCH16CQ2502SI8ZNMTM67VS String(32) 随机字符串，不长于 32 位 商户号 mch_billno 1234567890 String(32) 微信支付的商户号 公众账号 appid wxappid wx1234567890abcdef String(32) 微信公众号的 appid (在mp.weixin.qq.com申请的) 商户名称 send_name 京东商城 String(32) 红包发送者名称 商户订单号 mch_billno 1234567890201606011234567890 String(28) 每个订单号必须唯一，组成：mch_id+yyyymmdd+10位一天内不能够重复的数字。 用户 openid re_openid oxTWIuGaIt6gTKsQRLau2M0yL16E String(32) 接受红包的用户在 wxappid 下的 openid Ip 地址 client_ip 192.168.0.1 String(15) 调用接口的机器的 IP 地址 付款金额 total_amount 1000 int 红包金额，单位是分。红包金额范围：￥1 ～ ￥200 红包发放总人数 total_num 1 int 红包发放总人数 红包祝福语 wishing 恭喜发财 String(128) 红包祝福语 活动名称 act_name 拜年 String(32) 活动名称 备注 remark 备注 String(256) 备注信息 签名 sign 5K8264ILTKCH16CQ2502SI8ZNMTM67VS String(32) 生成的签名 数据示例：123456789101112131415&lt;xml&gt;&lt;sign&gt;&lt;![CDATA[E1EE61A91C8E90F299DE6AE075D60A2D]]&gt;&lt;/sign&gt;&lt;mch_billno&gt;&lt;![CDATA[0010010404201411170000046545]]&gt;&lt;/mch_billno&gt;&lt;mch_id&gt;&lt;![CDATA[888]]&gt;&lt;/mch_id&gt;&lt;wxappid&gt;&lt;![CDATA[wxcbda96de0b165486]]&gt;&lt;/wxappid&gt;&lt;send_name&gt;&lt;![CDATA[send_name]]&gt;&lt;/send_name&gt;&lt;re_openid&gt;&lt;![CDATA[onqOjjmM1tad-3ROpncN-yUfa6uI]]&gt;&lt;/re_openid&gt;&lt;total_amount&gt;&lt;![CDATA[1000]]&gt;&lt;/total_amount&gt;&lt;total_num&gt;&lt;![CDATA[1]]&gt;&lt;/total_num&gt;&lt;wishing&gt;&lt;![CDATA[恭喜发财]]&gt;&lt;/wishing&gt;&lt;client_ip&gt;&lt;![CDATA[127.0.0.1]]&gt;&lt;/client_ip&gt;&lt;act_name&gt;&lt;![CDATA[拜年]]&gt;&lt;/act_name&gt;&lt;remark&gt;&lt;![CDATA[备注]]&gt;&lt;/remark&gt;&lt;nonce_str&gt;&lt;![CDATA[50780e0cca98c8c8e814883e5caa672e]]&gt;&lt;/nonce_str&gt;&lt;/xml&gt; 实现步奏 获取随机字符串 123456789101112131415/** * 获取指定长度的随机字符串 * ASCII 码： a-z: 97-122; A-Z: 65-90 * @param int $length * @return string */public function getRandom($length = 32) &#123; $nonce_str = &apos;&apos;; for ($i=0; $i&lt;$length; $i++) &#123; $random = rand(0, 61); $c = $random &lt; 10 ? rand(0, 9) : chr(rand(1, 26) + rand(0, 1)*32 + 64); $nonce_str .= $c; &#125; return $nonce_str;&#125; 整合请求发送的数据 12345678910111213141516171819202122232425 /** * 微信发送红包的请求数据（除了签名参数 sign） * @return array */public function angPaoData() &#123; // 活动名称 $act_name = &apos;act_name&apos;; // 备注 $remark = &apos;remark&apos;; $data = array( &apos;nonce_str&apos; =&gt; getRandom(32), &apos;mch_billno&apos; =&gt; $mch_billno.date(&apos;YmdHis&apos;).rand(1000, 9999), &apos;mch_id&apos; =&gt; $mch_billno, // 商户号 &apos;wxappid&apos; =&gt; $wxappid, // 公众号 appid &apos;send_name&apos; =&gt; $send_name, // 商户名称 &apos;re_openid&apos; =&gt; $open_id, // 用户 openid &apos;total_amount&apos; =&gt; $total_amount, // 红包金额 &apos;total_num&apos; =&gt; 1, // 红包发放人数 &apos;wishing&apos; =&gt; $wishing, // 红包祝福语 &apos;client_ip&apos; =&gt; $client_ip, // 当前客户端 IP 地址 &apos;act_name&apos; =&gt; $act_name, &apos;remark&apos; =&gt; $remark, ); return $data;&#125; 签名算法 12345678910111213141516171819function getSign($data) &#123; global $_W; ksort($data, SORT_STRING); $stringA = &apos;&apos;; // 第一步，将所有发送的参数按照 key=value 的格式组成字符串 stringA， // 并且 key 要按照 ASCII 码从小到大排序（字典序） foreach ($data as $k =&gt; $v) &#123; if ($k &amp;&amp; $v &amp;&amp; $k != &apos;sign&apos;) &#123; $stringA .= &quot;&#123;$k&#125;=&#123;$v&#125;&amp;&quot;; &#125; &#125; // 第二步，在 stringA 最后拼接上 key 得到 stringSignTemp 字符串， // 并对 stringSignTemp 进行 MD5 运算，再将得到的字符串所有字符转换为大写 // key 设置路径：微信商户平台(pay.weixin.qq.com)--&gt;账户设置--&gt;API安全--&gt;密钥设置 $setting = uni_setting($_W[&apos;uniacid&apos;], array(&apos;payment&apos;)); $key = $setting[&apos;payment&apos;][&apos;wechat&apos;][&apos;apikey&apos;]; $stringSignTemp = $stringA . &quot;key=&quot; . $key; return strtoupper(md5($stringSignTemp));&#125; 发送数据的时候，不要忘记了将数据转换成指定的 xml 格式 12345678910111213/** * 将数据转换成符合传送要求的 xml 格式 * @param $data * @return string */function array2xml($data) &#123; $xml = &quot;&lt;xml&gt;&quot;; foreach ($data as $k =&gt; $v) &#123; $xml .= &quot;&lt;&quot; . $k . &quot;&gt;&lt;![CDATA[&quot; . $v . &quot;]]&gt;&lt;/&quot; .$k . &quot;&gt;&quot;; &#125; $xml .= &quot;&lt;/xml&gt;&quot;; return $xml;&#125; 获取微信支付证书文件 为了安全，一般将证书的内容保存到数据库中，使用的时候读取出来，保存到文件中去，用完之后，及时删除掉。 12345678910111213141516171819202122232425262728 /** * 获取微信支付文件： * 1、apiclient_cert.pem * 2、apiclient_key.pem * 3、rootca.pem */public function getPayFile() &#123; // 从数据库中取出来 $sec = m(&apos;common&apos;)-&gt;getSec(); $certs = iunserializer($sec[&apos;sec&apos;]); if (is_array($certs)) &#123; if (empty($certs[&apos;cert&apos;]) || empty($certs[&apos;key&apos;]) || empty($certs[&apos;root&apos;])) &#123; message(&apos;未上传完整的微信支付证书，请到【系统设置】-&gt;【支付方式】中上传!&apos;, &apos;&apos;, &apos;error&apos;); &#125; $certfile = IA_ROOT . &quot;/addons/sz_yi/cert/apiclient_cert.pem&quot;; file_put_contents($certfile, $certs[&apos;cert&apos;]); $keyfile = IA_ROOT . &quot;/addons/sz_yi/cert/apiclient_key.pem&quot;; file_put_contents($keyfile, $certs[&apos;key&apos;]); $rootfile = IA_ROOT . &quot;/addons/sz_yi/cert/rootca.pem&quot;; file_put_contents($rootfile, $certs[&apos;root&apos;]); $extras[&apos;CURLOPT_SSLCERT&apos;] = $certfile; $extras[&apos;CURLOPT_SSLKEY&apos;] = $keyfile; $extras[&apos;CURLOPT_CAINFO&apos;] = $rootfile; &#125; else &#123; message(&apos;未上传完整的微信支付证书，请到【系统设置】-&gt;【支付方式】中上传!&apos;, &apos;&apos;, &apos;error&apos;); &#125; return @$extras ?: array();&#125; 用 CURL 发送数据 12345678910111213141516171819202122232425262728293031323334353637/** * @param $url * @param $vars * @param int $second * @param array $aHeader * @return bool|mixed */function curl_post_ssl($vars, $second=30, $aHeader=array())&#123; $url = &apos;https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack&apos;; $ch = curl_init($url); curl_setopt($ch, CURLOPT_TIMEOUT, $second); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); //cert 与 key 分别属于两个.pem文件 //请确保您的libcurl版本是否支持双向认证，版本高于7.20.1 foreach ($this-&gt;getPayFile() as $k =&gt; $v) &#123; curl_setopt($ch, constant($k), $v); &#125; if( count($aHeader) &gt;= 1 )&#123; curl_setopt($ch, CURLOPT_HTTPHEADER, $aHeader); &#125; curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $vars); $data = curl_exec($ch); if($data)&#123; curl_close($ch); return $data; &#125; else &#123; $error = curl_errno($ch); //echo &quot;call faild, errorCode:$error\\n&quot;; curl_close($ch); return false; &#125;&#125; 发送红包 1234567891011121314151617 /** * 发送红包 * @return bool|mixed */public function angPaoPay() &#123; // 红包请求数据 $data = $this-&gt;angPaoData(); $data[&apos;sign&apos;] = $this-&gt;getSign($data); // 将数据转换成 xml 格式 $postXml = array2xml($data); $responseXml = $this-&gt;curl_post_ssl($postXml); // 为了证书安全，及时删掉 foreach ($this-&gt;getPayFile() as $file) &#123; unlink($file); &#125; return $responseXml;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"https://lizsgh.github.io/tags/php/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}]},{"title":"Nginx - 配置反向代理，让公网可以访问本地服务器","slug":"nginx/nginx配置反向代理，让公网访问本地服务器","date":"2016-03-25T16:00:00.000Z","updated":"2019-02-26T12:59:05.108Z","comments":true,"path":"2016/03/26/nginx/nginx配置反向代理，让公网访问本地服务器/","link":"","permalink":"https://lizsgh.github.io/2016/03/26/nginx/nginx配置反向代理，让公网访问本地服务器/","excerpt":"","text":"需求最近用微擎框架做微信公众号开发，需要通过绑定站点域名来收发信息。因此，平常在本地的开发环境是不能够满足需求的。但是，我们不可能每更改一点东西就将更改之后的内容更新到服务器上面去测试吧。为了能够让 URL 访问到本地的服务器，可以将指定域名的访问反向代理到本地来。 解决 首先，分配子域名，并且指向你的远程服务器。比如，*.lizsblog.com。 在配置方向代理之前，必须在本地网络的路由给你的 PC 设置一个虚拟服务器(端口转发)。即，分配一个固定的 IP 和端口号，当访问你网络的 IP 和你分配的端口号时，路由就会将访问转发到你的 PC。光纤用户，要先配置光纤猫。 | 名称 | 协议 | 外部端口 | 内部 IP 地址 | 内部端口 | |——–|———|—————|——————–|—————| | lizs | TCP 和 UDP | 8112 | 192.168.1.99 | 80 | 在远程服务器上面配置一个方向代理，指向你本地生产环境的服务器。 1234567891011121314151617181920212223242526server &#123; listen 80; server_name *.lizsblog.com; location / &#123; proxy_redirect off; proxy_pass http://183.26.116.104:8112; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 20m; &#125;&#125; proxy_pass 参数后面的 183.26.116.104 是你本地网络的 IP，可以通过百度搜索 ip 即可查看；8112 是你本地网络给你 PC 设置的虚拟服务器的端口号。 通过从远程服务器中反向代理你本地的 PC 之后，只要配置本地 Nginx 服务器就可以了。 Nginx 一般都有一个 default 配置的，里面的 root 只要指向你的项目文件就可以了。比如， 12root /home/lizs/app/we7/shengmingtrip 但是，这样存在一个问题，当你要用同样的方法做第二个项目的时候，你就要将 root 指向你的第二个项目文件目录了。那么，如果想要访问第一个项目呢？不是又要修改回来了吗？那如果有更多的项目呢？我们可以根据不同的域名来访问不同的项目文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# Default server configurationserver &#123; listen 80 default_server; listen [::]:80 default_server; set $dir_name default; # shengming project if ($host = &quot;shengmingtrip.lizs.easecloud.cn&quot;) &#123; set $dir_name we7/shengmingtrip; &#125; # dsyd project if ($host = &quot;dsyd.lizs.easecloud.cn&quot;) &#123; set $dir_name we7/dsyd; &#125; root /home/lizs/app/$dir_name; # Add index.php to the list if you are using PHP index index.html index.htm index.php index.nginx-debian.html; server_name _; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; &#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 location ~ \\.php$ &#123; include snippets/fastcgi-php.conf; # With php5-cgi alone: fastcgi_pass 127.0.0.1:9000; # With php5-fpm: # fastcgi_pass unix:/var/run/php5-fpm.sock; &#125;&#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://lizsgh.github.io/categories/Nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://lizsgh.github.io/tags/nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://lizsgh.github.io/categories/Nginx/"}]},{"title":"Linux - 使用 SSH 登录远程服务器","slug":"linux/ssh_login_server","date":"2016-03-18T16:00:00.000Z","updated":"2019-02-26T13:25:35.869Z","comments":true,"path":"2016/03/19/linux/ssh_login_server/","link":"","permalink":"https://lizsgh.github.io/2016/03/19/linux/ssh_login_server/","excerpt":"","text":"Windows 中远程 SSH 登录 VPS 进行管理可以用 PuTTY、BvSshClient 等应用，但 Linux 中就没必要用他们了。 Linux 可以通过 OpenSSH，可以通过它来登录 VPS。 Linux 终端登录 SSH1ssh &lt;userName&gt;@&lt;serverDomain or IP&gt; -p &lt;port&gt; 快速登录 SSH 本身提供了登录配置文件 ~/.ssh/config，我们可以在本地配置 config 来快速登录 VPS。 创建 config 脚本文件( home/user/.ssh/ 文件夹里面) 1vim ~/.ssh/config 配置 config 文件 1234Host 配置别名(如，vps1) Hostname serverName 或 serverIp Port 端口 User userName 示例： 1234Host myblog Hostname lizsblog.com Port 26522 User root 登录保存号 config 文件的配置之后，就可以用别名来快速登录了 1ssh myblog 不过这样还是需要登录密码的，下面可以用 IdentityFile 属性来设置不需要密码自动登录。 自动登录：ssh 密钥认证自动登录 ssh 密钥：~/.ssh/id_rsa； ssh 公钥：~/.ssh/id_rsa.pub 在本地 PC 如果没有 ssh 公钥，则创建公钥 1ssh-keygen -t rsa -C &quot;comment&quot; 执行过程中连续回车即可。 -t：指定密钥类型，默认即为rsa，可以省略； -C：设置注释，显示在公钥最后，可以省略。 将 ssh 公钥复制到远程服务器 ~/.ssh/authorized_keys 文件中 简单粗暴：打开远程服务器，创建文件 ~/.ssh/authorized_keys，将本地 PC 的 ssh 公钥的内容复制到authorized_keys 中，注意是将内容追加到后面，前面可能已经有了其他人的 ssh 公钥。 在本地终端用命令实现：1234// 如果远程终端没有创建 .ssh 文件夹cat ~/.ssh/id_rsa.pub | ssh username@hostname &quot;mkdir ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys&quot;// 已经创建 .ssh 文件夹cat ~/.ssh/id_rsa.pub | ssh username@hostname &quot;cat &gt;&gt; ~/.ssh/authorized_keys&quot; 在本地 ssh 配置文件~/.ssh/config 添加IdentityFile 属性 1234Host myblog Hostname lizsblog.com User root IdentifyFile ~/.ssh/id_rsa 自动登录 1ssh myblog 不需要输入密码，直接登录了远程服务器。 创建多个服务器的快速登录只需要在 config 文件里面空行添加多个 Host 配置即可。多个服务器是可以共用同一个 ssh 公钥来实现自动登录的。 其他配置属性 为了保持连接，ssh 每隔 30s 向 server 发出一次请求12ServerAliveInterval 30 // timeout interval, unit secondsServerAliveCountMax 10 // server 没有响应时，最大执行发送请求次数。default 3 其他参考 www.openssh.com","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Git - CURL 换行问题","slug":"git/curl","date":"2016-02-12T16:00:00.000Z","updated":"2019-02-26T13:43:31.100Z","comments":true,"path":"2016/02/13/git/curl/","link":"","permalink":"https://lizsgh.github.io/2016/02/13/git/curl/","excerpt":"","text":"CRLF CRLF：Carriage-Return Line-Feed 回车换行 CRLF：回车换行。 CR：回车，使用\\r符号表示，ASCII 码为 13，十六进制代码为 0x0D； LF：换行，使用\\n符号表示，ASCII 码为 10，十六进制代码为 0x0A。 不同系统下的换行符 Windows/DOS：CR/LF Unix/Linx：LF Mac OS：CR 所以，Windows 系统上换行在文本文件中是使用 0d 0a 两个字节表示，而在 Unix/Linx或苹果系统上换行则是使用一个字节 0a 或 0d 表示。Unix/Linux/Mac系统下的文件在Windows里打开的话（使用Windows自带记事本），会出现换行丢失，所有文字会变成一行，整个文本会乱成一团。Windows系统下的文件在Unix/Linux/Mac里打开的话，在每行的结尾可能会多出一个^M符号。 Git CRLFGit 在默认情况下，提交时会将 CRLF 转换为 LF，在拉取时将 LF 转换成 CRLF。我们可以通过设置 autocrlf 和 safecrlf 来处理 CRLF 的转换。 autocrlf 属性：true、input、false true：提交时，CRLF 转换为 LF；拉取时，LF 转换为 CRLF input：提交时，CRLF 转换为 LF；拉取时，不进行转换。 false：提交拉取时都不转换。 查看当前项目的 autocrlf 属性： 1git config core.autocrlf 查看 autocrlf 的全局属性： 1git config --global core.autocrlf 设置当前项目的 autocrlf 属性： 1git config core.autocrlf true/input/false 设置 autocrlf 的全局属性： 1git config --global core.autocrlf true/input/false savecrlf：true、false、warn 拒绝提交包含混合换行符的文件 1git config --global core.safecrlf true 允许提交包含混合换行符的文件 1git config --global core.safecrlf false 提交包含混合换行符的文件时给出警告 1git config --global core.safecrlf warn","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"LSBInitScript - php5-cgi","slug":"php/php5_cgi_lsbinitscript","date":"2016-02-03T16:00:00.000Z","updated":"2019-02-26T12:52:29.964Z","comments":true,"path":"2016/02/04/php/php5_cgi_lsbinitscript/","link":"","permalink":"https://lizsgh.github.io/2016/02/04/php/php5_cgi_lsbinitscript/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#!/bin/sh### BEGIN INIT INFO# Provides: php5-cgi# Required-Start: $remote_fs $network# Required-Stop: $remote_fs $network# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: starts the php5-cgi# Description: Starts the PHP FastCGI Process Manager Daemon### END INIT INFOPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/binDAEMON=/usr/bin/spawn-fcgiNAME=php5-cgiCGI_FILE=/usr/bin/$NAMEPID_FILE=/var/run/$&#123;NAME&#125;.pidDAEMON_ARGS=&quot;-a 127.0.0.1 -p 9000 -C 32 -u lizs -g lizs -f $CGI_FILE -P $PID_FILE&quot;# Load the VERBOSE setting and other rcS variables. /lib/init/vars.sh# Define LSB functions.. /lib/lsb/init-functions## Check if php5-cgi is running#do_check()&#123; # Return # 0 if php5-cgi doesn&apos;t has been started # 1 if php5-cgi was already running ps -ef | grep $NAME | grep -v grep &gt; /dev/null || return 0 return 0&#125;## Start php5-cgi#do_start()&#123; # Return # 0 if daemon has been started successfully # 1 if daemon was already running # 2 if daemon could not be started start-stop-daemon --start --test --quiet --pidfile $PID_FILE --exec $DAEMON &gt; /dev/null \\ || return 1 start-stop-daemon --start --quiet --pidfile $PID_FILE --exec $DAEMON -- $DAEMON_ARGS 2&gt; /dev/null \\ || return 2 #spawn-fcgi -a 127.0.0.1 -p 9000 -C 32 -u lizs -g lizs -f /usr/bin/$&#123;NAME&#125; -P $PID_FILE&#125;## Stop php5-cgi#do_stop()&#123; # Return # 0 if daemon has beent stopped successfully # 1 if daemon was already stopped # 2 if daemon could not be stopped # other if a failure occurred start-stop-daemon --stop --quiet --retry=QUIT/30/TERM/5/KILL/5 --pidfile $PID_FILE --name $NAME --remove-pidfile RETVAL=&quot;$?&quot; return &quot;$RETVAL&quot; #killall $NAME #rm -f $PID_FILE&#125;case &quot;$1&quot; in start) if init_is_upstart; then exit 1 fi log_daemon_msg &quot;Starting $NAME&quot; do_start case &quot;$?&quot; in 0|1) log_end_msg 0 ;; 2) log_end_msg 1 ;; esac ;; stop) if init_is_upstart; then exit 1 fi log_daemon_msg &quot;Stopping $NAME&quot; do_stop case &quot;$?&quot; in 0|1) log_end_msg 0 ;; 2) log_end_msg 1 ;; *) log_end_msg 1 ;; esac ;; restart) if init_is_upstart; then exit 1 fi log_daemon_msg &quot;Restarting $NAME&quot; do_stop case &quot;$?&quot; in 0|1) do_start case &quot;$?&quot; in 0) log_end_msg 0 ;; 1) log_end_msg 1 ;; 2) log_end_msg 1 ;; *) log_end_msg 1 ;; esac ;; *) log_end_msg 1 ;; esac ;; status) status_of_proc &quot;$CGI_FILE&quot; &quot;$NAME&quot; &amp;&amp; exit 0 || exit $? exit 0; ;; reload|force-reload) # No-op exit 0 ;; *) echo &quot;Usage: $NAME &#123;start|stop|status|help&#125;&quot; &gt;&amp;2 exit 1 ;;esac","categories":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"https://lizsgh.github.io/tags/php/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}]},{"title":"PHP - curl 访问需要用户登录的网站","slug":"php/curl访问需要用户登录的网站","date":"2016-02-01T16:00:00.000Z","updated":"2019-02-26T12:56:24.937Z","comments":true,"path":"2016/02/02/php/curl访问需要用户登录的网站/","link":"","permalink":"https://lizsgh.github.io/2016/02/02/php/curl访问需要用户登录的网站/","excerpt":"","text":"项目需求：每天定时访问一次网站的某个网页，而且这个网页是需要登录才能够访问。 解决思路（linux系统）：解决其实很简单，只要每天定时用浏览器登录，然后访问就可以了。但是，这种做法是不现实的。我们可以利用 linux 的定时器(crontab) 来实现定时访问功能，然后用 PHP CURL 来模拟浏览器登录和访问。 首先，在系统设置定时任务。定时执行某个 php 文件，如 timer.php。 在这个 php 文件中会实现两个功能，先登录，获取登录信息的 cookie，然后访问指定的网页。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 先登录（登录需要获取 token） */// 创建临时存放 cookie 的文件$cookie_file = tempnam(&apos;./temp&apos;, &apos;cookie&apos;);$login_url = &apos;http://..&apos;;$ch = curl_init($login_url);// 是否将头文件的信息作为数据流输出curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_POST, 1);// 先获取 token，已在登录页面设置好curl_setopt($ch, CURLOPT_POST, array(&apos;curl_token&apos; =&gt; &apos;curl_token&apos;));$token = curl_exec($ch);// 登录curl_setopt($ch, CURLOPT_POST, array( &apos;submit&apos; =&gt; &apos;登录&apos;, &apos;token&apos; =&gt; $token, &apos;username&apos; =&gt; &apos;xxx&apos;, &apos;password&apos; =&gt; &apos;xxx&apos;,));// 连接结束后，比如，调用 curl_close 后，保存 cookie 信息curl_setopt($ch, CURLOPT_COOKIEJAR, $cookie_file);// 再次连接，这次是登录curl_exec($ch);curl_close($ch);/** * 利用登录获取的登录 cookie，访问页面 */$url = &apos;http://...&apos;;$ch = curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);// 模拟登录状态的 cookiecurl_setopt($ch, CURLOPT_COOKIEFILE, $cookie_file);curl_exec($ch);curl_close($ch);","categories":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"https://lizsgh.github.io/tags/php/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}]},{"title":"PHP - php-cgi 开机启动、重启","slug":"php/php_cgi_start","date":"2016-01-31T16:00:00.000Z","updated":"2019-02-26T12:50:49.965Z","comments":true,"path":"2016/02/01/php/php_cgi_start/","link":"","permalink":"https://lizsgh.github.io/2016/02/01/php/php_cgi_start/","excerpt":"","text":"php-cgi 开机启动（ubuntu） 将 php-cgi 的启动添加到系统启动服务 rc-local：/etc/rc.local（个别版本可能不一样，具体查看/etc/init.d/rc.local） 12spawn-fcgi -a 127.0.0.1 -p 9000 -C 32 -u lizs -g lizs -f /usr/bin/php5-cgi -P /var/run/php5-cgi.pid 自己写一个 LSBInitScript 脚本来启动服务。这样不但可以开机启动还可以随时用 service 来控制 php-cgi 程序的启动/关闭/重启等。 php-cgi 重启 php-cgi 的重启没有像 Nginx service nginx restart 那样的快捷方式，所以，我们可以通过先杀死所有 php-cgi 进程，再启动 php-cgi 的方式来达到重启的目的。 当然，如果可以自己写一个启动服务 LSBInitScript 最好，直接可以用 service 来实现重启功能。 关闭所有 php-cgi 进程 12sudo killall php-cgi 启动 php-cgi 12sudo spawn-fcgi -a 127.0.0.1 -p 9000 -C 32 -u lizs -g lizs -f /usr/bin/php5-cgi -P /var/run/php5-cgi.pid spawn-fcgi：一个通用的 FastCGI 管理服务器，它是 lighttpd 的一部份，很多人都用 Lighttpd 的 Spawn-FCGI 进行 FastCGI 模式下的管理工作。 -a：address，绑定到的地址 -p：port，绑定到的端口 -C：指定产生的 FastCGI 的进程数 -u：user，运行的用户 -g：group，运行的用户组 -f：指定调用 FastCGI 的进程的执行程序 -P：指定产生的进程的 PID 文件路径","categories":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"https://lizsgh.github.io/tags/php/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}]},{"title":"Git - Basic config","slug":"git/basic_config","date":"2016-01-01T16:00:00.000Z","updated":"2019-02-26T13:31:44.513Z","comments":true,"path":"2016/01/02/git/basic_config/","link":"","permalink":"https://lizsgh.github.io/2016/01/02/git/basic_config/","excerpt":"","text":"初次运行 Git 前的配置 Git 配置文件与命令运行 Git，我们需要先配置下自己的 Git 工作环境。Git 提供了 git config 工具来对 Git 进行配置，也可以通过直接修改 Git 的配置文件： /etc/gitconfig：系统中所有用户普遍使用的配置，用命令git config --system读写的就是这个配置文件。 ~/.gitconfig：当前用户的 Git 配置文件，使用 git config --global 进行的配置保存到这个文件。 .git/config：当前项目下 Git 的配置文件，使用 git config --local 进行配置，这里的配置仅仅针对当前项目有效。 Git 配置文件的优先级别：.git/config &gt; ~/.gitconfig &gt; /etc/gitconfig 配置用户信息12$ git config --global user.name \"lizs\"$ git config --global user.email lizsmail@qq.com 配置完毕之后，我们可以看到~/.gitconfig文件之中多了两行配置：123[user] name = lizs email = lizsmail@qq.com 配置文本编辑器Git 需要你输入一些额外信息的时候，会自动调用一个外部文本编辑器给你用，默认使用系统的默认编辑器。如我我修改提交信息的时候git commit --amend会使用 Ubuntu 系统默认编辑器 nano，使用起来不熟悉。这时候我们可以使用以下方法改变 Git 编辑器： 修改系统编辑器，打开~/.bashrc添加 export EDITOR=vim，然后 source ~/.bashrc。 使用命令 git config --global core.editor vim，修改成功之后，可以在~/.gitconfig文件中多了 core.editor 的配置： 12[core] editor = vim 直接修改 Git 配置文件 .git/config, ~/.gitconfig, /etc/gitconfig。在配置文件添加： 12[core] editor = vim 配置差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。1$ git config --global merge.tool vimdiff Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。 查看配置信息12345678$ git config --listuser.name=lizsuser.email=lizsmail@qq.comcore.editor=vimcore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=true","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"git stash","slug":"git/git_stash","date":"2015-12-31T16:00:00.000Z","updated":"2019-02-26T13:31:34.601Z","comments":true,"path":"2016/01/01/git/git_stash/","link":"","permalink":"https://lizsgh.github.io/2016/01/01/git/git_stash/","excerpt":"","text":"情景：工作的时候，你正在项目中属于你的分支下开发一部分功能，但是还没有完善。Leader 突然叫你放下当前的工作，先修改项目中一个非常紧急的 BUG。修 BUG 嘛！家常便饭了。立即切回到上次发布版本(master 最近一次合并)，新建一个分支去修复这个 BUG 。然而，在 checkout 到 master 的时候失败，提示你必须先 commit 当前分支的修改才能够 checkout 到其它分支。问题来了：当前分支的功能只是开发了一部分，不想那么快 commit。不 commit 的话，如果 reset 到前一次 commit 又浪费了之前所做的工作。怎么办？ Git 提供了一个存储机制，用户可以通过git stash或git stash save命令，将修改的跟踪文件与暂存改动存储到一个栈中。 1git stash - Stash the changes in a dirty working directory away 注意，直接git stash或git stash save是不会将未跟踪文件暂存的。所以，当有未跟踪的文件的时候，要先add，或加 -u 参数 如，当前仓库中有文件test1.py和test2.py两个文件而且工作区都是清洁的，然后对test2.py进行修改，并且添加新文件test3.py。1234567891011121314$ git statusOn branch lizsnothing to commit, working tree clean# change test2.py and add test3.py$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py# stashing the work$ git stashSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git status -s?? test3.py # Untracked files won't be stashed 那么，问题又来了。当我们 stash 修改的时候，发现还有文件没有被 stashed，想要将 stash 起来的修改恢复过来，重新 stash。要怎么做呢？ git stash list查看 stashed 的记录 12$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0 git stash apply [&lt;stash&gt;]将存储栈的一条记录重新应用到当前分支，如果不指定&lt;stash&gt;，会默认恢复最近一次 stash 记录存储内容。git stash apply在这里即相当于git stash apply stash@{0}。 1234$ git stash apply$ git status -s M test2.py?? test3.py 打开 test2.py 文件可以看到其内容又回到了 stash 之前的状态了。我们再用 git stash list 查看存储栈的时候，发现刚刚的 stash 记录还在。存储的内容都恢复了，我觉得这条记录没意义了，想要删除了相应的 stash 记录，又要怎么做？ git stash drop [&lt;stash&gt;]删除存储栈的一条 stash 记录。如果不指定&lt;stash&gt;将会默认删除存储栈中最近一次的 stash 记录，git stash drop在这里即相当于git stash drop stash@{0}。 123$ git stash dropDropped refs/stash@&#123;0&#125; (...) $ git stash list # 可以看到最近一次的 stash 记录已经被删除掉了 git stash pop [&lt;stash&gt;]恢复并删除一条 stash 记录的内容。相当于git stash apply和git stash drop命令的结合。用法和git stash apply [&lt;stash&gt;]一样。 总结以上情境中操作：12345678910111213141516171819202122# change test2.py and add test3.py in the clean working tree$ echo \"# hello world\" &gt;&gt; test2.py $ touch test3.py$ git add .$ git status -s M test2.py?? test3.py$ git stashSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean.# checkout to master fix bug$ git checkout master# create a new branch to fix bug$ git checkout -b issue-01# go back wo branch lizs to continue you work after finishing the bug$ git checkout lizs# restore your coding$ git stash pop 注意，恢复存储栈中的内容的时候可能会有冲突需要合并。 git stash --include-untracked或git stash -u将修改的跟踪文件与暂存改动，还有未跟踪的文件存储起来，即相当于先 git add 再 git stash。 123456789101112# change test2.py and add new file test3.py on a clean working tree$ echo \" \" &gt;&gt; test2.py$ touch test3.py $ git status -s M test2.py?? test5.py# stashing the change and untracked file$ git stash -uSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean. git stash save --keep-index和 git stash -u相反，通过git add命令跟踪的文件不存储。注意，--keep-index是git stash save的选项。即，git stash --keep-index是无效的。 1234567891011# change test2.py and add new file test3.py on a clean working tree$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py$ git add -A$ git stash save --keep-indexSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git status -sA test3.py git stash --patchGit 不会直接存储修改过的内容，但是会交互式地提示哪些修改要存储。 git stash branch &lt;branchname&gt; [&lt;stash&gt;]将 stash 的一个记录内容恢复在一个新创建的分支 &lt;branchname&gt; 上。&lt;branchname&gt;，新分支的名称；&lt;stash&gt;，可选，不指定默认为最近一次 stash。 12345678910111213141516171819202122232425262728# change test2.py and add new file test3.py on a clean working tree$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean.# restore the a stash on a new branch$ git stash branch issue-01 Switched to a new branch 'issue-01'On branch issue-01Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: test2.pyUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) test3.pyno changes added to commit (use \"git add\" and/or \"git commit -a\")Dropped refs/stash@&#123;0&#125; (...) 可以看到 git stash branch issue-01用分支 lizs 的一个 stash 记录的内容新建了一个 issue-01 分支，并且会自动删除该 stash 记录，当前位于 issue-01 分支下。那么 lizs 分支会怎么样呢？ 12345$ git checkout lizs$ git status -s M test2.py?? test3.py$ git stash --list # the stash has been dropped 回到 lizs 分支之后，发现用来创建新分支的 stash 的内容居然也恢复在了 lizs 分支！WTF！那这个命令有什么卵用？","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"PHP - Memcached installation and settings","slug":"php/memcached_install","date":"2015-12-31T16:00:00.000Z","updated":"2019-02-26T12:47:25.776Z","comments":true,"path":"2016/01/01/php/memcached_install/","link":"","permalink":"https://lizsgh.github.io/2016/01/01/php/memcached_install/","excerpt":"","text":"安装 Memcached 和 php memcached 扩展（ubuntu）1sudo apt-get install memcached php5-memcached 安装完 Memcached 服务会自动启动：12ps -ef | grep memcachedmemcache 11238 1 0 15:54 ? 00:00:00 /usr/bin/memcached -m 64 -p 11211 -u memcache -l 127.0.0.1 安装 Memcached 和 php memcache 扩展（ubuntu）如果你不是用 php-memcached 扩展，而用 php-memcache 扩展，则1sudo apt-get install memcached php5-memcache 安装成功之后，还需要在 PHP 的配置文件 php.ini 中添加：1extension=memcache.so 保存，然后重启 PHP。 配置Ubuntu 系统，Memcached 的配置文件为 /etc/memcached.conf。修改完配置之后，重启即可。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"https://lizsgh.github.io/tags/php/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}]},{"title":"Terminal - shortcut","slug":"others/terminal_shortcut","date":"2015-12-31T16:00:00.000Z","updated":"2019-02-26T07:35:57.150Z","comments":true,"path":"2016/01/01/others/terminal_shortcut/","link":"","permalink":"https://lizsgh.github.io/2016/01/01/others/terminal_shortcut/","excerpt":"","text":"Linux 终端窗口快捷键 Ctrl + p: 上一条命令 (相当于向上箭头)。 Ctrl + n: 下一条命令 (相当于向下箭头)。 Ctrl + a: 光标回到命令行开始位置。 Ctrl + e: 光标回到命令行开始位置。 Ctrl + b: 光标向左移动一位。 Ctrl + f: 光标向右移动一位。 Ctrl + h: 删除光标左边的一个字符。 Ctrl + d: 删除光标右边的一个字符。 Ctrl + w: 删除光标左边的一个’单词’字符。 Ctrl + u: 删除光标左边的所有字符。 Ctrl + k: 删除光标右边的所有字符。 Ctrl + l: 清屏。","categories":[{"name":"Others","slug":"Others","permalink":"https://lizsgh.github.io/categories/Others/"}],"tags":[{"name":"others","slug":"others","permalink":"https://lizsgh.github.io/tags/others/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"https://lizsgh.github.io/categories/Others/"}]},{"title":"PHP - Memcache introduction","slug":"php/memcached_intro","date":"2015-12-31T16:00:00.000Z","updated":"2019-02-26T12:45:30.054Z","comments":true,"path":"2016/01/01/php/memcached_intro/","link":"","permalink":"https://lizsgh.github.io/2016/01/01/php/memcached_intro/","excerpt":"","text":"Memcache 和 MemcachedMemcache 是一个高性能的分布式的内存对象缓存系统。它可以应对任意多个连接，使用非阻塞的网络 IO。 工作机制是，通过在内存中开辟一块空间，然后建立一个HashTable，Memcached 程序管理这些 HashTable。这块内存空间能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是，将数据调用到内存中，然后，从内存中读取，从而大大提高读取速度。 Memcache：是该系统的项目名称。 Memcached：是该系统的主程序文件（d可以理解为 daemon），以守护进程方式运行于一个或多个服务器中，随时接收客户端的连接和操作。 Memcache 服务器端和客户端 服务器端 Memcached 是 memcache 缓存系统的服务器端，它以守护进程方式运行于服务器上。同时，memcached 也是 memcache 服务器端的后台守护进程名。 客户端 那么什么是 memcache 客户端呢？你可能用 PHP 开发网站，也可能用 Python、java 等其他语言，这些相对于 memcache 缓存系统就是是客户端，都是在使用服务器的服务。再细化一点来说(如 PHP)，PHP 的 memcache 扩展 php-memcache 或 php-memcached 就是 memcache 系统的客户端。 php memcache 和 php memcachedPHP 想要使用 memcache 缓存系统，需要安装 memcache 客户端，即 memcache 的扩展。当安装 PHP 的 memcache 扩展的时候，发现有 php-memcache 和 php-memcached 两个。 php memcache：是完全在 PHP 框架内开发的，是原生实现的。 php memcached：则是使用了 libmemcached。在功能和性能上，都要比 php memcache 要好。 所以，PHP 安装 memcache 扩展的时候，建议安装 php-memcached。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"https://lizsgh.github.io/tags/php/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}]},{"title":"Git - submodule","slug":"git/submodule","date":"2015-12-31T16:00:00.000Z","updated":"2019-02-26T13:31:02.601Z","comments":true,"path":"2016/01/01/git/submodule/","link":"","permalink":"https://lizsgh.github.io/2016/01/01/git/submodule/","excerpt":"","text":"添加 submodule 假设当前 git 项目路径为 /home/lizs/app/project/ 1git submodule add submoduleUrl localPath submoduleUrl：submodule 仓库路径，如：https://github.com/lizs/hello.git 不指定 localPath，submodule clone 下来的项目会在当前目录，并且 submodule 的项目名就是 submodule 的根目录 1git submodule add https://github.com/lizs/hello.git submodule clone 下来的项目会在当前目录下，并且会用项目的名称作为submodule的根目录，也就是说，submodule的路径为 /home/lizs/app/project/hello 如果添加 localPath， localPath不能够是已经存在的目录。并且 submodule 会以 localPath 作为根目录。 1git submodule add https://github.com/lizs/hello.git www/ submodule clone 下来的项目在当前目录下的 www 目录下，即 /home/lizs/app/project/www/ 1git submodule add https://github.com/lizs/hello.git www/hi submodule clone 下来的项目在当前目录下的 www/hi 目录下，即 /home/lizs/app/project/www/hi。 localPath 不能够是已经存在的目录，是指路径的最后一层目录不能够已经存在。如果，localPath 为 www，即当前目录下不能够有 www 目录。如果 localPath 为 www/hi，即当前目录下可以有 www 目录(没有则会自动创建)，但是 www 目录下不能够有 hi 目录。 添加完成之后，会在当前项目跟路径下生成一个 .gitmodules 文件，其中记录了子模块的信息。 更新 submodule进入 submodule 目录下，将更新内容推送到 submodule 的仓库即可。 删除 submoduleHow do I remove a submodule? 克隆的项目中带有 submodule当 git clone 下来的项目中带有 submodule 时，初始化的时候，submodule 的内容并不会自动下载下来。此时，只需执行：1git submodule update --init --recursive","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"git clean","slug":"git/git_clean","date":"2015-12-31T16:00:00.000Z","updated":"2019-02-26T13:31:16.513Z","comments":true,"path":"2016/01/01/git/git_clean/","link":"","permalink":"https://lizsgh.github.io/2016/01/01/git/git_clean/","excerpt":"","text":"使用 Git 版本管理的时候，在常见的 IDE 工具 (如：PyCharm) 上看到未跟踪的文件都会与其它文件是有区别的，如文件名为红色。因此，当想要移除未跟踪的文件的时候会很简单。但是，当项目大并且未跟踪的文件很多分布在各个文件夹里面的时候，或者当没有这些方便的 IDE 工具给你的时候，你想要移除这些未跟踪文件还是很麻烦的。那么有没有方便的方法呢？ 1git-clean - Remove untracked files from the working tree 用法1git clean [-d] [-f] [-i] [-n] [-q] [-e &lt;pattern&gt;] [-x | -X] [--] &lt;path&gt;... git clean 默认从当前目录开始递归移除不在版本管理下的文件，如未跟踪的文件。也可以指定开始的目录 &lt;path&gt;。 git clean 常用参数： -n, --dry-runDon’t actually remove anything, just show what would be done.-n 参数不会真正移除任何东西，仅仅展示当前命令将要做的工作给你看。很有用的一个参数，可以让我们清晰的知道将要移除那些东西。 1234567891011121314# creating a new file test1.py on current clean working tree$ touch test1.py$ git status -s?? test1.py$ git clean -nWould remove test1.py# creating a new directory d1 and a new file test2.py in it$ mkdir d1$ touch d1/test2.py$ git status -s?? d1/?? test1.py$ git clean -nWould remove test1.py 一个很奇怪的现象：当新建一个空目录 (d1)，并在该目录下新建一个文件 (test2.py) 的时候，会发现该文件 (d1/test2.py) 不会被 git clean 移除！怎么回事？ -dRemove untracked directories in addition to untracked files.-d 参数不但会移除未跟踪的文件，还会移除未跟踪的目录。但是，如果未跟踪的目录被其它分支管理的话，将不会被移除。的确要移除只能够用 -f 强制性移除。接着上面的操作来看看： 123$ git clean -ndWould remove d1/Would remove test1.py 可以看到d1文件夹以及里面的内容都将会被移除。注意当文件夹里面有文件被跟踪的时候，这个目录实际上已经被跟踪了。 123456789$ touch d1/test3.py$ git add d1/test3.py$ git status -sA d1/test3.py?? d1/test2.py?? test1.py$ git clean -ndWould remove d1/test2.pyWould remove test1.py -f, --force-f参数会强制性执行移除操作。 -i, --interactiveShow what would be done and clean files interactively.-i会启动一个交互式的操作界面，你可以进一步确定那些东西要移除。 -x-x参数可以删除包括已经被.gitignore文件忽略的文件。接着上面的操作： 12345678910111213141516171819$ touch test4.py d1/test5.py$ git status -sA d1/test3.pyM .gitignore?? d1/test2.py?? d1/test5.py?? test1.py?? test4.py$ cat &lt;&lt;EOF &gt;&gt; .gitignoretest4.pyd1/test5.py$ git clean -n # the .gitignore files won't be removedWould remove d1/test2.pyWould remove test1.py$ git clean -nx # the .gitignore files will be removed tooWould remove d1/test2.pyWould remove d1/test5.pyWould remove test1.pyWould remove test4.py 可以看到git clean是不会移除 .gitignore 忽略的文件的，添加-x参数可以移除.gitignore忽略的文件。 -XRemove only files ignored by Git.仅仅移除被.gitignore文件忽略的文件。接着上面操作： 1234$ git clean -nX...Would remove d1/test5.pyWould remove test4.py","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"MySQL 修改数据库登录密码","slug":"mysql/mysql_change_password","date":"2015-09-01T16:00:00.000Z","updated":"2019-02-26T09:03:48.462Z","comments":true,"path":"2015/09/02/mysql/mysql_change_password/","link":"","permalink":"https://lizsgh.github.io/2015/09/02/mysql/mysql_change_password/","excerpt":"","text":"MySQL 的登录名和密码保存在名为 mysql 的数据库中的user表：User 和 Password。 首先，登录并且选择名为mysql的数据库。 12mysql -u root -pmysql&gt; use mysql; 更新 user 表中的 Password 1mysql&gt; UPDATE user SET Password=PASSWORD(&apos;新密码&apos;) WHERE User=&apos;用户名&apos;; Password 的值以加密的形式存储，password() 函数用于加密密码。 刷新 MySQL 的系统权限相关表1FLUSH PRIVILEGES; MySQL 用户数据和权限修改之后，希望在不重启 MySQL 服务的情况下直接生效，那么就需要执行这个命令。通常，在修改 root 账号的设置后，怕重启后无法再登录进来，FLUSH PRIVILEGES 之后就可以看设置是否生效，而不必冒太大风险。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://lizsgh.github.io/tags/mysql/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}]},{"title":"Vim usage","slug":"others/vim","date":"2015-08-31T16:00:00.000Z","updated":"2019-02-26T07:35:47.278Z","comments":true,"path":"2015/09/01/others/vim/","link":"","permalink":"https://lizsgh.github.io/2015/09/01/others/vim/","excerpt":"","text":"vim 配置 vim 配置文件： vim 首先读取当前用户的配置文件 ~/.vimrc，如果没有则读取 root 用户的配置文件/root/.vimrc。 在.vimrc文件中可以配置 vim 的永久属性。.vimrc 文件里面的注释用英文的双引号&quot;。 在文件编辑时，命令模式下可以配置 vim 的暂时属性，即关闭文件则失效。如给当前文件显示行号：:set nu 常见配置： set nu：添加行号。 set nonu：删除行号。 set tabstop=4：设置 Tab 键占 4 个空格。 set ai：自动换行。 vim 常见用法 :w：保存当前修改。 :w new_file：保存到新文件。当编辑没有权限的文件时，可以利用这个命令将当前修改保存到有权限的新文件中。 :w! exist_file：保存到已有文件。 :q：退出，当文件没有修改过的时候才有效，如果有修改过，需要保存退出或强制退出。 :wq, :x：退出，并保存修改。:wq，不管文件有没有修改，每次执行命令都会更新文件的修改时间；:x，当文件没有修改过的时候，直接退出，并不更新文件的修改时间。 :q!：强制退出，放弃修改。 查找 /word：从开头到结尾查找文件中的 “word”。 ?word：从结尾到开头查找文件中的 “word”。查看下一个，按n；上一个，按N。 替换在命令模式下，可以用 s 命令来替换字符串：: [option1]s/oldStr/newStr/[option2] [option2] 可以是 g c p g：表示全局替换 c：表示进行确认再替换 p：表示替换结果逐行显示（Ctrl + L 恢复屏幕） : s/oldStr/newStr/：替换当前行第一个 oldStr 字符串 : s/oldStr/newStr/g：替换当前行所有 oldStr 字符串 : m, ns/oldStr/newStr：替换从第 m 行到第 n 行中的第一个 oldStr 字符串 : n, $s/oldStr/newStr/g：替换从第 n 行到最后一行的所有 oldStr 字符串 : ., $s/oldStr/newStr/：替换从当前行到最后一行的第一个 oldStr 字符串 : %s/oldStr/newStr/g：替换每一行中所有的 oldStr 字符串 : %s/oldStr/newStr/c：替换每行中的第一个 oldStr 字符串，但是替换需要确认 : %s/oldStr/newStr/gc：替换所有的 oldStr 字符串，但是替换需要确认 可以使用 # 和 + 代替 / 作为分隔符，此时命令中出现的 / 将作为普通字符处理，如： : s#oldStr/#newStr#：替换当前行的 oldStr/ 字符串 : %s+/oldStr/+newStr：替换所有 /oldStr/ 字符串 跳到指定行 正常模式下，ngg 或 nG，n 为行号。如跳到 35 行，35gg。G 可以直接跳到最后一行。 命令模式下，:n 如果想打开文件即跳转，sudo vim +n file_name 复制一(n)行 正常模式下，复制光标所在的整行，yy；复制 n 行(从光标所在行开始)，nyy。 命令模式下，复制从第 n 行到 n + 5 行的内容到第 m 行后面 n, n+5 copy/co m 正常模式下，把光标移到要开始复制的那一行 ngg，然后，计算一下删除哪几行(如，n ～ n+5，包括n和n+5)，执行 d5（即删除第 n 到第 n+5 这 6 行）。删除完之后，恢复 u。将光标移到要粘贴的位置，p。 粘贴一行正常模式下，将复制到的内容粘贴到光标所在的行，p 删除一行正常模式下，删除光标所在的行，dd 删除多行正常模式下，删除光标所在的行开始的 n + 1 行，dn。n的值为最后一行的行号减去开始行的行号。 撤消在正常模式下,撤消上一步,u 恢复撤消在正常模式下,恢复撤消的内容,Ctrl + r 光标移动 h：向左；nh，向左移动 n 个字符。 j：向下；nj，向下移动 n 行。 k：向上；nk，向上移动 n 行。 l：向右。nl，向右移动 n 个字符。 w：向右移动到下个单词的首个字符处；nw，向右移动 n 个单词。 b：与 w 方向相反。 e：向右移动到下个单词的尾字符处；ne，向右移动 n 个单词。 ge：与 e 方向相反。 ^：光标移动到该行的第一个字符处（不包括空格）。 $：光标移动到该行的尾字符处。 0：光标移动到该行的行首。 ngg或nG：光标移动到 n 行的第一个字符上。 gg：移动到文件首行。 G：光标移动到文件末行。 Ctrl + f：向上翻页。 Ctrl + b 选择字符正常模式下，v，进入可视模式，然后通过光标移动来选择字符。 复制 y：复制选中的字符，选中字符可以在可视模式下，然后 hjkl 选择。 ye：复制当前光标位置到单词结尾的字符内容到 vim 缓冲区。nye，复制 n 个单词。 yw：复制当前光标位置到下个单词开头的字符内容到 vim 缓冲区。nyw，复制 n 个单词。 y^：复制当前光标位置到行首的内容到 vim 缓冲区。 y$：复制当前光标位置到行尾的内容到 vim 缓冲区。 yy：复制当前行的内容到 vim 缓冲区。nyy，复制 n 行。 复制第 m 行到第 n 行的内容到 vim 缓冲区：命令模式下，m, ny 复制第 m 行到第 n 行的内容到第 k 行后面：命令模式下，m, n copy/co k 以上复制，都是将内容复制到 vim 剪贴板，而且 vim 具有多个剪贴板，而我们平时操作的复制粘贴是将内容保存到系统的剪贴板。所以，当你想从另外的地方复制了一段内容（如，浏览器某个网址上复制一段内容）到当前 vim 来，是不能够直接用 p 来粘贴的。因为，p 命令是默认粘贴当前 vim 缓冲区的内容。 vim 中的剪贴板内容是保存在 register 中的，在 vim 命令模式下，可以用 reg 命令来查看 register 中的内容。 （ubuntu 16.04）我们可以看到，系统中复制的内容保存在 &quot;* 和 &quot;+ 的 register 中。所以，如果我们想要将系统剪贴板的内容粘贴到当前 vim，只需在粘贴命令前添加 register 标记就可以了。 &quot;*p或&quot;+p：将系统剪贴板的内容粘贴到光标后面。 &quot;*y或“+y：将当前 vim 中选中的内容复制到系统剪贴板中。 删除 (非插入模式下) x或d：删除当前光标下的字符。 dw：删除光标之后的单词剩余部分。 d$：删除光标之后的该行剩余部分。 dd：删除当前行。 dn：n为最后一行的行号减去开始行的行号的值，删除光标所在的行开始的 n + 1 行。 c：删除光标下的字符后，进入插入模式。 cc：删除当前行之后，进入插入模式。","categories":[{"name":"Others","slug":"Others","permalink":"https://lizsgh.github.io/categories/Others/"}],"tags":[{"name":"others","slug":"others","permalink":"https://lizsgh.github.io/tags/others/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"https://lizsgh.github.io/categories/Others/"}]},{"title":"PHP - 三元运算符 (?:)","slug":"php/php_三元运算符","date":"2015-08-31T16:00:00.000Z","updated":"2019-02-26T12:54:49.782Z","comments":true,"path":"2015/09/01/php/php_三元运算符/","link":"","permalink":"https://lizsgh.github.io/2015/09/01/php/php_三元运算符/","excerpt":"","text":"PHP 三元运算符 ?: 结合方向：自右往左 示例如 status 有值为 1，2 和 3 三种情况，分别对应 type 的值：C，PHP 和 Python。 错误做法：123456$type = $status == 1 ? &apos;C&apos; : $status == 2 ? &apos;PHP&apos; : &apos;Python&apos;; 无论 status 为任何值，得到的 type 的值都是 PHP。因为，PHP 三元运算符 ?: 的结合方向是自右往左。 即，上面的代码实际上是这样执行的： 12$type = ($status == 1 ? &apos;C&apos; : $status == 2) ? &apos;PHP&apos; : &apos;Python&apos;; 正确做法：123456$type = $status == 1 ? &apos;C&apos; : ($status == 2 ? &apos;PHP&apos; : &apos;Python&apos;);","categories":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"https://lizsgh.github.io/tags/php/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://lizsgh.github.io/categories/PHP/"}]},{"title":"lizsgh.github.io","slug":"others/lizsgh.github.io","date":"2015-05-31T16:00:00.000Z","updated":"2019-02-26T07:36:24.392Z","comments":true,"path":"2015/06/01/others/lizsgh.github.io/","link":"","permalink":"https://lizsgh.github.io/2015/06/01/others/lizsgh.github.io/","excerpt":"","text":"Github Pages 和 hexo 搭建个人博客。 Github PagesGithub Pages, Websites for you and your projects. 在 github 上创建名为username.github.io的仓库，其中username为你的 GitHub 账号名称。如我的 GitHub 账号为lizsgh，则创建仓库名为lizsgh.github.io。 在仓库根目录下添加 index.html 页面。这时候，我们登录 http://lizsgh.github.io 就可以看到 index.html 的内容。也就是说，我们可以通过http://lizsgh.github.io来访问这个仓库的静态页面内容。 Jekyll themes。Jekyll 是一个简单的、可扩展的、静态的网站生成器。GitHub Pages 可以选择 Jekyll theme 来作为网站的主题。设置方法：打开仓库，在setting中有一个GitHub Pages的设置选项，其中Theme Chooser可以选择 Jekyll theme 来作为网站的主题。Jekyll 的使用可以看文档：Jekyll Document CNAME。GitHub Pages 还可以让我们自己自定义网站的域名。同样在仓库setting的Github Pages设置选项中有一个Custom domain的选项，可以自定义网站的域名，如 www.lizs.cc。然后，在域名服务商平台将域名解析为 CNAME 类型，值为 lizsgh.github.io。生效之后，就可以通过 www.lizs.cc 来访问了。 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown (或其他渲染引擎) 解析文章，生成静态网页。 个人觉得 Hexo 比 Jekyll 简单好用点，所以抛弃了用 Jekyll theme 来作为 Github Pages 主题。 Hexo 安装前提：Node.js 和 Git。 安装 Hexo 1$ npm install -g hexo-cli 初始化一个 hexo 项目 123$ hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成之后，项目目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 创建文章 1$ hexo new [layout] [title] 如，hexo new test 就会在 source/_posts 目录下生成一篇名为 test.md 的文章。也可以直接在 source/_posts 下新建 test.md 文件来创建文章。 生成静态页面 1$ hexo generate 执行命令会生成一个 public 目录来存放生成的静态页面。如果生成静态页面之前想将之前版本的 public 删除，可以用 hexo clean 命令。 启动本地服务器 1$ hexo server 通过以上命令启动服务器，可以通过 http://localhost:4000/ 地址来访问。 部署到 GitHub Pages 首先，配置 _config.yml 文件 1234deploy: type: git repo: https://github.com/lizsGH/lizsgh.github.io.git branch: master 其中 repo 为你 GitHub Pages 仓库的地址。 然后执行部署命令 1$ hexo deploy 如果出现错误 ERROR Deployer not found: git，则需要安装 hexo-deployer-git 扩展： 1$ npm install hexo-deployer-git --save 自定义域名自定义 GitHub Pages 的域名只需要添加文件 source/CNAME: 1www.lizs.cc 然后，重新部署到 GitHub Pages 即可。 更多详细信息，可以参考 Hexo Document。","categories":[{"name":"Others","slug":"Others","permalink":"https://lizsgh.github.io/categories/Others/"}],"tags":[{"name":"others","slug":"others","permalink":"https://lizsgh.github.io/tags/others/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"https://lizsgh.github.io/categories/Others/"}]},{"title":"MySQL - SELECT","slug":"mysql/select","date":"2015-04-04T16:00:00.000Z","updated":"2019-02-26T08:57:36.299Z","comments":true,"path":"2015/04/05/mysql/select/","link":"","permalink":"https://lizsgh.github.io/2015/04/05/mysql/select/","excerpt":"","text":"select 的 5 种子句: where：条件查询 group by：分组 having：筛选 order by：排序 limit：限制结果条数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748where where 条件where常用运算符： =：等于 &lt;：小于 &gt;：大于 &lt;=：小于或等于 &gt;=：大于或等于 != 或 &lt;&gt;：不等于 in：在某集合内 between：在某范围内where逻辑运算符： and 或 &amp;&amp;：与 or 或 ||： 或 not 或 !： 非 in：在某集合内，是对一个集合来操作的。而between对某个范围内的。in(值1，值2...值n)//查询goods中id等于3、5或者6的商品select id,name,price from goods where id in(3,5,6);between 值1 and 值2//查询goods中id在3-6这个范围的上面select id,name,price from goods where id between 3 and 6;或者：select id,name,price from goods where id&gt;=3 and id&lt;=6;优先级别：not &gt; and &gt; or//查询2-4和5-7的商品select * from goods where id&gt;=2 and id&lt;=4 or id&gt;=5 and id&lt;=7;//not可以和in一起用select * from goods where id not in(4,5);等于：select * from goods where id!=4 and id!=5;模糊查询 like %：通配任意字符 _：通配单个字符 注意，如果想要模糊查询，但是又没有通配符的时候，查询语句是没有报错的，但是，查询的结果可能是空的。如，select goods_id,goods_name from goods where goods_name like &apos;诺基亚&apos;;Empty set (0.00sec)//查询结果是空的，因为good_name中有“诺基亚”的商品都是有后缀的，没有单独的诺基亚商品，如诺基亚N85、诺基亚N96、诺基亚耳机等等。所以，要加通配符//查询任意字符用%，如查询有“诺基亚”的所有商品select goods_id, goods_name from goods where goods_name like &apos;诺基亚%&apos;//查询诺基亚N系列而且N后面是两个字符的商品，也就是Nxx系列。select goods_id, goods_name from goods where goods_name like &apos;诺基亚N__&apos; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051group by 作用：把行按字段分组 max：求最大 min：求最小 sum：求总和 avg：求平均 count：求总行数//查询shop_price最大的商品的价格select max(shop_price) from goods;//下面的语句是没有意义的select goods_id, goods_name max(goods_price) from goods; 因为，goods_id和goods_name是第一列的值，而goods_price是最大值。查询出来的结果goods_id、goods_name和goods_price是不搭配的。//查询每个商品所积压的货款select goods_id, goods_name, goods_number*shop_price from goods;//查询该商店积压的总货款select sum(goods_number*shop_price) from goods; 我们的商品不但有goods_id号还有栏号cat_id，如果我们想查出每一栏目中价格最贵的商品，怎么查select cat_id, max(shop_price) from goods group by cat_id; 如果加good_id，goodd_id也是没有意义的。//按栏目查询最便宜的商品select cat_id, min(shop_price) from goods group by cat_id;//按栏目查询商品平均价格，也就是每一栏的平均价格select cat_id, avg(shop_price) from goods group by cat_id;//按栏目查询商品种类，也就是每个栏目下的商品种类select cat_id, count(*) from goods group by cat_id;//查询商品的平均价格select avg(good_price) from goods;//查询所有商品的数量，也就是求有多少行select count(*) from goods; 我们要养成一种思想：把列当成变量来看。//查询出本店每个商品比市场价格低多少钱select goods_id, goods_name, market_price - shop_price from goods; 注意，显示出来的结果是会有market_price - shop_price这一列的。//查询每个栏目下积压的货款，也就是库存*价格select cat_id, sum(shop_price*good_number) from goods group by cat_id; 我们可以看到查询结果有sum(shop_price*goods_number)这一列，不过列名实在是有点长，这时候，我们可以起一个别名，用as。select cat_id, sum(shop_price*good_number) as hk from goods group bycat_id; 这时候，我们查询结果看到的就是hk这一列代表积压货款。 1234567891011121314151617181920212223242526272829having//查询出本店价格比市场价格低多少钱，并且把低200元以上的商品选出来//查询出本店价格比市场价格低多少钱，我们可以这样实现select goods_id, goods_name, sum(market_price-goods_price) as cheap from goods;//当你还想要把低于200元以上的商品选出来的时候，我们首先想到的是用where条件来实现，即select goods_id, goods_name, sum(market_price-goods_price) as cheap from goods where cheap&gt;200;结果：ERROR 1054 &lt;42S22&gt;: Unkown column &apos;cheap&apos; in &apos;where clause&apos; 注意，这样是不能够实习的！因为，where是对表起作用的，而不是对查询到的结果起作用。那么，我们要怎么样才能够实现：查询出本店价格比市场价格低多少钱，并且把低于200元以上的商品选出来呢？ 方法一：select goods_id, goods_name, sum(market_price-goods_price) as cheap from goods where market_price-goods_price&gt;200; 这种方法可以实现，不过查询的时候计算了两次。注意，结果显示的是cheap列，而不是market_price-goods_price列。 方法二： having，可以筛选查询的结果。select goods_id, goods_name, sum(market_price-goods_price) as cheap from goods having cheap&gt;200;//当一条语句有where和having，where在前//查询本店价格比市场价格低多少钱，并且把第3个栏目下比市场价格低于200元以上的商品选出来select goods_id, cat_id, goods_name, sum(market_price-goods_price) as cheap from goods where cat_id=3 having cheap&gt;200;//查询积压货款超过2W元的栏目，以及该栏目积压的货款//先查询栏目积压的货款select cat_id, sum(goods_number*shop_price) as jyhk from goods group by cat_id;//然后用having jyhk&gt;2W筛选积压货款超过2W的栏目select cat_id, sum(goods_number*shop_price) as jyhk from goods group by cat_id having jyhk&gt;2W; 总结：where针对表中的列发挥作用，查询数据；having针对查询结果中的列发挥作用，筛选数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126练习：设有成绩表grades如下：姓名：张三 张三 张三 李四 李四 王五科目：数学 语文 地理 语文 政治 政治分数： 90 50 40 55 45 30 查询两门及两门以上不及格同学的平均分。要求只用一个select。//先创建表gradescreate table grades (name varchar(10) not null default &apos;&apos;,subject varchar(10) not null default &apos;&apos;,score tinyint not null default 0);//插入数据insert into gradesvalues(&apos;张三&apos;, &apos;数学&apos;, 90),(&apos;张三&apos;, &apos;语文&apos;, 50),(&apos;张三&apos;, &apos;地理&apos;, 40),(&apos;李四&apos;, &apos;语文&apos;, 55),(&apos;李四&apos;, &apos;政治&apos;, 45),(&apos;王五&apos;, &apos;政治&apos;, 30);mysql&gt; select * from grades;+--------+---------+-------+| name | subject | score |+--------+---------+-------+| 张三 | 数学 | 90 || 张三 | 语文 | 50 || 张三 | 地理 | 40 || 李四 | 语文 | 55 || 李四 | 政治 | 45 || 王五 | 政治 | 30 |+--------+---------+-------+6 rows in set (0.00 sec)//先求每个人成绩的平均分mysql&gt; select name, avg(score) from grades group by name;+--------+------------+| name | avg(score) |+--------+------------+| 张三 | 60.0000 || 李四 | 50.0000 || 王五 | 30.0000 |+--------+------------+3 rows in set (0.10 sec)//再查找有两门及两门以上不及格的同学select name, count(score&lt;60) as fail from grades group by name having fail&gt;=2;+--------+------+| name | fail |+--------+------+| 张三 | 3 || 李四 | 2 |+--------+------+2 rows in set (0.04 sec)//最后，合成一条select语句select name, avg(score), count(score&lt;60) as fail from grades group by name having fail&gt;=2;+--------+------------+------+| name | avg(score) | fail |+--------+------------+------+| 张三 | 60.0000 | 3 || 李四 | 50.0000 | 2 |+--------+------------+------+2 rows in set (0.00 sec) 注意，这种做法看上去像是对的。其实，这是错误的做法。因为，查询结果显示张三挂了3科，其实他只挂了2科。count是计算所有行数，它不论大于还是小于60分的都计算了的。我们可以验证一下：insert into gradesvalues(&apos;赵六&apos;, &apos;语文&apos;,99),(&apos;赵六&apos;, &apos;数学&apos;,98),(&apos;赵六&apos;, &apos;政治&apos;,97);mysql&gt; select * from grades;+--------+---------+-------+| name | subject | score |+--------+---------+-------+| 张三 | 数学 | 90 || 张三 | 语文 | 50 || 张三 | 地理 | 40 || 李四 | 语文 | 55 || 李四 | 政治 | 45 || 王五 | 政治 | 30 || 赵六 | 语文 | 99 || 赵六 | 数学 | 98 || 赵六 | 政治 | 97 |+--------+---------+-------+9 rows in set (0.00 sec)select name, avg(score), count(score&lt;60) as fail from grades group by name having fail&gt;=2;+--------+------------+------+| name | avg(score) | fail |+--------+------------+------+| 张三 | 60.0000 | 3 || 李四 | 50.0000 | 2 || 赵六 | 98.0000 | 3 |+--------+------------+------+3 rows in set (0.00 sec) 我们可以看到count(score&lt;60)并不是计算score&lt;60的行数，而是计算所有行的行数。因为select name, score&lt;60 from grades;+--------+----------+| name | score&lt;60 |+--------+----------+| 张三 | 0 || 张三 | 1 || 张三 | 1 || 李四 | 1 || 李四 | 1 || 王五 | 1 || 赵六 | 0 || 赵六 | 0 || 赵六 | 0 |+--------+----------+9 rows in set (0.00 sec) score&lt;60的值不是0就是1，因为，score&lt;60不是真就是假的。但是，无论是0还是1，score&lt;60都有一行，而count(score&lt;60)是计算score&lt;60的行数。 所以，我们可以计算score&lt;60的值为1的行数来查看不及格的门数。select name, avg(score), sum(score&lt;60) as fail from grades group by name having fail&gt;=2;+--------+------------+------+| name | avg(score) | fail |+--------+------------+------+| 张三 | 60.0000 | 2 || 李四 | 50.0000 | 2 |+--------+------------+------+2 rows in set (0.02 sec) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162order by order by：排序功能，按一个或多个字段对查询结果进行排序，可以是升序排序，也可以是降序排序，默认是升序排序。select goods_id, cat_id, goods_name, shop_price from goods where cat_id=3order by shop_price; 这条语句查询显示的结果是按照shop_price的值由小到大排序的(默认升序)，如果我们想查询结果由降序排序，要怎么做呢？可以在后面加上字段名desc。 desc：按降序排序； asc：按升序排序(默认也是升序排序，所以可以不加)select goods_id, cat_id, goods_name, shop_price from goods where cat_id=3 order by shop_price desc;//查询栏目号从低到高，而且栏目内的商品价格从高到低的排序结果select goods_id, cat_id, goods_name, shop_price from goods where goods_id&lt;50 order by cat_id, shop_price desc; //先按cat_id排序，再在栏目内按shop_price从高到低排序//按发布时间从早到晚排序(发布时间add_time是用时间戳来存储的)select goods_id, goods_name, add_time from goods order by add_time; 我们可以看到add_time的值是int型的，表示1970-01-01 00:00:00 到当前的秒数。 我们可以按字段排序，查询显示的结果是符合条件所有行的数据。如果我们只是想要显示排序之后的某几行，又要怎么做呢？limit语句可以帮我们实现。 limit [offset] [n] offset：偏移量，offset如果不写，则相当于0，即limit 0, n。所以，是从第offset+1个开始。如limit 3,2 表示偏移前3个，从第4个开始选择2个，即4、5 n：取出的条目//取出商品价格最贵的3个商品的信息select goods_id, cat_id, goods_name，shop_price from goods order by shop_price desc limit 3;//取出最新发布的商品select goods_id, cat_id, goods_name, add_time, shop_price from goods order by add_time desc limit 1;//取出每个栏目下最贵的商品错误一：select goods_id, cat_id, goods_name, max(shop_price) from goods; 这种做法查出来的是的确是shop_price最大的商品，不过shop_price不一定是和前面的goods_id, cat_id, goods_name是对应的。错误二：select goods_id, cat_id, goods_name, shop_price from goods group by cat_id order by shop_price desc; 这种做法也能查出每个栏目下的一个商品来，不过这个商品不一定是每个栏目下最贵的商品，这个商品只是每个栏目下的第一个商品。仔细观察我们可以发现查询结果中shop_price列的价格是按照从大到小来排序的，这就说明了，这条语句查询的结果是把每个栏目下的第一个商品拿出来，后面的order by shop_price desc实现的是对拿出来的每个栏目下的第一个商品按照shop_price从大到小排序。错误三： 根据上面的做法，有的同学就会想到：如果我先实现 order by shop_price desc 再来实现group by不就行了吗。select goods_id, cat_id, goods_name, shop_price from goods order byshop_price desc group by cai_id; 这种做法也一样是不正确的，因为： select的5种子句：where、group by、having、order by、limit是按照顺序来使用的，不能把后面的子句放到前面来先使用。错误四： 有的同学可能会想，我先构造一张表goods1，表里面的数据是按照order by cat_id asc，shop_price desc顺序排列的，然后，再调用group by来取出每个栏目下的第一个商品不就行了吗。//创建表goods1create lzs.goods1 like goods;//将表goods的数据按照order by cat_id，shop_price desc顺序保存到goods1insert into goods1 select * from goods order by cat_id, shop_price desc;//最后，用group by取出每个栏目下的第一个商品就可以了select goods_id, cat_id, goods_name, shop_price from goods1 group by cat_id; 这种做法也是错误的，因为在将表goods的数据按照order by cat_id asc，shop_price desc顺序存进goods1的时候，保存进goods1的数据根本就没有按照想要的顺序排序，而是按照goods原来的顺序保存进来的。所以，最后group by取出来的数据还是不对的。 其实，我们不用创建一张新表，因为查询的结果本来就可以在内存中当作表来使用，所以我们可以这样实现：select * from (selcet goods_id, cat_id, goods_name, shop_price from goods order by cat_id asc, shop_price desc) as goods1 group by cat_id; 这种做法是from型子查询，但是，如果要求只用一个select，又要怎么去实现呢？ 1234良好的理解模型： where 表达式：把表达式放在行中，看表达式是否为真 列：理解成变量，可以运算 取出结果：可以理解成一张临时表 12345678910111213141516171819202122232425262728293031323334353637383940子查询 where型子查询：把内层查询的结果作为外层查询的比较条件 from型子查询：把内层查询的结果当成临时表，供外层再次查询 exists型子查询：把外层的查询结果，拿到内层，看内层的查询是否成立//查询最新的商品(以id最大为最新)select goods_id, cat_id, goods_name from goods order by goods_id desc limit 1; 如果，不能用order by呢？又要怎么做？我们可以用where子查询来实现：select goods_id, cat_id, goods_name from goods where goods_id = (selectmax(goods_id) from goods);//查询每个栏目下最贵的商品select goods_id, cat_id, goods_name shop_price from goods where shop_price in(select max(shop_price) from goods group by cat_id)//上面我们用from型子查询是这样实现的：select * from (select goods_id, cat_id, goods_name, shop_price from goods order by shop_price desc) as goods1 group by cat_id; from型子查询，是先select内层order by shop_price desc查询的结果，然后利用group by cat_id来取出第一个。注意，from型子查询必须要给内层查询的结果加上一个别名。 而where型子查询，是选出每栏目下max(shop_price)的商品，如果一个栏目下有几个商品都是同价格的而且还是最贵的，这几个商品都是内层查询的结果来的，都是在in里面的值。所以，都是可以查询出来的。//利用上面的grades表，如何用子查询查出挂科两门及两门以上同学的平均分//不用子查询select name, avg(score), sum(score&lt;60) as fail from grades group by name having fail&gt;=2;//子查询//先查出挂机两门及两门以上的同学select name, sum(score&lt;60) as fail from grades group by name having fail&gt;=2;//不过，我们要的只是name，所以，还要选出name来：select name from (select name, sum(score&lt;60) as fail from grades group by name having fail&gt;=2);//最后根据名字查找平均分select name, avg(score) from grades where name in(select name from (select name, sum(score&lt;60) as fail from grades group by name having fail&gt;=2) as tmp) group by name; 注意，from型子查询必须要给内层查询的结果加上一个别名，所以，要as tmp//或者select name, avg(score) from grades where name in(select name from (select name, count(*) as fail from grades where score&lt;60 group by name having fail&gt;=2) as tmp) group by name;//查询有商品的栏目(栏目表名category)//我们先看一下，下面这条语句实现的是什么select cat_id, cat_name from category where exists(select * form goods); 显示的结果是：所有的cat_id，cat_name。因为，只要goods里面有内容，exists(select * from goods)就会为真，显示的结果就是所有的cat_id和cat_name。那么如果要查询有商品的栏目，我们只要将exists里面的判断设置为有商品就为真就可以了。select cat_id, cat_name from category where exists(select * from goods where goods.cat_id=category.cat_id); exists(select * from goods where goods.cat_id=category.cat_id)的意思是，只要商品表goods里面有栏目表category相等的id就表示，有商品里面有该栏目的商品。 12345678910111213141516171819202122232425262728293031select的5中子句的总结： where 表达式 表达式在哪一行成立，哪一行就取出来 where常用运算符：=，!=/&lt;&gt;，&lt;，&gt;，&lt;=，&gt;=，in()，between and where逻辑运算符：and、or、not 模糊查询：like 通配符：%，任意字符；_，单个字符 group by： 分组，一般和统计函数配合使用 常用的统计函数：max()，min()，avg()，sum()，count() having 表达式 数据在表中，表在硬盘或者内存以文件形式存在。 查询出的结果，也可以看成一张表，其文件一般临时存放在缓冲区。 where，针对表文件发挥作用； having，针对查询结果发挥作用。 order by： 作用：对字段排序，可以升序asc，也可以降序desc。 有可能一个字段排不出结果，可以选用其它字段继续排序: order by 字段1[asc/desc]， 字段2[asc/desc] ... 如，order by cat_id, shop_price desc limit： 作用：限制条目 limit [offset] n offset：偏移量，不填就是默认0 n：限制取出的条目数量 如，取出shop_price最贵的3个商品： ... order by shop_price desc limit 3; 1234567891011121314151617select的子查询 where型子查询： 内层的查询结果作为外层查询的比较条件 例如，查询最新商品(以goods_id最大为最新) select * from goods where goods_id = 最大的goods_id； select * from goods where goods_id = (select max(goods_id) from goods); from型子查询： 把内层的查询结果供外层再次查询。 注意，内层的查询结果看成临时表，要加&apos;as 临时表名&apos; exists型子查询： 把外层的查询结果代入到内层，看内层是否成立。 例如，查询有商品的栏目 select cat_id, cat_name from category where exists(select * from goods.cat_id=category.cat_id); 如果select * from goods where goods.cat_id;的结果有值就说明 cat_id 有商品。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://lizsgh.github.io/tags/mysql/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}]},{"title":"MySQL - Column types","slug":"mysql/column_types","date":"2015-04-03T16:00:00.000Z","updated":"2019-02-26T08:59:13.326Z","comments":true,"path":"2015/04/04/mysql/column_types/","link":"","permalink":"https://lizsgh.github.io/2015/04/04/mysql/column_types/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403 MySQL三大列类型：数值型、字符串型、日期时间类型。ggj一、数值型：1、整形：（默认是有符号） tinyint：1字节，8位。无符号：0-255 有符号(0正1负)：-128- 127 smallint：2字节，16位。无符号：0-2^16-1 有符号：-2^15- 2^15-1 mediumint：3字节，24位。 int：4字节，32位。 bigint：8字节，64位。 整形列的可选属性：(默认有符号) 类型(M) unsigned/zerofill M：宽度(在0填充的时候才有意义) unsigned：无符号类型(非负) zerofill：0填充(默认无符号)mysql&gt; create table class ( -&gt; id int primary key auto_increment, -&gt; name varchar(10), -&gt; age tinyint -&gt; ) charset utf8;Query OK, 0 rows affected (0.32 sec)mysql&gt; show tables;+---------------+| Tables_in_lzs |+---------------+| class || messages || shop |+---------------+3 rows in set (0.00 sec)mysql&gt; desc class;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(10) | YES | | NULL | || age | tinyint(4) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+3 rows in set (0.03 sec)mysql&gt; insert into class -&gt; (name, age) -&gt; values -&gt; (a, 1), -&gt; (b,2);ERROR 1054 (42S22): Unknown column &apos;a&apos; in &apos;field list&apos;//varchar型要用单引号括起来mysql&gt; insert into class -&gt; (name, age) -&gt; values -&gt; (&apos;a&apos;, 1), -&gt; (&apos;b&apos;,2);Query OK, 2 rows affected (0.06 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from class;+----+------+------+| id | name | age |+----+------+------+| 1 | a | 1 || 2 | b | 2 |+----+------+------+2 rows in set (0.00 sec)//增加一列，age1，类型是tinyint unsignedmysql&gt; alter table class -&gt; add -&gt; age1 tinyint unsigned;Query OK, 0 rows affected (0.62 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc class;+-------+---------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+---------------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(10) | YES | | NULL | || age | tinyint(4) | YES | | NULL | || age1 | tinyint(3) unsigned | YES | | NULL | |+-------+---------------------+------+-----+---------+----------------+4 rows in set (0.01 sec)mysql&gt; delete from class where id=2;Query OK, 1 row affected (0.07 sec)mysql&gt; select * from class;+----+------+------+------+| id | name | age | age1 |+----+------+------+------+| 1 | a | 1 | NULL |+----+------+------+------+1 row in set (0.00 sec)mysql&gt; insert into class -&gt; (name, age) -&gt; values -&gt; (&apos;b&apos;, 2);Query OK, 1 row affected (0.06 sec)mysql&gt; select * from class;+----+------+------+------+| id | name | age | age1 |+----+------+------+------+| 1 | a | 1 | NULL || 3 | b | 2 | NULL |+----+------+------+------+2 rows in set (0.00 sec)mysql&gt; update class set -&gt; id=id-1 -&gt; where id&gt;1;Query OK, 1 row affected (0.17 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from class;+----+------+------+------+| id | name | age | age1 |+----+------+------+------+| 1 | a | 1 | NULL || 2 | b | 2 | NULL |+----+------+------+------+2 rows in set (0.00 sec)mysql&gt; insert into class -&gt; (name, age1) -&gt; values -&gt; (&apos;c&apos;, 3);Query OK, 1 row affected (0.03 sec)mysql&gt; select * from class;+----+------+------+------+| id | name | age | age1 |+----+------+------+------+| 1 | a | 1 | NULL || 2 | b | 2 | NULL || 4 | c | NULL | 3 |+----+------+------+------+3 rows in set (0.00 sec)mysql&gt; alter table class add age2 tinyint(5) zerofill;Query OK, 0 rows affected (0.38 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc class;+-------+------------------------------+------+-----+---------+| Field | Type | Null | Key | Default |+-------+------------------------------+------+-----+---------+| id | int(11) | NO | PRI | NULL || name | varchar(10) | YES | | NULL || age | tinyint(4) | YES | | NULL || age1 | tinyint(3) unsigned | YES | | NULL || age2 | tinyint(5) unsigned zerofill | YES | | NULL |+-------+------------------------------+------+-----+---------+5 rows in set (0.01 sec)mysql&gt; insert into class -&gt; (name, age2) -&gt; values -&gt; (&apos;d&apos;, 4);Query OK, 1 row affected (0.03 sec)mysql&gt; select * from class;+----+------+------+------+-------+| id | name | age | age1 | age2 |+----+------+------+------+-------+| 1 | a | 1 | NULL | NULL || 2 | b | 2 | NULL | NULL || 4 | c | NULL | 3 | NULL || 5 | d | NULL | NULL | 00004 | //5位，自动填充0+----+------+------+------+-------+4 rows in set (0.02 sec)mysql&gt; alter table class add age3 tinyint(1) zerofill;Query OK, 0 rows affected (0.41 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc class;+-------+------------------------------+------+-----+---------+| Field | Type | Null | Key | Default |+-------+------------------------------+------+-----+---------+| id | int(11) | NO | PRI | NULL || name | varchar(10) | YES | | NULL || age | tinyint(4) | YES | | NULL || age1 | tinyint(3) unsigned | YES | | NULL || age2 | tinyint(5) unsigned zerofill | YES | | NULL || age3 | tinyint(1) unsigned zerofill | YES | | NULL |+-------+------------------------------+------+-----+---------+6 rows in set (0.01 sec)mysql&gt; insert into class -&gt; (name, age3) -&gt; values -&gt; (&apos;e&apos;, 5);Query OK, 1 row affected (0.07 sec)mysql&gt; select * from class;+----+------+------+------+-------+------+| id | name | age | age1 | age2 | age3 |+----+------+------+------+-------+------+| 1 | a | 1 | NULL | NULL | NULL || 2 | b | 2 | NULL | NULL | NULL || 4 | c | NULL | 3 | NULL | NULL || 5 | d | NULL | NULL | 00004 | NULL || 6 | e | NULL | NULL | NULL | 5 | //zerofill，0填充1位+----+------+------+------+-------+------+5 rows in set (0.00 sec)mysql&gt; insert into class -&gt; (name, age3) -&gt; (&apos;f&apos;, 255); //age3是tinyint(1) zerofill，0填充1位，只是填充效果，不影响数据的填充，一样是可以执行的mysql&gt; alter table class add age4 tinyint(1);Query OK, 0 rows affected (0.46 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc class;+-------+------------------------------+------+-----+---------+| Field | Type | Null | Key | Default |+-------+------------------------------+------+-----+---------+| id | int(11) | NO | PRI | NULL || name | varchar(10) | YES | | NULL || age | tinyint(4) | YES | | NULL || age1 | tinyint(3) unsigned | YES | | NULL || age2 | tinyint(5) unsigned zerofill | YES | | NULL || age3 | tinyint(1) unsigned zerofill | YES | | NULL || age4 | tinyint(1) | YES | | NULL |+-------+------------------------------+------+-----+---------+7 rows in set (0.01 sec)mysql&gt; insert into class -&gt; (name, age4) -&gt; values -&gt; (&apos;f&apos;, 16); //tinyint(1)后面的1在0填充时才有意义Query OK, 1 row affected (0.07 sec)mysql&gt; select * from class;+----+------+------+------+-------+------+------+| id | name | age | age1 | age2 | age3 | age4 |+----+------+------+------+-------+------+------+| 1 | a | 1 | NULL | NULL | NULL | NULL || 2 | b | 2 | NULL | NULL | NULL | NULL || 4 | c | NULL | 3 | NULL | NULL | NULL || 5 | d | NULL | NULL | 00004 | NULL | NULL || 6 | e | NULL | NULL | NULL | 5 | NULL || 7 | f | NULL | NULL | NULL | NULL | 16 |+----+------+------+------+-------+------+------+6 rows in set (0.00 sec)//我们可以看到很多没有填充的值都是NULL，因为Default默认是NULL值。//我们可以设置默认值，not NULL default 某值mysql&gt; alter table class add age5 tinyint not null default 0;Query OK, 0 rows affected (0.47 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; select * from class;+----+------+------+------+-------+------+------+------+| id | name | age | age1 | age2 | age3 | age4 | age5 |+----+------+------+------+-------+------+------+------+| 1 | a | 1 | NULL | NULL | NULL | NULL | 0 || 2 | b | 2 | NULL | NULL | NULL | NULL | 0 || 4 | c | NULL | 3 | NULL | NULL | NULL | 0 || 5 | d | NULL | NULL | 00004 | NULL | NULL | 0 || 6 | e | NULL | NULL | NULL | 5 | NULL | 0 || 7 | f | NULL | NULL | NULL | NULL | 16 | 0 || 8 | f | NULL | NULL | NULL | NULL | 16 | 0 || 9 | f | NULL | NULL | NULL | 16 | NULL | 0 |+----+------+------+------+-------+------+------+------+8 rows in set (0.00 sec)mysql&gt; update class set -&gt; id=id-1 -&gt; where id&gt;2;Query OK, 6 rows affected (0.03 sec)Rows matched: 6 Changed: 6 Warnings: 0mysql&gt; select * from class;+----+------+------+------+-------+------+------+------+| id | name | age | age1 | age2 | age3 | age4 | age5 |+----+------+------+------+-------+------+------+------+| 1 | a | 1 | NULL | NULL | NULL | NULL | 0 || 2 | b | 2 | NULL | NULL | NULL | NULL | 0 || 3 | c | NULL | 3 | NULL | NULL | NULL | 0 || 4 | d | NULL | NULL | 00004 | NULL | NULL | 0 || 5 | e | NULL | NULL | NULL | 5 | NULL | 0 || 6 | f | NULL | NULL | NULL | NULL | 16 | 0 || 7 | f | NULL | NULL | NULL | NULL | 16 | 0 || 8 | f | NULL | NULL | NULL | 16 | NULL | 0 |+----+------+------+------+-------+------+------+------+8 rows in set (0.00 sec)2、小数型： 浮点型：float(M,D) 定点型：decimal(M,D) //定点型更精确 M：精度(总位数，不包含点) D：标度(小数位) 同样，小数型也是有unsigned型的。 float和double容易产生误差，对精确度要求比较高时，建议使用decimal来存放，decimal在mysql内存是以字符串存储的，用于定义货币要求精确度高的数据。在数据迁移中，float(M,D)是非标准定义，最好不要这样使用。M为精度，D为标度。 float和real数据类型被称为近似的数据类型。不存储精确值.当要求精确的数字状态时，比如在财务应用程序中，在那些需要舍入的操作中，或在等值核对的操作中，就不使用这些数据类型。这时就要用integer、decimal、money或smallmone数据类型。 在 WHERE 子句搜索条件中(特别是 = 和 &lt;&gt; 运算符)，应避免使用float或real列。最好限制使用float和real列做&gt; 或 &lt; 的比较。mysql&gt; create table goods ( -&gt; id tinyint(3) zerofill primary key auto_increment, -&gt; name varchar(10) not null default &apos;&apos;, -&gt; price float(5.2) not null default 0.00, -&gt; decprice decimal(5.2) not null default 0.00 -&gt; )charset utf8;Query OK, 0 rows affected (0.36 sec)mysql&gt; desc goods;+----------+------------------------------+------+-----+---------+| Field | Type | Null | Key | Default |+----------+------------------------------+------+-----+---------+| id | tinyint(3) unsigned zerofill | NO | PRI | NULL || name | varchar(10) | NO | | || price | float | NO | | 0 || decprice | decimal(5,0) | NO | | 0 |+----------+------------------------------+------+-----+---------+4 rows in set (0.05 sec)二、字符型： char：定长类型，1字节。 char(M)，0&lt;=M&lt;=255，当存入N个字符小于M个字符时，实占M个字符空间，会在N个字符后面加空格补齐。所以，对定长char而言，如果存入的字符最后有空格字符，取出来的时候，空格字符会被当作是填充的，空格字符就会丢失掉。但是，varchar类型不会丢掉，varchar会取存入的个数。 varchar：变长类型，2字节。 varchar(M)，0&lt;=M&lt;=65535（以ascii字符为例，utf8是22000左右），当存入小于M个字符时，实占存入字符个数的字符空间。 text：文本类型。 text，不用加默认值(加了也是无效的).可以存放比较大的文本段，约2W-6W个字符(受字符集影响)。因此，如果不是特别大的内容，建议使用char、varchar。mysql&gt; alter table student -&gt; add -&gt; essay text not null default &apos;&apos;; //添加默认值会失败ERROR 1101 (42000): BLOB/TEXT column &apos;essay&apos; can not have a default value.mysql&gt; create table student ( -&gt; id tinyint(3) zerofill primary key auto_increment, -&gt; firstname char(8) not null default &apos;&apos;, -&gt; lastname varchar(8) not null default &apos;&apos; -&gt; );Query OK, 0 rows affected (2.08 sec)mysql&gt; desc student;+-----------+------------------------------+------+-----+---------+| Field | Type | Null | Key | Default |+-----------+------------------------------+------+-----+---------+| id | tinyint(3) unsigned zerofill | NO | PRI | NULL || firstname | char(8) | NO | | || lastname | varchar(8) | NO | | |+-----------+------------------------------+------+-----+---------+3 rows in set (0.38 sec)mysql&gt; insert into student -&gt; (firstname, lastname) -&gt; values -&gt; (&apos;first&apos;, &apos;last&apos;), -&gt; (&apos;first &apos;, &apos;last &apos;);Query OK, 2 rows affected (0.14 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from student;+-----+-----------+----------+| id | firstname | lastname |+-----+-----------+----------+| 001 | first | last || 002 | first | last |+-----+-----------+----------+2 rows in set (0.00 sec)mysql&gt; select concat(firstname, &apos;!&apos;), concat(lastname, &apos;!&apos;) from student+------------------------+-----------------------+| concat(firstname, &apos;!&apos;) | concat(lastname, &apos;!&apos;) |+------------------------+-----------------------+| first! | last! || first! | last ! |+------------------------+-----------------------+2 rows in set (0.03 sec)三、日期时间类型： year：年类型，1字节，一共可以表示256种年份：0000、1901-2155。(0000，表示不输人或者选择错误)。 年份一般是4位的，但是，以前有用2位来表示年份的，如97，表示1997年。但是如果输入的是10呢？1910？2010？还是2110？所以，当输入2位的时候： 00-69：表示2000-2069； 70-99：表示1970-1999 date：日期类型，典型格式：如，1991-04-02。范围：1000-01-01- 9999-12-31 time：时间类型，典型格式： hh:mm:ss datetime：日期时间类型，典型格式：如1991-04-02 15:23:23 范围：1000-01-01 00:00:00 - 9999-12-31 23:59:59 注意：在开发中，很少用日期时间类型来表示一个需要的精确到秒的列。一般用时间戳来表示。 时间戳：用int型来存储，表示1970-01-01 00:00:00 到当前的秒数。 一般存注册时间、商品发布时间等，并不是用datetime存储，而是用时间戳。因为，datetime虽然直观，但是计算不方便。而用int型存储时间戳，方便计算，对于显示，也可以方便格式化成不同的显示样式。 在MySQL中提供了当前时间的函数：now()","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://lizsgh.github.io/tags/mysql/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}]},{"title":"MySQL - CURD/CRUD","slug":"mysql/CURD","date":"2015-04-02T16:00:00.000Z","updated":"2019-02-26T09:01:10.131Z","comments":true,"path":"2015/04/03/mysql/CURD/","link":"","permalink":"https://lizsgh.github.io/2015/04/03/mysql/CURD/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536DATABASE show databases; create database DBName; drop database DBName; (&apos;Can not alter DBName&apos;) use DBName;TABLE show tables; create table tableName ( C1Name C1Type [C1Attribute] [Default Value], ... CnName CnType [CnAttribute] [Default Value] (&apos;the last column can not add comma&apos;) ) enqine enqineName charset charType; drop table tableName; rename table oldName to newName; desc tableName; // check the table structure insert into tableName (column1, column2, ...) [option] values (column1, column2, ... ); select (column) from table; update tableName set column1 = value1, ... columnN = valueN // the last column can not add comma where conditions; delete from tableName where conditions; (&apos;NOTE: can not delete column. If you want to delete certain column, It is the same as updating the column with value &apos;&apos; &apos;) 1234567891011121314151、连接服务器了就可以查看有哪些数据库： show databases; ---&gt;注意，MySQL语句是以分号结束的！mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+--------------------+information_schema：数据库的基本信息；mysql：用户信息；如，rootperformance_schema：性能优化的信息； 上面的3个数据库是不能够随便修改的，如果更改了上面的3个数据库服务器就起不来了。 12345678910111213141516172、创建数据库： create database DBName;mysql&gt; create database lzs;Query OK, 1 row affected (0.01 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || lzs || mysql || performance_schema || test |+--------------------+5 rows in set (0.00 sec) 123、删除数据库： drop database DBName; 124、修改数据库名： 能否修改数据库的名字呢？ 不能！ 123456785、选择数据库： use DBName; //选择相应的数据库，注意，这条语句是可以不加分号的。mysql&gt; use lzs；Database changedmysql&gt; use lzsDatabase changed 123456、如何查看数据库的所以元素： show tables；mysql&gt; show tables;Empty set (0.00 sec) 12345678910111213141516171819202122232425262728293031323334353637387、如何创建一张表： create table tablename ( 列1名称 列1类型 [列1属性] [默认值]， ... 列n名称 列n类型 [列n属性] [默认值](最后一列不能加逗号) ）enqine 引擎名 charset 字符集； 建表的时候，最好就先在记事本上先写出来，再复制过去创建。mysql&gt; create table class -&gt; ( -&gt; num int, -&gt; name varchar(20), //varchar()，字符串 -&gt; height int //注意，最后一列不能够加逗号，因为逗号是用来分开列的。 -&gt; );Query OK, 0 rows affected (0.19 sec)//创建名为shop_all的表格//id varchar(6) not null分别对应：列名、数据类型、数据长度、是否为空值mysql&gt; create table shop_all( -&gt; id varchar(6) not null, -&gt; status varchar(16) not null, -&gt; owner varchar(20) not null, -&gt; owner_id varchar(18) not null, -&gt; introduction varchar(500) not null, -&gt; primary key(id) -&gt; );Query OK, 0 rows affected (0.40 sec)mysql&gt; show tables;+---------------+| Tables_in_lzs |+---------------+| class || shop_all |+---------------+2 rows in set (0.00 sec) 128、删除一张表： drop table tableName； 123456789101112131415161718192021229、如何修改表名： rename table oldName to newName；mysql&gt; show tables;+---------------+| Tables_in_lzs |+---------------+| class || shop_all |+---------------+2 rows in set (0.00 sec)mysql&gt; rename table shop_all to shop;Query OK, 0 rows affected (0.10 sec)mysql&gt; show tables;+---------------+| Tables_in_lzs |+---------------+| class || shop |+---------------+ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525310、查看表结构： desc tableName； //describe v.描述 description n.描述mysql&gt; desc class;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| num | int(11) | YES | | NULL | || name | varchar(20) | YES | | NULL | || height | int(11) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+3 rows in set (0.05 sec)mysql&gt; desc shop;+--------------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------------+--------------+------+-----+---------+-------+| id | varchar(6) | NO | PRI | NULL | || status | varchar(16) | NO | | NULL | || owner | varchar(20) | NO | | NULL | || owner_id | varchar(18) | NO | | NULL | || introduction | varchar(500) | NO | | NULL | |+--------------+--------------+------+-----+---------+-------+5 rows in set (0.01 sec) 注意，当输入错误而且又按下了回车键Enter的时候，MySQL是没有返回改错的，这时候我们可以结束输入&quot;；&quot;，不过这样会有报错。我们可以用&quot;\\c&quot;来退出这条语句。mysql&gt; create tabel class ( //table打错了 -&gt; num int, -&gt; \\cmysql&gt;mysql&gt; create table messages ( -&gt; id int, -&gt; name varchar(20), -&gt; sex varchar(10), -&gt; height varchar(10), -&gt; weight varchar(10) -&gt; );Query OK, 0 rows affected (0.46 sec)mysql&gt; show tables;+---------------+| Tables_in_lzs |+---------------+| class || messages || shop |+---------------+3 rows in set (0.00 sec) 123456789101112131415161718192021222324252627282930313211、增加数据 //往哪张表增，增哪几列，各列是什么值。 insert into tableName //或者insert into lzs.tablename (列名1，列名2，...) //你要增加哪一列的值就加哪一列的名字 values (列1值，列2值，...), //values要与列名对应，varchar型要用单引号括起来 (列1值，列2值，...); //当要增加多列，一列之间用逗号，最后列分号结束 insert语句允许不写列名，如果没有声明列名，则默认插入所有列。因此，如果没有列名，values应该与全部列按顺序一一对应。 如果某列中不想插入值，可以用插入空格来处理，即&apos; &apos;。mysql&gt; insert into messages -&gt; (id, name, sex, height, weight) -&gt; values -&gt; (1, &apos;jack&apos;, &apos;boy&apos;, &apos;175cm&apos;, &apos;60kg&apos;);Query OK, 1 row affected (0.07 sec)mysql&gt; select * from messages;+------+------+------+--------+--------+| id | name | sex | height | weight |+------+------+------+--------+--------+| 1 | jack | boy | 175cm | 60kg |+------+------+------+--------+--------+1 row in set (0.00 sec)mysql&gt; insert into messages -&gt; (id, name, sex, height, weight) -&gt; values -&gt; (2, &apos;rose&apos;, &apos;girl&apos;, &apos;165cm&apos;, &apos;50kg&apos;);Query OK, 1 row affected (0.09 sec) 123456789101112131415161718192021222324252627282930313233343536373839404112、查看数据 select (列) from table；mysql&gt; select * from messages;+------+------+------+--------+--------+| id | name | sex | height | weight |+------+------+------+--------+--------+| 1 | jack | boy | 175cm | 60kg || 2 | rose | girl | 165cm | 50kg |+------+------+------+--------+--------+2 rows in set (0.00 sec) 只查看不同的值，也就是说，当表中有重复的数据时，只列出其中一个来： select distinct (column) from table;TABLE: messages+------+------+------+--------+--------+| id | name | sex | height | weight |+------+------+------+--------+--------+| 1 | jack | boy | 175cm | 60kg || 2 | rose | girl | 165cm | 50kg || 2 | rose | girl | 165cm | 50kg || 3 | rose | girl | 165cm | 50kg |+------+------+------+--------+--------+mysql&gt; select name from messages;+------+| name |+------+| jack || rose |+------+mysql&gt; select * from messages;+------+------+------+--------+--------+| id | name | sex | height | weight |+------+------+------+--------+--------+| 1 | jack | boy | 175cm | 60kg || 2 | rose | girl | 165cm | 50kg || 3 | rose | girl | 165cm | 50kg |+------+------+------+--------+--------+ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646513、修改数据 update tablename set 列名1 = 新值1， 列名2 = 新值2， ... 列名n = 新值n //注意，最后一个不要加逗号，逗号作用是用来分开数据的 where 条件(如，id = 2、name = &apos;xxx&apos;等等);mysql&gt; update messages -&gt; set -&gt; height = &apos;178cm&apos;, -&gt; weight = &apos;65kg&apos; -&gt; where //条件 -&gt; name = &apos;jack&apos;;Query OK, 1 row affected (0.11 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from messages;+------+------+------+--------+--------+| id | name | sex | height | weight |+------+------+------+--------+--------+| 1 | jack | boy | 178cm | 65kg || 2 | rose | girl | 165cm | 50kg |+------+------+------+--------+--------+2 rows in set (0.00 sec)mysql&gt; insert into messages -&gt; values -&gt; (3, &apos;Jeff&apos;, &apos;boy&apos;, &apos;175cm&apos;, &apos;63kg&apos;), -&gt; (4, &apos;Tom&apos;, &apos;boy&apos;, &apos;180cm&apos;, &apos;70kg&apos;), -&gt; (5, &apos;Tim&apos;, &apos;boy&apos;, &apos;185cm&apos;, &apos;72kg&apos;);Query OK, 3 rows affected (0.10 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; select * from messages;+------+------+------+--------+--------+| id | name | sex | height | weight |+------+------+------+--------+--------+| 1 | jack | boy | 178cm | 65kg || 2 | rose | girl | 165cm | 50kg || 3 | Jeff | boy | 175cm | 63kg || 4 | Tom | boy | 180cm | 70kg || 5 | Tim | boy | 185cm | 72kg |+------+------+------+--------+--------+5 rows in set (0.00 sec)mysql&gt; select * from messages where id&gt;2;+------+------+------+--------+--------+| id | name | sex | height | weight |+------+------+------+--------+--------+| 3 | Jeff | boy | 175cm | 63kg || 4 | Tom | boy | 180cm | 70kg || 5 | Tim | boy | 185cm | 72kg |+------+------+------+--------+--------+3 rows in set (0.03 sec)mysql&gt; select id, name, height from messages where weight = &apos;50kg&apos;;+------+------+--------+| id | name | height |+------+------+--------+| 2 | rose | 165cm |+------+------+--------+1 row in set (0.00 sec) 123456789101112131415161718192014、删除数据 delete from tablename where 条件； （from前面是没有列的） 注意，delete只能根据条件删除行，没有删除列的。如果要删除列，那就不叫删除了，而是将它改为null。用update就可以完成了。mysql&gt; delete from messages where id=3;Query OK, 1 row affected (0.07 sec)mysql&gt; select * from messages;+------+------+------+--------+--------+| id | name | sex | height | weight |+------+------+------+--------+--------+| 1 | jack | boy | 178cm | 65kg || 2 | rose | girl | 165cm | 50kg || 4 | Tom | boy | 180cm | 70kg || 5 | Tim | boy | 185cm | 72kg |+------+------+------+--------+--------+4 rows in set (0.00 sec)","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://lizsgh.github.io/tags/mysql/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"https://lizsgh.github.io/categories/MySQL/"}]}]}