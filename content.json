{"meta":{"title":"lizs","subtitle":"www.lizs.cc","description":"www.lizs.cc","author":"lizs","url":"https://lizsgh.github.io"},"pages":[],"posts":[{"title":"HTTP - Basic Authentication","slug":"http/basic_http_authorization","date":"2018-01-31T16:00:00.000Z","updated":"2018-09-12T07:44:44.871Z","comments":true,"path":"2018/02/01/http/basic_http_authorization/","link":"","permalink":"https://lizsgh.github.io/2018/02/01/http/basic_http_authorization/","excerpt":"","text":"HTTP 基本认证中，web 服务器拒绝一个事务，质询客户端，请用户提供有效的用户名和密码。同时，返回 401 状态码，并用 WWW-Authenticate 响应首部指定要访问的安全域(realm)。然后，客户端用 Authorization 请求首部发送经过 base64 加密之后的用户名密码(用户名:密码)给服务器。 Nginx 搭建 HTTP Basic AuthorizationNginx ngx_http_auth_basic_module 可以实现 HTTP Basic Authorization 协议。1234location / &#123; auth_basic &apos;authorization&apos;; auth_basic_user_file conf/htpasswd;&#125; auth_basic: string | off，默认 off，不开启。开启 HTTP Basic Authorization 只需要填写一个字符串，该字符串会作为 realm 的值，在服务器质询客户端的返回头部信息 WWW-Authenticate 中显示，如：WWW-Authenticate: Basic realm=&quot;Authorication&quot;。 auth_basic_user_file: 指定访问的用户名和密码的配置文件，如，htpasswd： 123# commentname1:password1name2:password2:comment 可以用 # 注释 可以设置多个用户名和密码，每行一个，用户名和密码之间用 : 隔开，注释也可以写在密码后面，用 : 隔开。 用户名直接填写，但是密码需要经过加密。如，Linux 系统，密码 123456 可以用 openssl passwd 123456 生成。 假设，刚刚搭建的服务器地址为：127.0.0.1。从浏览器访问 http://127.0.0.1 就会收到一个 401 质询，弹出一个用户名和密码的输入框。用户输入账号和密码之后，浏览器会用 : 将其连接起来，编成 base64 编码，然后将其放在请求头部的 Authorization 中发送给服务端。服务端验证通过后就可以正常浏览页面的内容了。 HTTP 基础认证过程 假如，nginx 配置好的认证页面为 http://127.0.0.1 telnet 建立一条 http 连接 1telnet 127.0.0.1 80 发送正常的请求，会返回 401 12345678910HEAD / HTTP/1.1Host: 172.16.105.114HTTP/1.1 401 UnauthorizedServer: BDSCAN/1.5.0Date: Wed, 17 Jan 2018 08:26:04 GMTContent-Type: text/htmlContent-Length: 195Connection: keep-aliveWWW-Authenticate: Basic realm=&quot;authorization&quot; 发送带验证信息的请求 12345678910111213HEAD / HTTP/1.1Host: 172.16.105.114Authorization: Basic bGl6czoxMjM0NTY=HTTP/1.1 200 OKServer: BDSCAN/1.5.0Date: Wed, 17 Jan 2018 08:26:59 GMTContent-Type: text/htmlContent-Length: 334Last-Modified: Tue, 16 Jan 2018 08:55:10 GMTConnection: keep-aliveETag: &quot;5a5dbdee-14e&quot;Accept-Ranges: bytes 验证信息放在请求头的 Authorization，即 Authorization: Basic base64-username-and-password。base64-username-and-password 为用户名和密码用 : 连接起来，并经过 base64 编码等到的字符串 (即上面的 bGl6czoxMjM0NTY=) 。Python(python2) 生成：12345import base64username = &apos;lizs&apos;password = &apos;123456&apos;msg = base64.b64encode(&apos;%s:%s&apos; % (username, password))","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"https://lizsgh.github.io/tags/http/"}],"keywords":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}]},{"title":"linux command - find","slug":"linux/cmd_find","date":"2017-12-31T16:00:00.000Z","updated":"2018-09-12T08:31:46.194Z","comments":true,"path":"2018/01/01/linux/cmd_find/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/linux/cmd_find/","excerpt":"","text":"findsearch for files in a directory hierarchy 1find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] -H, -L, -P选项 -H, -L, -P 用来控制软连接的处理。 -H: 默认行为，不搜索软连接下的目录或文件。 -L: 搜索软链接。 -P: 不搜索软链接下的目录或文件，除非 当没有指定 -H, -L, -P时，-H 是默认行为，即不搜索软链接下的目录和文件。同时指定多个选项，最后一个有效。如：find -H -L .，-H 无效，-L 有效。 -D debugopts, -Olevel -D debugopts: 打印诊断信息 -Olevel: 允许查询优化，level: 0, 1, 2, 3 starting-point查询开始路径，默认为当前目录 .。 expressionexpression 表达式可以由以下部分组成：tests, actions, global options, positional options, operators。 tests -name pattern按目录名或文件名查找。pattern 不能够有 /，否则无效，如：-name a/b 无效。 123find -name &quot;apps.py&quot; # 查找当前目录下的 apps.py 文件find -name &quot;apps&quot; # 查找当前目录下名称为 apps 的文件或目录find /home -name &quot;app*&quot; # 查找 /home 目录下名称匹配 app* 的文件或目录 -iname patterniname(insensitive name). 用法同 -name，只是 pattern 对大小写不敏感。 -path pattern按路径查找。pattern 是路径。 1234find -path &quot;apps&quot; # 无结果，因为 apps 不是路径find -path &quot;./apps&quot; # 查找当前目录下的 apps 目录或文件find -path &quot;./apps*&quot; # 查找当前目录下路径以 apps 开头的目录或文件find /home -path &quot;*apps*&quot; # 在 /home 目录下查找包含 apps 的目录或文件 -ipath patterninsensitive path, 用法同 -path, 只是 pattern 对大小写不敏感。 -regex pattern和 -path 差不多。 -user uname按照文件或目录所属用户查找。 -group gname按照文件或目录所属组查找。 更多选项查看 find --help 或 man find。 actions -exec command ;对搜索的结果执行命令 command。如果命令是用搜索结果作为参数的，可以用 {} 作为占位符。 12find -path &quot;./apps*&quot; -execfind -path &quot;./apps*&quot; -exec file &#123;&#125; \\; -ok command ;类似 -exec，不过在执行命令 command 之前先要经过用户同意 (y/n) operators (expr)优先操作符，和一般运算的 () 一样。 ! expr取反 expr1 expr2与，即 expr1 和 expr2，相当于 Python 表达式 expr1 and expr2。 expr1 -a expr2同 expr1 expr2 expr1 -and expr2同 expr1 expr2，但是不遵循 POSIX。 expr1 -o expr2或，即 expr1 或 expr2，相当于 Python 表达式 expr1 or expr2。 expr1 -or expr2同 expr1 -o expr2，但是不遵循 POSIX。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"cmd","slug":"cmd","permalink":"https://lizsgh.github.io/tags/cmd/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Terminal - shortcut","slug":"others/terminal_shortcut","date":"2017-12-31T16:00:00.000Z","updated":"2018-09-12T09:45:42.959Z","comments":true,"path":"2018/01/01/others/terminal_shortcut/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/others/terminal_shortcut/","excerpt":"","text":"Linux 终端窗口快捷键 Ctrl + p: 上一条命令 (相当于向上箭头)。 Ctrl + n: 下一条命令 (相当于向下箭头)。 Ctrl + a: 光标回到命令行开始位置。 Ctrl + e: 光标回到命令行开始位置。 Ctrl + b: 光标向左移动一位。 Ctrl + f: 光标向右移动一位。 Ctrl + h: 删除光标左边的一个字符。 Ctrl + d: 删除光标右边的一个字符。 Ctrl + w: 删除光标左边的一个’单词’字符。 Ctrl + u: 删除光标左边的所有字符。 Ctrl + k: 删除光标右边的所有字符。 Ctrl + l: 清屏。","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"TCP/IP - TCP 三次握手连接和四次握手关闭","slug":"tcp/3-handshake_and_4-waves","date":"2017-12-31T16:00:00.000Z","updated":"2018-09-12T10:04:31.511Z","comments":true,"path":"2018/01/01/tcp/3-handshake_and_4-waves/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/tcp/3-handshake_and_4-waves/","excerpt":"","text":"TCP 首部TCP 数据被封装在 IP 数据报中： TCP 首部数据格式： 每个 TCP 段都包含了源端口号和目的端口号，用于寻找发端和接收端的应用程序。这两个端口号加上 IP 首部的源端 IP 地址和目的端 IP 地址就可以确定一个TCP连接。 序号：sequence number, 用来标识从 TCP 发端向 TCP 收端发送的数据字节流。 确认序号：acknowledgement number, 确认序号只有在 ACK 标志位开启(值为1)时有效，值为要确认的数据包的 sequence number + 1。如客户端发送了一个数据包(序号为x)给服务端，则服务端收到这个数据包之后要回复一个确认数据包(确认序号为x + 1)。 标志位：共有 6 个，每个标志位用 1 和 0 分别表示开和关状态。 URG: The urgent point is valid. ACK: The acknowledgement number is valid. PSH: The receiver should pass this data to the application as soon as possible. RST: Reset the connection. SYN: Synchronize sequence numbers to initiate a connection. FIN: The sender is finished sending data. 每个TCP数据包的格式都是固定的，都包含了端口号，序号，确认序号，标志位等。 三次握手和四次握手TCP 建立连接需要经过三次握手 (three-way handshake)，关闭连接需要经过四次握手。 建立连接的三次握手 第一次，客户端发送一个数据包：TCP首部的标志位SYN被设置为1，并且序号为初始序号ISN(Initial Sequence Number)。 第二次，服务器收到客户端的连接请求后，由标志位SYN为1知道这个是建立TCP连接的请求，返回一个数据包：TCP首部的标志位SYN和ACK都被设置为1；序号为服务器端的ISN；确认序号为客户端序号 + 1。此时，服务器处于 SYN_RCVD 状态。 第三次，客户端收到服务端的返回数据之后，由标志位SYN和ACK为1知道服务器同意建立TCP连接的确认数据包。检查确认序号的值(第一次握手客户端发送的序号 + 1)，标志位SYN和ACK都正确之后，返回一个数据报给服务器：标志位ACK设置为1、序号和确认序号的值为服务器发送过来的序号 + 1。服务器收到这个数据包并检查数据报正确之后，客户端和服务端成功建立TCP连接，进入 ESTABLISHED 状态。 关闭连接的四次握手 第一次，主动关闭的那一端(假设为客户端)发送一个关闭连接FIN数据包：TCP首部的标志位FIN设置为1；序号为正常递增值。此时，客户端进入为 FIN_WAIT_1 状态。 第二次，另一端收到数据包之后，由FIN为1知道这是另一端关闭连接的请求。然后返回一个确认数据包：TCP首部标志位ACK设置为1；确认序号为发端序号 + 1；序号正常递增值。此时，服务器进入 CLOSE_WAIT 状态。当客户端收到确认数据包之后进入 FIN_WAIT_2 状态。 第三次，当服务端发送完数据之后，向客户端发送一个关闭连接数据包：TCP首部的标志位FIN设置为1;序号为正常递增值。此时，服务端进入 LAST_ACK 状态。 第四次，客户端收到数据包之后，由FIN为1知道这是服务端要关闭连接了，然后返回一个确认数据包：TCP首部标志位ACK设置为1；确认序号为收到的序号 + 1；序号为正常递增值。此时，客户端进入 TIME_WAIT 状态。 为什么建立连接是三次握手不是两次握手？关闭连接要四次握手？ 建立连接的时候，当客户端收到服务端的确认信息之后(第二次握手)就已经知道了服务端同意了连接，为什么还要再发送确认数据包给服务端(第三次握手)？ 第三次握手，是对第二次握手的确认。假如不进行第三次握手，服务端发送了SYN的确认数据包之后就直接处于 ESTABLISH 状态。这个确认数据包发送过程中出错，没有发送到给客户端怎么办？所以，一定要进行第三次握手。 关闭TCP连接为什么要四次握手？ TCP连接是全双工的通信，关闭的时候需要每个方向进行单独地关闭。当一端主动请求关闭的时候，被动的一端可能还有数据没有发送完毕，不能够立即关闭，所以不能够同时回复FIN + ACK，只能够先回复ACK数据包(第二次握手)，此时属于半关闭状态。当处理完数据之后，被动关闭的一端再发送FIN包给主动关闭的一端关闭连接。 ISNreference","categories":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://lizsgh.github.io/categories/TCP-IP/"}],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"https://lizsgh.github.io/tags/tcp-ip/"}],"keywords":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://lizsgh.github.io/categories/TCP-IP/"}]},{"title":"Stashing and Cleaning","slug":"git/stashing_and_cleaning","date":"2017-01-31T16:00:00.000Z","updated":"2018-09-15T19:11:24.188Z","comments":true,"path":"2017/02/01/git/stashing_and_cleaning/","link":"","permalink":"https://lizsgh.github.io/2017/02/01/git/stashing_and_cleaning/","excerpt":"","text":"情景：工作的时候，你正在项目中属于你的分支下开发一部分功能，但是还没有完善。Leader 突然叫你放下当前的工作，先修改项目中一个非常紧急的 BUG。修 BUG 嘛！家常便饭了。立即切回到上次发布版本(master 最近一次合并)，新建一个分支去修复这个 BUG 。然而，在 checkout 到 master 的时候失败，提示你必须先 commit 当前分支的修改才能够 checkout 到其它分支。问题来了：当前分支的功能只是开发了一部分，不想那么快 commit。不 commit 的话，如果 reset 到前一次 commit 又浪费了之前所做的工作。怎么办？ StashingGit 提供了一个存储机制，用户可以通过git stash或git stash save命令，将修改的跟踪文件与暂存改动存储到一个栈中。 注意，新增的未跟踪文件不会被暂存。所以，当有未跟踪的文件的时候，要先add。 如，当前仓库中有文件test1.py和test2.py两个文件而且工作区都是清洁的，然后对test2.py进行修改，并且添加新文件test3.py。1234567891011121314$ git statusOn branch lizsnothing to commit, working tree clean# change test2.py and add test3.py$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py# stashing the work$ git stashSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git status -s?? test3.py # Untracked files won't be stashed 那么，问题又来了。当我们 stash 修改的时候，发现还有文件没有被 stashed，想要将 stash 起来的修改恢复过来，重新 stash。要怎么做呢？ git stash list: 查看 stashed 的记录 12$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0 git stash apply [&lt;stash&gt;]: 将存储栈的一条记录重新应用到当前分支，如果不指定&lt;stash&gt;，会默认恢复最近一次 stash 记录存储内容。git stash apply在这里即相当于git stash apply stash@{0}。 1234$ git stash apply$ git status -s M test2.py?? test3.py 打开 test2.py 文件可以看到其内容又回到了 stash 之前的状态了。我们再用 git stash list 查看存储栈的时候，发现刚刚的 stash 记录还在。存储的内容都恢复了，我想删除了相应的 stash 记录。 git stash drop [&lt;stash&gt;]: 删除存储栈的一条 stash 记录。如果不指定&lt;stash&gt;将会默认删除存储栈中最近一次的 stash 记录，git stash drop在这里即相当于git stash drop stash@{0}。 123$ git stash dropDropped refs/stash@&#123;0&#125; (...) $ git stash list # 可以看到最近一次的 stash 记录已经被删除掉了 git stash pop [&lt;stash&gt;]: 恢复并删除一条 stash 记录的内容。相当于git stash apply和git stash drop命令的结合。用法和git stash apply [&lt;stash&gt;]一样。 总结以下情境中操作：12345678910111213141516171819202122# change test2.py and add test3.py in the clean working tree$ echo \"# hello world\" &gt;&gt; test2.py $ touch test3.py$ git add .$ git status -s M test2.py?? test3.py$ git stashSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean.# checkout to master fix bug$ git checkout master# create a new branch to fix bug$ git checkout -b issue-01# go back wo branch lizs to continue you work after finishing the bug$ git checkout lizs# restore your coding$ git stash pop 注意，恢复存储栈中的内容的时候可能会有冲突需要合并。 Creative Stashing","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"Git - Basic config","slug":"git/basic_config","date":"2017-01-01T16:00:00.000Z","updated":"2018-09-14T15:37:10.892Z","comments":true,"path":"2017/01/02/git/basic_config/","link":"","permalink":"https://lizsgh.github.io/2017/01/02/git/basic_config/","excerpt":"","text":"初次运行 Git 前的配置 Git 配置文件与命令运行 Git，我们需要先配置下自己的 Git 工作环境。Git 提供了 git config 工具来对 Git 进行配置，也可以通过直接修改 Git 的配置文件： /etc/gitconfig：系统中所有用户普遍使用的配置，用命令git config --system读写的就是这个配置文件。 ~/.gitconfig：当前用户的 Git 配置文件，使用 git config --global 进行的配置保存到这个文件。 .git/config：当前项目下 Git 的配置文件，使用 git config --local 进行配置，这里的配置仅仅针对当前项目有效。 Git 配置文件的优先级别：.git/config &gt; ~/.gitconfig &gt; /etc/gitconfig 配置用户信息12$ git config --global user.name \"lizs\"$ git config --global user.email lizsmail@qq.com 配置完毕之后，我们可以看到~/.gitconfig文件之中多了两行配置：123[user] name = lizs email = lizsmail@qq.com 配置文本编辑器Git 需要你输入一些额外信息的时候，会自动调用一个外部文本编辑器给你用，默认使用系统的默认编辑器。如我我修改提交信息的时候git commit --amend会使用 Ubuntu 系统默认编辑器 nano，使用起来不熟悉。这时候我们可以使用以下方法改变 Git 编辑器： 修改系统编辑器，打开~/.bashrc添加 export EDITOR=vim，然后 source ~/.bashrc。 使用命令 git config --global core.editor vim，修改成功之后，可以在~/.gitconfig文件中多了 core.editor 的配置： 12[core] editor = vim 直接修改 Git 配置文件 .git/config, ~/.gitconfig, /etc/gitconfig。在配置文件添加： 12[core] editor = vim 配置差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。1$ git config --global merge.tool vimdiff Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。 查看配置信息12345678$ git config --listuser.name=lizsuser.email=lizsmail@qq.comcore.editor=vimcore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=true","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"Algorithm - Basic","slug":"algorithm/basic","date":"2016-12-31T16:00:01.000Z","updated":"2018-09-12T07:45:26.526Z","comments":true,"path":"2017/01/01/algorithm/basic/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/algorithm/basic/","excerpt":"","text":"数学基础知识计量单位 B，字节 KB，千字节，2^10 = 1024 B MB，兆字节，2^20 B GB，吉字节，2^30 B 阶乘(factorial)阶乘n!，指从 1 到 n 之间所有整数的乘积，n为大于 0 的整数。如：15! = 1 * 2 * 3 * 4 * 5 特别地，0! = 1。 取模(modulus)取模，指获取整除后的余数。如：15 % 3 = 2 指数幂在数学上，我们把 n 个相同因数 a 相乘的积记做a^n。这种求几个相同因数的积的运算叫做乘方，乘方的结果叫做幂。在a^n中，a叫做底数，n叫做指数。a^n读作：a的n次方，或a的n次幂。 对数在数学中，对数是对求幂的逆运算。如果 N = a^x(a &gt; 0, a != 1)，那么数 x 就叫做以 a 为底 N 的对数(logarithm)，记作 x=logaN。其中，a叫做对数的底数，N叫做真数，x叫做以a为底N的对数。 对数在坐标上过定点 (1, 0)，即 x = 1 时，y = 0。 特别地，以 10 为底的对数称为常用对数(common logarithm)，记为 lg。 以无理数 e(e=2.71828) 为底的对数称为自然对数(natural logarithm)，记为 ln。 零没有对数。 在实数范围内，负数无对数；在复数范围内，负数有对数。 级数级数指将数列的项依次加起来的函数。1∑Un = U1 + U2 + ... + Un 算法分析渐近分析当我们估算一种算法的时间或者其他代价时，经常忽略其系数，只关注其增长率，这称为渐近分析法。准确的说，渐近分析是当输入规模很大，或者达到极限(微积分意义上)时，对一种算法的研究。实践证明忽略这些系数很有用，因此渐近分析也广泛应用于算法比较。 并不是任何情况都能忽略常数。当算法要解决的问题规模 n 很小时，系数就会起到举足轻重的作用。 上限算法运行时间的上限，用来表示该算法可能有的最高增长率。算法有最佳、最差、平均情况下的上限，一般估算最差情况下的上限。 算法增长率的上限，用大 O 表示。如果某种算法的增长率上限(最差情况下)是f(n)，那么就说这种算法“在集合 O(f(n)) 中”，或直接说“在 O(f(n))”中。 下限算法下限，表示最差、最佳、平均情况下的时间下限。用 Ω 表示，读作“大欧米伽”或“欧米伽”。 Θ当算法上限和下限相等时，可用 Θ 表示法，读作“西塔”。 算法最佳、最差、平均情况算法的上(下)限与给定输入规模(如n)的最差(佳)情况不同，上(下)限不是用来确定运行时间(对于给定的n值，即可确定具体的运行时间)的，而是用来确定运行时间的增长率(增长率只能在n值的一个范围内确定)。对于单个点是没有增长率概念的，增长率用于体现伴随输入规模变化的代价变化。 算法的每种输入规模(如n)都存在最佳和最差情况，所以，不要误认为当输入规模尽可能小时出现算法的最佳情况，当输入规模尽可能大时出现算法的最差情况。 理想情况下，当输入规模增大时，可以确定在最佳、最差和平均情况下的增长率。 基本数据结构线性表线性表是由称为元素(element)的数据项组成的一种有限且有序的序列。有序，是指线性表中的每一个元素都有自己的位置。每一个元素也都有一种数据类型。 线性表中不包含任何元素时，称为空表。当前存储的元素数目称为线性表的长度；线性表的开始结点称为表头(head)；结尾结点称为表尾(tail)。 线性表的实现有两种标准方法：顺序表(array-based list 或 sequential list)和链表(linked list)。 顺序表和链表的比较： 顺序表的缺点是大小事先固定，很容易造成空间不足或浪费的情况；优点是对于表中的每个元素没有浪费空间，而链表需要在每个结点上附加一个指针。 链表的优点是只有实际在链表中的对象需要空间，只要存在可用的内存空间分配，链表中的元素个数就没有限制。 一般规律，当线性表元素数目变化较大或者未知时，最好使用链表实现；而如果用户事先知道线性表的大致长度时，使用顺序表的空间效率会更高。 链表的增加/删除操作所需的时间仅为Θ(1)。而顺序表必须将其余的元素向前或向后移动，所需的平均时间和最差时间均为Θ(n)。对于许多应用，插入和删除是最主要的操作，仅就这个原因链表往往比顺序表更好。 链表分为单链表和双链表。双链表存储了两个指针(前驱和后继)，双链表与单链表相比唯一的缺点就是使用更多的空间，双链表的每一个结点需要两个指针。 字典计算机程序一般是用来存储和检索数据的。字典，一个简单的数据库接口，被定义成一个ADT，它提供在数据库中存储、查找和删除记录的功能。 字典用关键码(key)来描述一条数据库记录，并且该关键码是可比的(comparable)。有了这样的关键码，就能够在数据库中顺序地搜索并找出给定关键码值相匹配的记录。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://lizsgh.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://lizsgh.github.io/tags/algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://lizsgh.github.io/categories/Algorithm/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-12-31T16:00:00.000Z","updated":"2018-09-12T07:47:33.451Z","comments":true,"path":"2017/01/01/hello-world/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"lizsgh.github.io","slug":"others/lizsgh.github.io","date":"2016-12-31T16:00:00.000Z","updated":"2018-09-12T08:32:11.774Z","comments":true,"path":"2017/01/01/others/lizsgh.github.io/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/others/lizsgh.github.io/","excerpt":"","text":"Github Pages 和 hexo 搭建个人博客。 Github PagesGithub Pages, Websites for you and your projects. 在 github 上创建名为username.github.io的仓库，其中username为你的 GitHub 账号名称。如我的 GitHub 账号为lizsgh，则创建仓库名为lizsgh.github.io。 在仓库根目录下添加 index.html 页面。这时候，我们登录 http://lizsgh.github.io 就可以看到 index.html 的内容。也就是说，我们可以通过http://lizsgh.github.io来访问这个仓库的静态页面内容。 Jekyll themes。Jekyll 是一个简单的、可扩展的、静态的网站生成器。GitHub Pages 可以选择 Jekyll theme 来作为网站的主题。设置方法：打开仓库，在setting中有一个GitHub Pages的设置选项，其中Theme Chooser可以选择 Jekyll theme 来作为网站的主题。Jekyll 的使用可以看文档：Jekyll Document CNAME。GitHub Pages 还可以让我们自己自定义网站的域名。同样在仓库setting的Github Pages设置选项中有一个Custom domain的选项，可以自定义网站的域名，如 www.lizs.cc。然后，在域名服务商平台将域名解析为 CNAME 类型，值为 lizsgh.github.io。生效之后，就可以通过 www.lizs.cc 来访问了。 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown (或其他渲染引擎) 解析文章，生成静态网页。 个人觉得 Hexo 比 Jekyll 简单好用点，所以抛弃了用 Jekyll theme 来作为 Github Pages 主题。 Hexo 安装前提：Node.js 和 Git。 安装 Hexo 1$ npm install -g hexo-cli 初始化一个 hexo 项目 123$ hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成之后，项目目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 创建文章 1$ hexo new [layout] [title] 如，hexo new test 就会在 source/_posts 目录下生成一篇名为 test.md 的文章。也可以直接在 source/_posts 下新建 test.md 文件来创建文章。 生成静态页面 1$ hexo generate 执行命令会生成一个 public 目录来存放生成的静态页面。如果生成静态页面之前想将之前版本的 public 删除，可以用 hexo clean 命令。 启动本地服务器 1$ hexo server 通过以上命令启动服务器，可以通过 http://localhost:4000/ 地址来访问。 部署到 GitHub Pages 首先，配置 _config.yml 文件 1234deploy: type: git repo: https://github.com/lizsGH/lizsgh.github.io.git branch: master 其中 repo 为你 GitHub Pages 仓库的地址。 然后执行部署命令 1$ hexo deploy 如果出现错误 ERROR Deployer not found: git，则需要安装 hexo-deployer-git 扩展： 1$ npm install hexo-deployer-git --save 自定义域名自定义 GitHub Pages 的域名只需要添加文件 source/CNAME: 1www.lizs.cc 然后，重新部署到 GitHub Pages 即可。 更多详细信息，可以参考 Hexo Document。","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"Python - Built-in functions","slug":"python/builtin_function","date":"2016-12-31T16:00:00.000Z","updated":"2018-09-13T15:44:17.134Z","comments":true,"path":"2017/01/01/python/builtin_function/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/python/builtin_function/","excerpt":"","text":"overview Built-in Functions abs() delattr() hash() memoryview() set() all() dict() help() min() setattr() any() dir() hex() next() slice() ascii() divmod() id() object() sorted() bin() enumerate() input() oct() staticmethod() bool() eval() int() open() str() breakpoint() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() abs(x)返回数值x的绝对值，x可以为：整数和浮点数。如果x是复数，则返回复数的 magnitude，即复数与其共轭复数乘积的正平方根。如：12abs(2 + 2j) # (2 + 2j) * (2 - 2j) 的平方根2.8284271247461903 复数与其共轭复数的乘积运算： (a + bj) * (a - bj) == a ** 2 + b ** 2，因此，abs(a + bj) == math.sqrt(a ** 2 + b ** 2) all(iterable)当iterable中的所有元素为真，或iterable为空时，返回True。 any(iterable)当iterable中有任意一个元素为真时，返回True。 ascii(object)As repr(), return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by repr() using \\x, \\u or \\U escapes. This generates a string similar to that returned by repr() in Python 2. bin(x)将整数x转换为以0b开头的二进制字符串。x为整数或int对象(即该对象必须定义__index__()方法，并返回一个整数)。1234a = bin(3) # &apos;0b11&apos;b = bin(-3) # &apos;-0b11&apos;int(b, base=2)-3 bool([x])根据x的判断值，返回布尔值True或False。如果x为空，返回False。 bool是int的子类，但是，bool不能够被继承，因为bool的实例只有True和False。1234class A(bool): pass TypeError: type &apos;bool&apos; is not an acceptable base type breakpoint(*args, **kws) New in version 3.7 bytearray([source[, encoding[, errors]]]) bytes([source[, encoding[, errors]]]) callable(object)判断 object 是否是可调用的，返回Ture/False。 callable函数只是检测object是否可调用，不管object调用是否成功。object为可调用对象时，调用的时候也可能调用失败；object为不可调用对象时，调用就一定失败。 1234567891011class A(object): pass class B(object): def __call__(self): return a # global name &apos;a&apos; is not defined callable(A) # Truecallable(A()) # Falsecallable(B) # Truecallable(B()) # True 类对象都是可调用的，返回一个类实例。但是类的实例对象是否为可调用对象，取决于类是否定义了__call__()方法。 1234callable(int) # Truecallable(int()) # Falsecallable(bool) # Truecallable(bool()) # False New in version 3.2: This function was first removed in Python 3.0 and then brought back in Python 3.2. chr(i)Return a Unicode string of one character with ordinal i (0 &lt;= i &lt;= 0x10ffff).返回 code point i 对应的 Unicode 的字符，0 &lt;= i &lt;= 0x10ffff。与 ord() 函数作用相反。12chr(65) # Aord(&apos;A&apos;) # 65 @classmethod compile(source, filename, mode, flags=0, dont_inherit=False, optimize=1) eval(expression, globals=None, locals=None)在globals和locals变量的环境下，返回表达式expression执行的值。 expression，可以是字符串，也可以是一个 code objects (如 compile() 创建的 code object)。 globals，字典类型，当globals=None时，默认值为当前环境下的globals()。 locals，任意映射类型，当locals=None时，默认值为当前环境下的locals()。 globals和locals参数只能够通过位置参数传参。 12eval(&apos;int()&apos;, globals=&#123;&apos;a&apos;: 1&#125;)TypeError: eval() takes no keyword arguments 如果globals字典参数中没有__builtins__键，则自动添加__builtins__，其值为builtins模块。 12eval(&apos;list(globals().keys()), list(locals().keys())&apos;, &#123;&#125;, &#123;&#125;)[&apos;__builtins__&apos;, &#123;&#125;] 如果只有globals参数，则locals参数的值默认为globals参数的值。 12eval(&apos;list(locals().keys())&apos;, &#123;&apos;a&apos;: 1&#125;)[&apos;a&apos;, &apos;__builtins__&apos;] 当expression为 code object 时，如果 code object 使用compile()创建时使用的了exec作为参数mode的值，则返回None。 1234print(eval(compile(&apos;1 + 2&apos;, &apos;&lt;string&gt;&apos;, &apos;eval&apos;)))3print(eval(compile(&apos;1 + 2&apos;, &apos;&lt;string&gt;&apos;, &apos;None&apos;)))None 注意，print(&quot;hello world&quot;)只是在屏幕输出内容，表达式没有返回值的。 12345678a = print(&apos;hello world&apos;)hello world # 屏幕输出print(a)None # print 函数的返回值为 Nonea = eval(&quot;print(&apos;hello world&apos;)&quot;)hello world # 屏幕输出print(a)None # eval 函数执行完的返回值为 None map(function, iterable[, iterable, ..]) (Python2.7) Apply function to every item of iterable and return a list of the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. If one iterable is shorter than another it is assumed to be extended with None items. If function is None, the identity function is assumed; if there are multiple arguments, map() returns a list consisting of tuples containing the corresponding items from all iterables (a kind of transpose operation). The iterable arguments may be a sequence or any iterable object; the result is always a list.(Python3+) Return an iterator that applies function to every item of iterable, yielding the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterable stops when the shortest iterable is exhausted. 将function应用于iterable的每一项，返回列表(Python3+，迭代对象)，列表(迭代对象)中的每一项都是function作用后的结果。注意：Python3+ 返回的是迭代对象。 如果有多个iterable，function将并行应用于iterable的每一项。也即是，所有iterable中相同序列的项同时作为参数传递给function运行。如： 12345678map(lambda x, y: x + y, [1, 2, 3], [4, 5, 6])[5, 7, 9] # Python3+ 返回迭代器&lt;map object&gt;map(lambda x: x * x, [1, 2, 3], [4, 5, 6])TypeError: &lt;lambda&gt;() takes exactly 1 argument (2 given)def func(*args): return argsmap(func, [1, 2, 3], [4, 5, 6], [7, 8, 9])[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 当iterable的个数(注意，不是iterable元素个数)与function函数的参数不一致时会出错。如： 12map(lambda x: x * x, [1, 2, 3], [4, 5, 6])TypeError: &lt;lambda&gt;() takes exactly 1 argument (2 given) 当有多个iterable并且iterable的元素数目不一致时：Python2，会以最长的为准，短自动用None补全。Python3+，以最短的为准，迭代完最短的iterable就会自动结束。 12345678def func(*args): return args# Python2.7map(func, [1, 2, 3], [4, 5, 6, 7])[(1, 4), (2, 5), (3, 6), (None, 7)]# Python3+list(map(func, [1, 2, 3], [4, 5, 6, 7]))[(1, 4), (2, 5), (3, 6)] 当function为None 123456# Python2map(None, [1, 2, 3], [4, 5, 6, 7])[(1, 4), (2, 5), (3, 6), (None, 7)]# Python3+list(map(None, [1, 2, 3], [4, 5, 6, 7]))TypeError: &apos;NoneType&apos; object is not callable","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"},{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]}]}