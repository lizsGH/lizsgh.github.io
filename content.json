{"meta":{"title":"lizs","subtitle":"www.lizs.cc","description":"www.lizs.cc","author":"lizs","url":"https://lizsgh.github.io"},"pages":[],"posts":[{"title":"HTTP - Cookies","slug":"http/http_cookies","date":"2019-01-08T19:19:06.248Z","updated":"2019-01-08T19:19:06.244Z","comments":true,"path":"2019/01/09/http/http_cookies/","link":"","permalink":"https://lizsgh.github.io/2019/01/09/http/http_cookies/","excerpt":"","text":"HTTP Cookie (web cookie, browser cookie) 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向该服务器发起请求时附加在请求首部 Cookie 字段发送给服务器。 Cookie 注意用于以下三个方面： 会话状态管理 (如用户登录状态、购物车、游戏分数或其它需要记录的信息等) 个性化设置 (如用户自定义设置、主题等) 浏览器行为跟踪 (如跟踪分析用户行为等) Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。Cookie 的大小不超过 4KB，而且每次请求都会发送回服务器，带来额外的性能开销。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API或更加高级的IndexedDB。 创建 Cookie当服务器收到 HTTP 请求时，服务器可以通过响应头部的 Set-Cookie 字段将 cookies 发送给客户端浏览器。浏览器收到响应之后，通常会保存下 cookies，之后对该服务器的每一次请求中都通过请求头部的 Cookie 字段将相应的 cookies 附带发送到服务器。 Set-Cookie响应首部Set-Cookie被用来由服务器端向客户端发送 cookies。Syntax:12345678910111213Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt; Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Max-Age=&lt;non-zero-digit&gt;Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Path=&lt;path-value&gt;Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; SecureSet-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; HttpOnlySet-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; SameSite=StrictSet-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; SameSite=Lax// Multiple directives are also possible, for example:Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;; Secure; HttpOnly &lt;cookie-name&gt;=&lt;cookie-value&gt;cookies 键值对。 &lt;cookie-name&gt;，键名。可以是除了控制字符 (CTLs)、空格 (spaces) 或制表符 (tabs) 之外的任何 US-ASCII 字符。同时，不能够包含以下分隔字符：()&lt;&gt;@,;:\\&quot;/[]?={}。 &lt;cookie-value&gt;，键值。可以是除了控制字符 (CTLS)、空格 (whitespace)、双引号 (double quotes)、逗号 (comma)、分号 (semicolon) 和反斜杠 (backslash) 之外的任意 US-ASCII 字符。该值可以也可以用双引号括起来，即cookie-name=&quot;cookie-value&quot;。关于编码：许多应用会对 cookie 值按照 URL 编码 (URL encoding) 规则进行编码，按照 RFC 规范，这不是必须的。不过编码可以将不规范的值转化为符合要求的值。 __Secure-前缀，以__Secure-为前缀的 cookie，必须与secure属性一同设置，同时必须应用于安全页面 (HTTPS)。 __Host-前缀，以__Host-为前缀的 cookie，必须与secure属性一起设置，必须应用于安全页面 (HTTPS)，而且不能够设置domain属性 (这样就不会发送给子域)，同时path属性的值必须为/。123456789// 当响应来自于一个安全域（HTTPS）的时候，二者都可以被客户端接受Set-Cookie: __Secure-ID=123; Secure; Domain=example.comSet-Cookie: __Host-ID=123; Secure; Path=/// 缺少 Secure 指令，会被拒绝Set-Cookie: __Secure-id=1// 缺少 Path=/ 指令，会被拒绝Set-Cookie: __Host-id=1; Secure// 由于设置了 domain 属性，会被拒绝Set-Cookie: __Host-id=1; Secure; Path=/; domain=example.com Expires=&lt;date&gt;可选，指定 cookie 的有效日期，格式和Date首部字段一样。注意：该有效日期是指客户端上的日期，不是服务端。如： 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Max-Age=&lt;non-zero-digit&gt;可选，指定 cookie 的有效时间，值为非零整数，单位为秒。如Max-Age=60，表示 cookie 在 60 秒之后就会过期。 Domain=&lt;domain-value&gt;可选，指定 cookie 可以送达的主机。如果不指定，默认为当前文档访问地址 (Document.location) 的主机，但是不包括子域名。如果指定了Domain，在一般包括子域名。如，Domain=mozilla.org，则 cookie 也可以发送到子域名中 (如developer.mozilla.org)。 Path=&lt;path-value&gt;可选，指定 cookie 允许发送的 URL 路径。字符%x2F (/) 为路径分隔符，子路径也会被匹配。如Path=/docs，则/docs, /docs/Web/, docs/Web/HTTP等都会被匹配。 Secure可选，标记为Secure的 Cookie 只应通过被 HTTPS 协议加密的请求发送给服务器。但即便设置了Secure标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure标记无法提供确实的安全保障。从 Chrome 52 和 Firefox 52 开始，不安全的站点 (http:) 无法使用 Cookie 的Secure属性。 HttpOnly可选，设置了HttpOnly属性的 Cookie 不能使用 JavaScript 的 Document.cookie 属性、XMLHttpRequest或Request API 进行访问，以防范跨站脚本攻击 (XSS)。 CookieCookie 是请求首部，会将由服务器通过 Set-Cookie 响应首部发送过来的 cookies 发送到服务器。这个首部可能会被完全移除，例如在浏览器的隐私设置为禁止用 cookie。1Cookie: name=value[; name2=value2; name3=value3; ...] 如：1Cookie: PHPSESSID=298zf09hf012fh2; csrftoken=u32t4o3tb3gg43; _gat=1; 会话期 cookies (Session cookies)会话期 cookies ，即Set-Cookie中不设置过期日期 (Expires) 或有效时间 (Max-Age) 的 cookies。会话期 cookies 会在浏览器关闭时自动删除。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 cookies 也会被保留下来，就像浏览器从来没有关闭一样。1Set-Cookie: sessionid=38afes7a8; HttpOnly; Path=/ 持久化 cookies (Permanent cookies)持久化 cookies，即指定了过期日期 (Expires) 或有效时间 (Max-Age) 的 cookies。持久化 cookies 与客户端关闭与否无关，只有过期了才会失效。1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 第三方 cookies每个 cookie 都会有与之关联的域 (Domain)，如果 cookie 的域和页面相同，那么我们称这个 cookie 为第一方 cookie (first-part cookie)。如果 cookie 的域和页面的域不同，则称之为第三方 cookie (third-part cookie)。 如，网站 A 上引用了网站 B 的一个 JS 脚本，当浏览器打开网站 A 的时候，也会请求网站 B 的这个脚本，这时候，网站 B 可以创建 cookie 一起响应返回。浏览器会将网站 B 的 cookie 也保存下来 (浏览器没有禁止第三方 cookie 的情况下)，这个 cookie 相对网站 A 来说就是第三方 cookie，只有用户访问网站 B 的时候使用。 利用第三方 cookies 进行精准推送广告 (如百度联盟)： 用户使用百度搜索的时候，百度搜索引擎会记住你的搜索内容，并设置了一个用户标识 cookie (BAIDUID)。 当用户访问嵌有百度推广广告的网页的时候，广告模块 (如&lt;iframe src=&quot;http://pos.baidu.com/...&quot;&gt;) 会携带这个 cookie 一起发送到服务器。然后，服务器根据这个用户标识找到你搜索过的内容，生成相应的广告返回。 DNT (Do-Not-Track)DNT请求首部字段表明了用户对于网站追踪的意愿。0，表示用户同意目标站点追踪用户的个人信息；1，表示用户不愿意目标站点追踪用户的个人信息。 用户对DNT的设置，可以使用Navigator.doNotTrack属性进行读取。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"https://lizsgh.github.io/tags/http/"}],"keywords":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}]},{"title":"HTTP - Cross-Origin Resource Sharing (CORS)","slug":"http/http_cors","date":"2019-01-05T18:46:49.965Z","updated":"2018-12-28T19:48:51.782Z","comments":true,"path":"2019/01/06/http/http_cors/","link":"","permalink":"https://lizsgh.github.io/2019/01/06/http/http_cors/","excerpt":"","text":"HTTP access control (CORS)跨域资源共享 CORS 详解 出入安全原因，浏览器限制了脚本跨域 HTTP 请求。一般情况下，当脚本发出跨域 HTTP 请求的时候，浏览器根据返回的头部信息，判断是否拦截返回的结果。通常情况出现错误提示如：`Access to XMLHttpRequest at ‘xxx’ from origin ‘xxx’ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.即，HTTP 请求的返回被浏览器拦截了。在 Chrome 浏览器上可以用插件 ‘Moesif Origin &amp; CORS Changer’ 来处理。 CORS 简介跨域资源共享 (CORS)，是一种在 HTTP 头部附加相应的信息来使浏览器允许 web 应用有权限跨域 HTTP 请求资源的机制。当 HTTP 请求的资源与自身的协议、域名或端口不一样的时候，这个 HTTP 请求就是跨域 HTTP 请求 (cross-origin HTTP request)。如，从前端地址为 http://localhost:8080/ 的应用页面 API 地址为 http://localhost:8000 的数据的时候。 跨域资源共享 (CORS) 机制支持安全的跨域请求，使请求数据可以安全地在浏览器与服务器传输。现代的浏览器可以通过 XMLHttpRequest 或 FetCh API 使用 CORS 机制来处理跨域 HTTP 请求。当然，这些都是浏览器自动处理的，不需要用户参与，而且即使 CORS 请求失败，在 JavaScript 代码层也无法获取错误信息，只能够在浏览器控制台查看。 CORS 标准是通过在 HTTP 头部添加相应的信息来实现跨域资源共享的。浏览器根据头部信息来进行简单请求或 (simple requests) 预检请求 (preflighted requests)。 简单请求CORS 简单请求，即浏览器直接发出 CORS 请求 (在请求头部信息添加 Origin字段) 到服务器，如果响应头部不存在Access-Control-Allow-Origin字段，则说明请求源不在服务器允许的跨域白名单里或服务器不支持跨域请求。 若满足以下所有条件，则该请求为简单请求： 请求方法： HEAD GET POST 请求头部字段不超出： Accept Accept-Language Content-Language Content-Type，仅限于： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用XMLHttpRequest.upload属性访问。 请求中没有使用 ReadableStream 对象。 CORS 简单请求示例：123456GET /api/base/ HTTP/1.1Host: localhost:8000Connection: keep-aliveOrigin: http://localhost:8080User-Agent: Mozilla/5.0 ...Accept-Language: zh-CN,zh;... 响应头部信息：123456789HTTP/1.1 200 OKDate: Thu, 27 Dec 2017 20:35:23 GMTServer: WSGIServer/0.2 CPython/3.6Content-Type: application/jsonVary: Accept, Cookie, OriginAllow: GET, HEAD, OPTIONSX-Frame-Options: SAMEORIGINContent-Length: 560Access-Control-Allow-Credentials: true 响应状态为 200，但是响应头部中没有Access-Control-Allow-Origin，说明服务器不支持跨域 HTTP 请求资源。 当服务器添加跨域请求白名单之后，响应头部信息为：1234567891011HTTP/1.1 200 OKDate: Thu, 27 Dec 2017 20:42:23 GMTServer: WSGIServer/0.2 CPython/3.6Content-Type: application/jsonVary: Accept, Cookie, OriginAllow: GET, HEAD, OPTIONSX-Frame-Options: SAMEORIGINContent-Length: 560Access-Control-Allow-Credentials: trueAccess-Control-Allow-Origin: http://localhost:8080Access-Control-Expose-Headers: X-CSRFToken, X-SessionId 响应头部Access-Control-Allow-Origin的值为*或请求头部 Origin 字段的值，则说明服务器同意跨域资源共享。 预检请求预检请求，是在发送真正的跨域请求之前先向服务器发送一个请求方法为 OPTIONS 的 HTTP 请求，来检测服务器是否允许当前请求源的跨域资源请求。 当浏览器发现这满足预检请求条件的时候 (即非简单请求)，会自动发出一个预检请求：1234567891011OPTIONS /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 ...Accept-Language: zh-CN,zh;...Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveOrigin: http://localhost:8080Access-Control-Request-Method: POSTAccess-Control-Request-Headers: X-Custom-Header 预检请求使用OPTIONS方法 Origin，和简单请求字段一样，表示请求源； Access-Control-Request-Method，必须字段，告知服务器实际请求将使用的请求方法。 Access-Control-Request-Headers：告知服务器，实际请求将携带的额外头部信息。多个头部信息用逗号隔开。 预检请求的响应：12345678910111213HTTP/1.1 200 OKDate: Thu, 27 Dec 2017 20:55:23 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://localhost:8080Access-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-CSRFToken, X-SessionIdAccess-Control-Max-Age: 86400Vary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 以上响应表示服务器同意跨域资源请求。如果浏览器否定预检请求，会返回一个正常 HTTP 响应，但是没有 CORS 相关的头信息。 当预检请求通过之后，浏览器就会发出实际的跨域资源请求，就像简单请求一样。 Requests with credentials一般而言，对于跨域XMLHttpRequest或Fetch请求，浏览器不会发送身份凭证信息。如果要发送附带身份凭证的请求，需要在请求中打开XMLHttpRequest的withCredentials属性。12345var xhr = new XMLHttpRequest();xhr.withCredentials = true;// Vue2 的 axiosimport axios from 'axios'axios.defaults.withCredentials = true; 同时，需要服务器同意发送的请求附带 Cookie。服务器通过响应头部字段Access-Control-Allow-Credentials: true来告诉客户端可以发送 Cookies。 如果服务端的响应头部未携带Access-Control-Allow-Credentials: true，浏览器将不会把响应内容返回给请求的发送者；如果请求端不打开XMLHttpRequest的withCredentials属性，即使服务端同意发送 Cookie，浏览器也不会发送。 The HTTP request headers Origin指定请求源 ([scheme]://host[:port]，不包含任何路径信息)，服务器根据这个值判断是否同意跨域请求。注意：请求首部字段 Origin 不是 CORS 专属。 Access-Control-Request-Method用于预检请求，将实际请求所使用的 HTTP 方法告诉服务器。 Access-Control-Request-Headers用于预检请求，将实际请求所携带的额外首部字段告诉服务器。 The HTTP response headers Access-Control-Allow-Origin用于判断服务器是否同意或支持跨域资源分享。 如果简单请求或预检请求的响应头部不带Access-Control-Allow-Origin字段，则表示服务器不同意跨域请求，或不支持 CORS。即使服务器有正常的响应返回，浏览器为了安全考虑也会自动过滤掉请求的响应结果，抛出被 CORS 策略拦截的相关错误。 如果响应头部有Access-Control-Allow-Origin字段，该字段的值可以为*或请求首部字段Origin的值。当值不是*的时候，响应首部的Vary字段必须包含Origin，表示服务器对不同的请求源会返回不同的内容。 Access-Control-Allow-Credentials布尔值 (true/false)，表示服务器是否允许客户端发送带 Cookie 的 CORS 请求。一般而言，对于跨域XMLHtpRequest或Fetch请求，浏览器不会发送身份凭证信息。 Access-Control-Allow-Methods用于预检请求的响应，指明了实际请求所允许使用的 HTTP 方法。 1Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]... Access-Control-Allow-Headers用于预检请求的响应，指明实际请求中允许携带的头部字段。 1Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]... Access-Control-Expose-Headers在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能够获取到一些默认允许获取的响应头部字段：Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma。如果想要访问其它头部字段，则需要服务器端设置。如，Django 的corsheaders.middleware.CorsMiddle中间件，通过CORS_EXPOSE_HEADERS = (&#39;X-CSRFToken&#39;, &#39;X-SessionId&#39;)来设置。响应头部相应的会出现： 1Access-Control-Expose-Headers: X-CSRFToken, X-SessionId 这样，客户端就可以获取响应头部字段X-CSRFToken和X-SessionId了。 Access-Control-Max-Age用于预检请求的响应，告诉浏览器预检请求的结果能够被缓存多久。 1Access-Control-Max-Age: &lt;delta-seconds&gt; django-cors-headersDjango 可以通过安装django-cors-headers，通过使用相应的中间件来配置处理 CORS 请求。具体参考文档django-cors-headers。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"https://lizsgh.github.io/tags/http/"}],"keywords":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}]},{"title":"SDK environment to deploy Cordova apps for Android devices","slug":"cordova/cordova_env","date":"2019-01-05T08:36:57.450Z","updated":"2019-01-05T08:36:57.450Z","comments":true,"path":"2019/01/05/cordova/cordova_env/","link":"","permalink":"https://lizsgh.github.io/2019/01/05/cordova/cordova_env/","excerpt":"","text":"Cordova - Develop for platforms (Android) Installing the RequirementsJava Development Kit (JDK)首先安装 JDK 8。 方法一：从官网下载安装包安装(JDK8)。 下载相应平台的安装包，如：Ubuntu的jdk-8u191-linux-x64.tar.gz。 解压到/usr/local/lib/jvm/目录下 (目录自定义)，假如解压之后目录为：/usr/local/lib/jvm/jdk1.8.0_191。 全局配置，添加文件/etc/profile.d/jvm。(也可以配置当前用户~/.bashrc)。 1234export JAVA_HOME=/usr/local/lib/jvm/jdk1.8.0_191export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=.:$&#123;JAVA_HOME&#125;/bin:$PATH 再source /etc/profile，使配置生效。 检查是否安装成功。 1234$ java -versionjava version \"1.8.0_191\"Java(TM) SE Runtime Environment (build 1.8.0_191-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) 方法二：使用 PPA 源安装 123sudo add-apt-repository ppa:webupd8team/javasudo apt updatesudo apt install oracle-java8-installer 安装过程中，安装器会提示你是否同意 Oracle 的服务协议。 Gradle从 Cordova 6.4.0 开始，Cordova 需要安装 Gradle。 从官网上下载 Gradle 安装包，解压到/opt/gradle/。 添加/opt/gradle/bin/到PATH环境变量，/etc/profile。1export PATH=$PATH:/opt/gradle/bin Android SDK 方法一：直接下载 Android SDK 安装包，解压到/home/lizs/Android/sdk/ (目录自定义)。然后，配置环境变量，添加/etc/profile.d/android.sh： 12export ANDROID_HOME=/home/lizs/Android/sdkexport PATH=.:$&#123;ANDROID_HOME&#125;/tools:$&#123;ANDROID_HOME&#125;/platform-tools:$PATH 方法二：安装 Android Studio 的时候安装 Android SDK (我使用的就是这个方式，下载 SDK 的时候速度超级快)。 从 https://developer.android.google.cn/studio/下载 Android Studio 的安装包，解压到/opt/android-studio/。 进入/opt/android-studio/bin/目录执行安装脚步./studio.sh进行安装。 安装的时候选择自定义安装，可以指定 Android SDK 安装路径 (Android SDK Location)，如/home/lizs/Android/sdk/。 安装完毕，打开 Android Studio 可以在顶部菜单栏Tools-&gt;Create Desktop Entry创建快捷方式。 Ubuntu18.04 也可以直接从Ubuntu Software中心安装 Android Studio。 配置环境变量，和方法一一样。 同意 Android SDK 服务协议。如果这时候创建并运行 Cordova 项目cordova run android，出现没有接受 Android SDK 服务协议的错误 (You have not accepted the license agreements of the following SDK components)，需要同意 Android SDK 服务协议：进入目录$ANDROID_HOME/tools/bin/，执行sdkmanager --licenses，一直输入y回车。","categories":[{"name":"Cordova","slug":"Cordova","permalink":"https://lizsgh.github.io/categories/Cordova/"}],"tags":[{"name":"cordova","slug":"cordova","permalink":"https://lizsgh.github.io/tags/cordova/"}],"keywords":[{"name":"Cordova","slug":"Cordova","permalink":"https://lizsgh.github.io/categories/Cordova/"}]},{"title":"Django tutorial 2","slug":"python/django_tutorial_2","date":"2018-12-08T16:41:21.927Z","updated":"2018-12-08T16:41:21.923Z","comments":true,"path":"2018/12/09/python/django_tutorial_2/","link":"","permalink":"https://lizsgh.github.io/2018/12/09/python/django_tutorial_2/","excerpt":"","text":"","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://lizsgh.github.io/categories/Python/Django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://lizsgh.github.io/tags/django/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://lizsgh.github.io/categories/Python/Django/"}]},{"title":"Vim usage","slug":"others/vim","date":"2018-12-07T08:46:36.450Z","updated":"2018-12-07T08:46:36.442Z","comments":true,"path":"2018/12/07/others/vim/","link":"","permalink":"https://lizsgh.github.io/2018/12/07/others/vim/","excerpt":"","text":"vim 配置 vim 配置文件： vim 首先读取当前用户的配置文件 ~/.vimrc，如果没有则读取 root 用户的配置文件/root/.vimrc。 在.vimrc文件中可以配置 vim 的永久属性。.vimrc 文件里面的注释用英文的双引号&quot;。 在文件编辑时，命令模式下可以配置 vim 的暂时属性，即关闭文件则失效。如给当前文件显示行号：:set nu 常见配置： set nu：添加行号。 set nonu：删除行号。 set tabstop=4：设置 Tab 键占 4 个空格。 set ai：自动换行。 vim 常见用法 :w：保存当前修改。 :w new_file：保存到新文件。当编辑没有权限的文件时，可以利用这个命令将当前修改保存到有权限的新文件中。 :w! exist_file：保存到已有文件。 :q：退出，当文件没有修改过的时候才有效，如果有修改过，需要保存退出或强制退出。 :wq, :x：退出，并保存修改。:wq，不管文件有没有修改，每次执行命令都会更新文件的修改时间；:x，当文件没有修改过的时候，直接退出，并不更新文件的修改时间。 :q!：强制退出，放弃修改。 查找 /word：从开头到结尾查找文件中的 “word”。 ?word：从结尾到开头查找文件中的 “word”。查看下一个，按n；上一个，按N。 替换在命令模式下，可以用 s 命令来替换字符串：: [option1]s/oldStr/newStr/[option2] [option2] 可以是 g c p g：表示全局替换 c：表示进行确认再替换 p：表示替换结果逐行显示（Ctrl + L 恢复屏幕） : s/oldStr/newStr/：替换当前行第一个 oldStr 字符串 : s/oldStr/newStr/g：替换当前行所有 oldStr 字符串 : m, ns/oldStr/newStr：替换从第 m 行到第 n 行中的第一个 oldStr 字符串 : n, $s/oldStr/newStr/g：替换从第 n 行到最后一行的所有 oldStr 字符串 : ., $s/oldStr/newStr/：替换从当前行到最后一行的第一个 oldStr 字符串 : %s/oldStr/newStr/g：替换每一行中所有的 oldStr 字符串 : %s/oldStr/newStr/c：替换每行中的第一个 oldStr 字符串，但是替换需要确认 : %s/oldStr/newStr/gc：替换所有的 oldStr 字符串，但是替换需要确认 可以使用 # 和 + 代替 / 作为分隔符，此时命令中出现的 / 将作为普通字符处理，如： : s#oldStr/#newStr#：替换当前行的 oldStr/ 字符串 : %s+/oldStr/+newStr：替换所有 /oldStr/ 字符串 跳到指定行 正常模式下，ngg 或 nG，n 为行号。如跳到 35 行，35gg。G 可以直接跳到最后一行。 命令模式下，:n 如果想打开文件即跳转，sudo vim +n file_name 复制一(n)行 正常模式下，复制光标所在的整行，yy；复制 n 行(从光标所在行开始)，nyy。 命令模式下，复制从第 n 行到 n + 5 行的内容到第 m 行后面 n, n+5 copy/co m 正常模式下，把光标移到要开始复制的那一行 ngg，然后，计算一下删除哪几行(如，n ～ n+5，包括n和n+5)，执行 d5（即删除第 n 到第 n+5 这 6 行）。删除完之后，恢复 u。将光标移到要粘贴的位置，p。 粘贴一行正常模式下，将复制到的内容粘贴到光标所在的行，p 删除一行正常模式下，删除光标所在的行，dd 删除多行正常模式下，删除光标所在的行开始的 n + 1 行，dn。n的值为最后一行的行号减去开始行的行号。 撤消在正常模式下,撤消上一步,u 恢复撤消在正常模式下,恢复撤消的内容,Ctrl + r 光标移动 h：向左；nh，向左移动 n 个字符。 j：向下；nj，向下移动 n 行。 k：向上；nk，向上移动 n 行。 l：向右。nl，向右移动 n 个字符。 w：向右移动到下个单词的首个字符处；nw，向右移动 n 个单词。 b：与 w 方向相反。 e：向右移动到下个单词的尾字符处；ne，向右移动 n 个单词。 ge：与 e 方向相反。 ^：光标移动到该行的第一个字符处（不包括空格）。 $：光标移动到该行的尾字符处。 0：光标移动到该行的行首。 ngg或nG：光标移动到 n 行的第一个字符上。 gg：移动到文件首行。 G：光标移动到文件末行。 Ctrl + f：向上翻页。 Ctrl + b 选择字符正常模式下，v，进入可视模式，然后通过光标移动来选择字符。 复制 y：复制选中的字符，选中字符可以在可视模式下，然后 hjkl 选择。 ye：复制当前光标位置到单词结尾的字符内容到 vim 缓冲区。nye，复制 n 个单词。 yw：复制当前光标位置到下个单词开头的字符内容到 vim 缓冲区。nyw，复制 n 个单词。 y^：复制当前光标位置到行首的内容到 vim 缓冲区。 y$：复制当前光标位置到行尾的内容到 vim 缓冲区。 yy：复制当前行的内容到 vim 缓冲区。nyy，复制 n 行。 复制第 m 行到第 n 行的内容到 vim 缓冲区：命令模式下，m, ny 复制第 m 行到第 n 行的内容到第 k 行后面：命令模式下，m, n copy/co k 以上复制，都是将内容复制到 vim 剪贴板，而且 vim 具有多个剪贴板，而我们平时操作的复制粘贴是将内容保存到系统的剪贴板。所以，当你想从另外的地方复制了一段内容（如，浏览器某个网址上复制一段内容）到当前 vim 来，是不能够直接用 p 来粘贴的。因为，p 命令是默认粘贴当前 vim 缓冲区的内容。 vim 中的剪贴板内容是保存在 register 中的，在 vim 命令模式下，可以用 reg 命令来查看 register 中的内容。 （ubuntu 16.04）我们可以看到，系统中复制的内容保存在 &quot;* 和 &quot;+ 的 register 中。所以，如果我们想要将系统剪贴板的内容粘贴到当前 vim，只需在粘贴命令前添加 register 标记就可以了。 &quot;*p或&quot;+p：将系统剪贴板的内容粘贴到光标后面。 &quot;*y或“+y：将当前 vim 中选中的内容复制到系统剪贴板中。 删除 (非插入模式下) x或d：删除当前光标下的字符。 dw：删除光标之后的单词剩余部分。 d$：删除光标之后的该行剩余部分。 dd：删除当前行。 dn：n为最后一行的行号减去开始行的行号的值，删除光标所在的行开始的 n + 1 行。 c：删除光标下的字符后，进入插入模式。 cc：删除当前行之后，进入插入模式。","categories":[{"name":"Others","slug":"Others","permalink":"https://lizsgh.github.io/categories/Others/"}],"tags":[{"name":"others","slug":"others","permalink":"https://lizsgh.github.io/tags/others/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"https://lizsgh.github.io/categories/Others/"}]},{"title":"Linux command - tcpdump","slug":"linux/cmd_tcpdump","date":"2018-12-05T18:37:44.676Z","updated":"2018-12-05T18:37:44.672Z","comments":true,"path":"2018/12/06/linux/cmd_tcpdump/","link":"","permalink":"https://lizsgh.github.io/2018/12/06/linux/cmd_tcpdump/","excerpt":"","text":"Dump the traffic on a network. 1tcpdump [options] [expression] 常用 options: -c count: Exit after receiving count packets. 指定抓取的包的数量。 -D, --list-interfaces: 打印出系统中可以被 tcpdump 抓包的网络接口。列出的网络接口包括相应的序号和网络接口名，可以用 tcpdump -i指定相应的网络接口或相应的序号来抓取特定网络接口的数据包。其中名为any的网络接口表示可以抓取所有网络接口的数据包 (tcpdump -i any)。 -F file: 从指定的file中读取expression(tcpdump [options] [expression])。 -i interface, --interface=interface: 指定抓包的网络接口。如果没有指定tcpdump会监听tcpdump -D中第一个网络接口。当指定interface为any则表示监听所有网络接口。 -l: Make stdout line buffered. 将抓包记录从标准输出变为行缓冲形式。当抓包的时候，你可以将抓包记录存到文件，边抓包边分析。 -n: Don not convert address (i.e., host address, port numbers, etc) to names. 即直接显示数字形式的地址端口号等，而不进行解析。 -#, --number: 给每行抓包的输出结果添加行号。 -q: 简短快速输出。只打印较少的协议信息。 -t: 每行抓包记录不打印时间。 -tt: 将每行抓包记录的时间代替为时间戳形式。 -ttt: 将每行记录的时间替换为和上一行的时间差。 -tttt: 在每行记录的时间前添加日期 (默认只显示时分秒)。 -v, -vv, -vvv: 打印其它详细信息，详细程度依次递增。 -w file, 不打印抓取的数据包，而是将数据保存到file文件中，文件后缀一般为.pcap, .cap, .dmp。保存的数据是没有解码的十六进制数据，可以使用 wirekshark 等工具进行分析。 -x: 以十六进制形式打印数据包的头部信息。 -xx: 比-x更加详细。 -X: 以十六进制和 ASCII 的形式打印数据包的头部信息。 -XX: 比-X更加详细。 12345678910111213141516171819202122232425# 查看系统中可以被 tcpdump 抓包的网络接口sudo tcpdump -D 1.wlo1 [Up, Running] 2.vmnet1 [Up, Running] 3.vmnet8 [Up, Running] 4.any (Pseudo-device that captures on all interfaces) [Up, Running] 5.lo [Up, Running, Loopback] 6.docker0 [Up] 7.eno1 [Up] 8.br-eb58f5c99244 [Up] 9.bluetooth0 (Bluetooth adapter number 0) ...# 监听所有接口sudo tcpdump -i any # 或 sudo tcpdump -i 4# 将抓包信息保存到文件，可以边抓包边分析sudo tcpdump -nn -l &gt; packets.log &amp;# 抓取 10 个数据包，并添加行号和显示数字形式的地址、端口信息sudo tcpdump -c 3 -n#listening on wlo1, link-type EN10MB (Ethernet), capture size 262144 bytes 1 19:55:08.990797 IP 192.168.3.3.53751 &gt; 192.168.0.102.63822: UDP, length 96 2 19:55:08.990972 IP 192.168.3.3.58581 &gt; 192.168.1.24.61048: UDP, length 96 3 19:55:08.991039 IP 192.168.3.3.41684 &gt; 140.240.42.194.4321: UDP, length 963 packets captured4 packets received by filter0 packets dropped by kernel expressionexpression 可以用来过滤抓取的数据包。 The filter expression consists of one or more primitives. Primitives usually consist of an id (name or number) preceded by one or more qualifiers. There are three different kinds of qualifier: type, dir, proto.过滤表达式可以由 type, dir, proto 中的一个或多个组成。 type: type qualifiers say what kind of thing the id name or number refers to. Possible type are: host, net, port and portrange. E.g. host lizs.cc, net 127.0, port 80, portrange 6000-6008, etc. 1234# 监听地址以 127. 开头的数据包，如`127.0.0.1`, `127.0.1.1`等sudo tcpdump -c 3 -i any -n# net 127# 监听 lizs.ccsudo tcpdump -c 3 -i any -n# host lizs.cc dir: dir qualifiers specify a particular transfer direction to and/or from id. Possible directions are src, dst, src or dst, src and dst, ra, ta, addr1, addr2, addr3, and addr4. E.g., src foo, dst net 128.3, src or dst port ftp-data. The ra, ta, addr1, addr2, addr3, and addr4 qualifiers are only valid for IEEE 802.11 Wireless LAN link layers. 1234# 监听源地址为 127.0.0.1 的数据包sudo tcpdump -c3 -i any -n# src net 127.0.0.1# 监听源地址或目的地址为 lizs.cc 的数据包sudo tcpdump -c3 -i any -n#tttt src or dst host lizs.cc proto: proto qualifiers restrict the match to a particular protocol. Possible protos are: ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp and udp. E.g., ether src foo, arp net 128.3, tcp port 21, udp portrange 7000-7009, wlan addr2 0:2:3:4:5:6.1234# 监听 TCP 的数据包sudo tcpdump -c 3 -i any -n#qtttt tcp# 监听所有网络接口的 ICMP 数据包sudo tcpdump -c3 -i any -n#qtttt icmp 除了以上 primitive，还有其它 primitive，如：gateway, broadcast, less, greater以及算术表达式，等等。 多个修饰语 (qualifier) 可以用and, or, not, !等连接组合起来，也可以用括号()指定优先级，不过要用反斜杠转义\\(\\)或 expression 用单引号或双引号括起来。12345678910111213141516# 监听源端口为 80 或 443 的 TCP 数据包sudo tcpdump -n#qtttt tcp src port 80 or 443 # 或者 sudo tcpdump -n#qtttt src port 80 or 443 and tcp# 监听 lizs.cc 的 TCP 数据包，不过过滤掉和 github.com 通信的数据包sudo tcpdump -i any tcp host lizs.cc and not github.com# 监听端口不为 1080 的非 TCP 数据包sudo tcpdump ! tcp port ! 1080# 监听目的端口不为 1080 的 tcp 或 arp 包sudo tcpdump dst port ! 1080 and \\(tcp or arp\\) # 或sudo tcpdump 'dst port ! 1080 and (tcp or arp)' # 或sudo tcpdump tcp or arp dst port ! 1080# 监听 ftp 端口或 telnet 端口的数据包sudo tcpdump -i any port ftp or telnet# 监听所有通过网关 snup 的 ftp 数据包sudo tcpdump -i any 'gateway snup and (port ftp or ftp-data)'# 抓取数据包长度小于或等于 65 的 tcp 数据包。sudo tcpdump -i any tcp and less 65 更多端口信息可以查看/etc/services。 表达式中的切片proto[x]，表示协议中的第 x 个字节的内容。proto为相应的协议名称，如tcp, ip。proto[x:y]，表示协议中从 x 位置开始的 y 个字节内容。proto为相应的协议名称，如tcp, ip。12345678910# 过滤掉源端口小于 1024 的 TCP 连接sudo tcpdump -i any -n#qtttt 'tcp[0:2] &lt; 1024'# 打印目的端口为 443 的 TCP 连接数据包sudo tcpdump -i any -n#qtttt 'tcp[2:2] = 443'# 打印源端口不是 443 的 TCP 连接sudo tcpdump -i any -n#qtttt 'tcp[0:2] != 443'# 抓取 SYN 包并保存到 syn_packets.pcap 文件中sudo tcpdump -i any -w syn_pckets.pcap 'tcp[13] == 2'# 抓取 HTTP 协议的 GET 方法请求的数据包sudo tcpdump -i any -n#qtttt 'tcp[20] = 0x47 and tcp[21] = 0x45 and tcp[22] = 0x54' TCP 首部共 20 字节: 16 位 (2 字节) 的源端口和 16 位的目的端口；32 位系列号；32 位确认序列号；4 位首部长度；6位保留位；6 位标志位 (URG, ACK, PSH, RST, SYN, FIN，各占一位)；等等。下标从 0 开始，所以，源端口为tcp[0:2]，目的端口为tcp[2:2]，SYN 标志位在第 14 字节 (即 13),值为 000010 == 2。 因为，要计算各协议的标志位很麻烦，所以，提供了部分别名： proto[icmptype]，ICMP 类型。同时 ICMP 类型有： icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redirect, icmp-echo 等等。 proto[icmpcode]，ICMP 符号。 proto[tcpflags]，TCP 标志位。标志值有：tcp-urg, tcp-ack, tcp-psh, tcp-syn, tcp-fin。12# 抓取 SYN 包sudo tcpdump -i any 'tcp[tcpflags] = tcp-syn' 更多 expression 的详细语法可以通过 man pcap-filter 查看。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"cmd","slug":"cmd","permalink":"https://lizsgh.github.io/tags/cmd/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Linux command - netstat","slug":"linux/cmd_netstat","date":"2018-12-04T12:54:25.667Z","updated":"2018-12-04T12:54:25.659Z","comments":true,"path":"2018/12/04/linux/cmd_netstat/","link":"","permalink":"https://lizsgh.github.io/2018/12/04/linux/cmd_netstat/","excerpt":"","text":"nestat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships. 1netstat [options] netstat 常见用法： (none): By default, netstat displays a list of open sockets. -a, --all: Show both listening and non-listening sockets. -l, --listening: Show only listening sockets. (these are omitted by default.) -t, --tcp: 显示 TCP 协议连接的 socket。 -u, --udp: 显示 UDP 协议连接的 socket。 -n, --numeric: 显示数字形式的地址，而不用解析主机、端口和用户名。 -p, --program: 显示 socket 连接程序的 PID 和名称。 -c, --continuous: 每秒钟打印一次输出结果。 -s, --statistics: Display summary statistics for each protocol. 显示每种协议收发数据包的统计结果。 -g, --groups: Display multicast group membership information for IPv4 and IPv6. 显示 IPv4 和 IPv6 的 IGMP 组播组成员关系信息。 -i, --interfaces: Display a table of all network interfaces. 显示网络接口信息。 -r, --route: Display the kernel routing tables. 显示内核路由表信息。 -M, --masquerade: Display a list of masqueraded connections. -A, --protocol: 指定要显示哪些的地址族的连接，多个协议用逗号分隔。常见地址族，如：inet, inet6, unix, ipx, ax25, netrom, econet, ddp, bluetooth。也可以作为参数使用: –inet|-4, –inet6|-6, –unix|-x, –ipx, –ax25, –netrom, –ddp, –bluetooth。 输出结果： Proto: 协议 Recv-Q: 此 socket 连接的应用程序未拷贝的字节数。 Send-Q: 远程主机未确认的字节数。 Local Address: socket 连接的本地地址信息 (本地主机名和端口)。 Foreign Address: socket 连接的远程地址信息 (远程主机名和端口)。 State: socket 状态 (ESTABLISHED, SYN_SENT, SYN_RECV, FIN_WAIT1, FIN_WAIT2, TIME_WAIT, CLOSED, CLOSE_WAIT, LAST_ACK, LISTEN, CLOSING, UNKNOWN)。 User: The username or the user id (UID) of the owner of the socket. PID/Program_name: socket 连接的所属应用程序的 PID 和程序名称。 等等 1234567891011121314151617181920# 显示连接状态的 socketnetstat# 显示所有 socketnetstat -a# 显示监听状态的 socketnetstat -l# 显示 TCP 协议并且在监听状态的 IPv6 连接netstat -tl6# 禁用反向域名解析，显示数字形式的地址netstat -n# 显示 UDP 协议监听中的 socket 连接，并显示数字形式的地址和用户名、PIDnetstat -ulnp# 显示内核路由表netstat -r# 每秒刷新显示内核路由表信息netstat -rc# 显示特定地址族的 socketnetstat -lA inet # 显示听中的 IPv4 连接netstat -l --protocol=inet6 # 显示监听中的 IPv6 连接netstat -A inet6,ddp 注意当 netstat -p显示的程序信息看不到的时候 (如-)，可能是权限问题。使用 sudo 提权或切换 root 用户执行命令。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"cmd","slug":"cmd","permalink":"https://lizsgh.github.io/tags/cmd/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Docker - Install Docker (CE) for Ubuntu","slug":"docker/installation","date":"2018-12-02T13:46:27.349Z","updated":"2018-12-02T13:46:27.345Z","comments":true,"path":"2018/12/02/docker/installation/","link":"","permalink":"https://lizsgh.github.io/2018/12/02/docker/installation/","excerpt":"","text":"Get Docker CE for Ubuntu 安装前准备工作 Ubuntu 系统要求安装 Docker CE，需要 64 位的以下版本的 Ubuntu 系统： Bionic 18.04 (LTS) Xenial 16.04 (LTS) Trusty 14.04 (LTS) 卸载旧版本 Docker旧版本的 Docker 名为 docker 或 docker-engine。 1sudo apt remove docker docker-engine docker.io 安装 Docker CE1. 更新系统软件源1sudo apt-get update 2 安装让 apt 工具支持 HTTPS 的相关库12345sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 3. 添加官方 GPG 密钥1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 4. 设置 Docker 的稳定版仓库（amd64）1234sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 5. 安装 Docker CE12sudo apt-get updatesudo apt-get install docker-ce 安装 Docker Compose Install Docker Compose 方法一 用以下命令下载 Docker Compose，将 $dockerComposeVersion 代替为要下载的版本。1curl -L https://github.com/docker/compose/releases/download/$dockerComposeVersion/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 如，下载 1.14.0 版本的 Docker Compose：1curl -L https://github.com/docker/compose/releases/download/1.14.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose https://github.com/docker/compose/releases 更改下载的 /usr/local/bin/docker-compose 文件权限： 1sudo chmod +x /usr/local/bin/docker-compose 测试是否安装成功 1docker-compose --version 方法二通过 Python 的 pip 来安装：1sudo pip install docker-compose 配置 DaoCloud 加速器Docker Hub 提供众多镜像，你可以从中自由下载数十万计的免费应用镜像， 这些镜像作为 docker 生态圈的基石，是我们使用和学习 docker 不可或缺的资源。为了解决国内用户使用 Docker Hub 时遇到的稳定性及速度问题 DaoCloud 推出永久免费的新一代加速器服务。 首先，在 DaoCloud 注册个人账号，登录之后在个人 dashboard 右上角，头像左边有一个火箭标志的加速器图标，点击进去，安装介绍操作就可以了。","categories":[{"name":"Docker","slug":"Docker","permalink":"https://lizsgh.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://lizsgh.github.io/tags/docker/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"https://lizsgh.github.io/categories/Docker/"}]},{"title":"Object Oriented Programming","slug":"python/object_oriented_programming","date":"2018-11-24T12:45:11.477Z","updated":"2018-11-24T12:45:11.469Z","comments":true,"path":"2018/11/24/python/object_oriented_programming/","link":"","permalink":"https://lizsgh.github.io/2018/11/24/python/object_oriented_programming/","excerpt":"","text":"OOP (Object Oriented Programming)面向对象的三大基本特征：封装、继承、多态。 封装：把客观事物封装成抽象的类，而且类中特定的属性或方法可以只提供给特定的类或对象使用，从而做到隐蔽性和安全性。 继承：继承可以让新创建的类获得被继承的类的属性和方法。通过继承创建的新类成为“子类”或“派生类”，被继承的类成为“父类”、“基类”或“超类”。继承概念的实现：实现继承和接口继承。 实现继承，是指子类可以直接使用基类的属性和方法； 接口继承，是指基类仅提供了一个接口方法，子类必须先实现了才能够使用。 某些 OOP 语言中，一个子类可以继承多个基类 (多重继承)。 多态：指子类重新定义父类的虚方法 (virtual, abstract)。当子类重新定义了父类的虚方法后，父类根据赋给它的不同子类，动态调用属于子类的该方法。 面向对象的五大基本原则：单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则。 单一职责原则 (SRP, Single Responsibility Principle)：就一个类而言，应该仅有一个引起它变化的原因。简言之，就是一个类的功能要单一。 开放封闭原则 (OCP, Open-Close Principle)：对扩展开放，对修改封闭。 里氏替换原则 (LSP, the Liskov Substitution Principle)：子类应当可以替换父类出现在父类能够出现的任何地方。 依赖倒置原则 (DIP, the Dependency Inversion Principle)：传统结构化编程中，最上层的模块通常要依赖下层模块来实现，即高层依赖低层。DIP 原则就是要让高层模块不依赖低层模块，二者都应该依赖抽象。抽象不应该依赖具体 (细节)，而具体 (细节) 应该依赖抽象。模块间的依赖通过抽象发生，实现类之间不产生直接的依赖关系，而是通过接口或抽象类产生。接口或抽象类不依赖于实现类；实现类依赖于接口或抽象类。 接口隔离原则 (ISP, Interface Segregation Principle)：使用多个专门的接口比使用大一的总接口要好。使用多个专门的接口比使用大一的总接口要好 重载与覆盖重载 (overload)重载，指函数具有相同的函数名，但这些同名函数具有不同的参数列表 (如：参数个数、参数类型、参数顺序等)。返回值可以相同也可以不同。 重载的实现：编译器根据不同的参数表对同名函数的名称做修饰，如：function func(p:integer) -&gt; integer_func； function func(p:string) -&gt; string_func。对编译器而言，这些同名方法就成了不同的方法，而且它们的调用地址在编译期间就绑定了，可以说是“早绑定”或“静态绑定”。 覆盖/重写 (override)覆盖存在类中，子类重写从父类继承过来的函数。但函数名、返回值、参数列表都必须和父类一样。当子类的实例对象调用的时候，会先调用自身的，没有再调用父类的。 如果子类覆盖的是基类的虚函数，则可以实现多态。当子类重新定义基类的虚函数后，基类指针可以根据赋给它的不同子类指针动态的调用子类中的该函数，可以做到动态绑定，即多态。 重载与覆盖 重载要求函数名相同，但是参数列表不同，返回值可以相同也可以不同；覆盖要求函数名、参数列表和返回值都相同。 在类中，重载是同一个类中不同成员函数之间的关系；而覆盖则是子类和基类之间不同成员函数之间的关系。 重载函数的调用是根据参数列表来决定调用哪个函数；覆盖函数的调用则根据对象的不同来决定调用哪个函数。 在类中，函数重载不能够实现多态；而子类对基类虚函数的覆盖则可以实现多态。 多态与重载 多态：基于对抽象方法的覆盖来实现，当子类重新定义基类的虚函数后，基类根据赋给它的不同子类，动态的调用子类中的该函数。多态可以说是“晚绑定”或“动态绑定”。 重载：指函数具有相同的函数名，但这些同名函数具有不同的参数列表。在编译期间就已经绑定调用地址了，是“早绑定”或“静态绑定”。而且，重载只是一种语言特性，一种语法规则，与多态无关，与面向对象也无关。 构造函数与析构函数构造函数：一种特殊的方法，主要用于在创建对象时初始化对象。析构函数：与构造函数相反，当对象结束其生命周期 (如对象所在的函数已调用完毕)，系统自动执行析构函数。 Python 分别用__init__()和__del__()来实现构造函数和析构函数。 混入类 混入类被定义为，一种被设计为通过继承与其它类结合的类，它给其它类提供可选择的接口或功能。 从概念上讲，混入类不定义新类，只是提供接口或功能，便于重用；从实现上讲，混入类要求多继承。 混入类为多个不相干的子类提供方法实现，便于重用，但不会实例化，并且具体类不能只继承混入类。 Python 中没有声明混入类的正式方式，Luciano 推荐在名称中加入Mixin后缀。 12345678910111213class People(object): passclass HasCarsMixin(object): def has_cars(self): return Trueclass NoHasCarsMixin(object): def has_cars(self): return Falseclass XiaoMing(People, HasCarsMixin): pass OOP - Python 在 Python 中一切都是对象。 Python 支持多重继承，内置函数super()可以解决多重继承中父类方法被多次调用的问题。 Python 并没有覆盖 (override) 的概念，从这个角度来说，Python 不支持多态。 12345678910111213141516171819202122232425262728class A(object): def __init__(self): pass def __del__(self): pass def func(self): return 'A.func'class B(A): def func(self, arg=0): return 'B.func'class C(A): passB().func() # B.funcB.func&lt;function __main__.B.func&gt;B().func&lt;bound method B.func of &lt;__main__.B object at 0x7f..&gt;&gt;C().func() # A.funcC.func&lt;function __main__.A.func&gt;C().func&lt;bound method A.func of &lt;__main__.A object at 0x7f...&gt;&gt; Python 中没有覆盖 (override) 的概念，子类重写父类的方法，其实只是把同名函数绑定到不同的函数对象。 Python 没有像 Java 等语言一样的接口概念，为了解决继承结构中接口和实现的问题，可以人为的设计一些规范。 123class A(object): def func(self): raise NotImplementdError 继承A的子类如果要使用func方法就要先实现，不然抛出异常。纵然如此，A还是可以被实例化的，而且无法强制A的子类必须实现func接口。Python 虽然没有接口的语法定义，但是还是有抽象类的概念的，使用抽象类实现类似接口的功能： 12345from abc import abstractmethod, ABCMetaclass A(metaclass=ABCMeta): @abstractmethod def func(self): pass Python 实现抽象类需要使用 abc 模块，抽象类A不会被实例化。 Python 不支持多态，也不用支持多态，Python 是一种多态语言，崇尚鸭子类型 (duck typing，当看到一只鸟走起来像鸭子、游泳起来像鸭子和叫起来也像鸭子，那么这只鸟就可以被成为鸭子)。鸭子类型不关注对象的类型，而是关注对象的行为 (方法)。鸭子类型像多态一样工作，但是没有继承关系。类与类之间不用共同继承同一个父类，只需要将它们做的像同一种事物，就能够实现：面向接口编程，而不是面向实现编程。 耦合与内聚耦合耦合性，也称块间联系，是软件系统结构中模块间相互关联紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。耦合程度取决于各个模块间接口的复杂程度、调用的方式，以及传递的信息。耦合分为七种： 内容耦合：一个模块直接访问另一个模块的内容。具体表现为： 一个模块直接访问另一个模块的内部数据。 一个模块不通过正常入口而直接转入到另一个模块的内部。 两个模块有一部分代码重叠 (该部分代码具有一定的独立功能)。 一个模块有多个入口。 公共耦合：一组模块都访问同一个公共数据环境。公共数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。 外部耦合：一组模块访问同一全局简单变量而不是同一全局数据结构，而且不通过参数传递该全局变量的信息。 控制耦合：模块之间传递的不是数据信息，而是控制信息 (如，标志、开关量等)，一个模块控制了另一个模块的功能。 标记耦合：调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称特征耦合。标记耦合的模块间传递的不是简单变量，而是像高级语言中的数据名、记录名和文件名等数据结果，这些名字即为标记，其实传递的是地址。 数据耦合：调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的值传递。 非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，非直接耦合的模块独立性最强。 耦合是影响软件复杂程度和设计质量的一个重要因素，为提高模块的独立性，应建立模块间尽可能松散的系统，在设计上我们应采用一下原则：若模块间必须存在耦合，应尽量使用数据耦合，少用控制耦合，慎用或有控制地使用公共耦合，并限制公共耦合的范围，尽量避免内容耦合。 内聚内聚性，又称内联系，指模块的功能强度的度量，即一个模块内容各个元素彼此结合的紧密程度的度量。若一个模块内个元素 (语名之间、程序段之间) 联系的越紧密，则它的内聚性就越高。 所谓高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一职责原则。 内聚有如下分类 (顺序按照内聚度由弱到强)： 偶然内聚：也称巧合内聚，模块内的各部分之间没有联系，或即使有联系也和松散，只是偶然地被凑到一起。 逻辑内聚：把几种相关的功能组合到一起，每次被调用时，由传递给模块的参数来确定该模块应该完成哪种功能。 时间内聚：又称经典内聚，这种模块大多为多功能模块，但模块的各个功能的执行与时间有关，通常要求所有功能必须在同一时间内执行。例如，初始化模块和终止模块。 过程内聚：构件或者操作的组合方式时，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。模块完成多个需要按一定的步骤一次完成的功能。(过程相关—控制耦合)。例如：在用程序流程图设计模块时，若将程序流程图中的一部分划出各自组成模块，便形成过程内聚。 通信内聚：指模块内所有处理元素都在同一个数据结构上操作或所有处理功能都通过公用数据而发生关联 (有时称之为信息内聚)。即指模块内各个组成部分都是用相同的数据或产生相同的数据结构。 顺序内聚：一个模块中各个处理元素和同一个功能密切相关，而且这些处理必须顺序执行，通常一个处理元素的输出是后一个处理元素的输入。顺序内聚的内聚度比较高，但缺点是不如功能内聚易于维护。 功能内聚：模块内所有元素的各个组成部分都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分。即模块仅包括为完成某个功能所必须的所有成分，这些成分紧密联系、缺一不可。 功能内聚是最强的内聚，其优点是功能明确。判断一个模块是否功能内聚，一般从模块名称就能够看出。如果模块名称只有一个动词和一个特定的目标 (单数名词)，一般来说就是功能内聚，如：“计算水费”、“计算产值”等模块。 模块划分时，要遵循“一个模块，一个功能”的原则，尽可能使模块达到功能内聚。","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"Python - Abstract Base Classes","slug":"python/abstract_base_classes","date":"2018-11-24T10:30:15.451Z","updated":"2018-11-24T10:30:15.439Z","comments":true,"path":"2018/11/24/python/abstract_base_classes/","link":"","permalink":"https://lizsgh.github.io/2018/11/24/python/abstract_base_classes/","excerpt":"","text":"Python 中没有接口的正式语法支持，但是 Python 有抽象类的概念。抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化。如果说类是从一堆对象中抽取相同的内容而来的，那么抽象类就是从一堆类中抽取相同的内容而来的，内容包括数据属性和函数属性。 抽象是为了继承，接口继承实质上是要求，“做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象”。这在程序设计上，叫做归一化。即基于同一个接口实现的类，这些类产生的对象在使用时，用法一样。 抽象类的一些特性： 抽象类不能被实例化。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 在继承抽象类的过程中，应该尽量避免多继承；而在继承接口的时候，反而使用多继承。(接口隔离原则) Python 中实现抽象类，需要使用 abc 模块。Python 3+123456789101112131415from abc import ABCMeta, abstractmethodclass People(metaclass=ABCMeta): @abstractmethod def name(self): passclass Teacher(People): @property def name(self): return 'lizs'People()TypeError: Can't instantiate abstract class People with abstract methods nameTeacher().name # lizs Python 2.7123456789class People(object): __metaclass__ = ABCMeta @abstractmethod def name(self): passPeople()TypeError: Can't instantiate abstract class People with abstract methods name 为了兼容 Python 2 和 Python 3，使用six模块。12345678910from abc import ABCMetaimport six@six.add_metaclass(ABCMeta)class People(object): def name(self): passPeople()TypeError: Can't instantiate abstract class People with abstract methods name","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Data model","slug":"python/data_model","date":"2018-11-08T07:06:15.150Z","updated":"2018-11-08T07:06:15.142Z","comments":true,"path":"2018/11/08/python/data_model/","link":"","permalink":"https://lizsgh.github.io/2018/11/08/python/data_model/","excerpt":"","text":"Objects, values and typesAll data in a Python program is represented by objects or by relations between objects.Every object has an identity, a type and a value. Python 对象创建之后，identity 是不会变的，你可以将它看成该对象在内存中的地址。 Python 的 is 操作符比较的就是对象的 identity，== 比较的是 value。 Python 的内置函数 id() 可以获取一个整数，代表了该对象的 identity。CPython 和 IPython id() 获取的是内存的地址。 Python 对象的 type 也是不可以改变的，可以用内置函数 type() 获取对象的 type。 Python 对象根据 value 是否可以改变分为：可变对象(mutable)和不可变对象(immutable)。 常见的 mutable 对象：list, dict, bytearray, set, etc；immutable 对象：int, float, complex, str, tuple, bytes, frozeset, etc。 如果 immutable 对象中包含了 mutable 对象，该 mutable 对象的 value 是可变的。如： 123456789101112131415&gt;&gt;&gt; a = []&gt;&gt;&gt; id(a)140537664498648&gt;&gt;&gt; b = (a, 1)&gt;&gt;&gt; b([], 1)&gt;&gt;&gt; id(b)140537664384752&gt;&gt;&gt; a.append(0)&gt;&gt;&gt; b([0], 1)&gt;&gt;&gt; id(a)140537664498648&gt;&gt;&gt; id(b)140537664384752 For immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed. 新建的 immutable 对象可能是已经存在 imutable 对象的一个引用，新建的 mutable 对象是一个新的对象。 123456789101112&gt;&gt;&gt; a = &apos;abcde&apos;&gt;&gt;&gt; b = &apos;abcde&apos;&gt;&gt;&gt; id(a)140537664090832&gt;&gt;&gt; id(b)140537664090832&gt;&gt;&gt; c = []&gt;&gt;&gt; d = []&gt;&gt;&gt; id(c)140537664333368&gt;&gt;&gt; id(d)140537664498648 对于 int 类型的 imutable 对象，值在 -5 - 256 之间的时候，新建对象都是引用。 12345678910111213141516&gt;&gt;&gt; a = -6&gt;&gt;&gt; b = -6&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a = -5&gt;&gt;&gt; b = -5&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a = 256&gt;&gt;&gt; b = 256&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a = 257&gt;&gt;&gt; b = 257&gt;&gt;&gt; a is bFalse 注意：c = d = []，mutable 对象 c 和 d 是引用关系，指向同一个对象。 12345678&gt;&gt;&gt; c = d = []&gt;&gt;&gt; id(c)140537664175712&gt;&gt;&gt; id(d)140537664175712&gt;&gt;&gt; e = c&gt;&gt;&gt; id(e)140537664175712 Python Garbage Collection","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"},{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"HTTP - Authentication","slug":"http/http_authentication","date":"2018-01-31T16:00:00.000Z","updated":"2019-01-06T15:12:50.322Z","comments":true,"path":"2018/02/01/http/http_authentication/","link":"","permalink":"https://lizsgh.github.io/2018/02/01/http/http_authentication/","excerpt":"","text":"HTTP 提供了一套访问控制和认证的通用框架。最常用的 HTTP 认证方案是 HTTP Basic Authentication。 HTTP 常规的认证流程HTTP 通用的认证模型非常简单，就是质询/响应 (challenge/response) 框架。以 HTTP Basic Authentication 为例： 当客户端请求一个需要认证的资源时，服务器返回一条 401 (Unauthorized) 响应。并在 WWW-Authenticate 响应首部携带如何进行验证的相关信息，其中至少包含一种质询方式。 然后，客户端根据WWW-Authentication提供的认证要求，在请求中添加Authorization首部字段进行认证，值为相应认证方案的认证凭证 (如 Basic 认证方案：Basic + “用户名:密码”的 base64 编码)。 服务器验证通过，则返回正常的请求。如果认证错误，则返回 403 (Forbidden)。 代理认证 (Proxy Authentication)服务器可以委托代理服务器提供内部资源的统一访问控制，即代理认证。如果使用了 HTTP 代理服务器，客户端的访问的其实是代理服务器，请求先经过代理服务器，然后代理服务器根据请求的内容处理请求 (如，过滤掉请求或将请求转发到不同的服务器等等)。如果你的网站是发布到公网上的话，你的代理服务器就暴露在公网上了。如果你的代理服务器没有设置任何访问权限，就可能会被网上的大量代理扫描程序扫描出来，公布到各大免费代理站点。所以，代理服务器最好设置账号密码，而且不要是弱密码。 代理认证与 Basic 认证的过程类似，同样的基于 HTTP 质询/响应框架。 Basic Authentication Proxy Authentication 401 407 WWW-Authenticate Proxy-Authenticate Authorization Proxy-Authorization WWW-Authenticate 与 Proxy-AuthenticateWWW-Authenticate与Proxy-Authenticate响应头部指定了获取资源访问权限的身份验证方法。12WWW-Authenticate: &lt;type&gt; realm=&lt;realm&gt;Proxy-Authenticate: &lt;type&gt; realm=&lt;realm&gt; &lt;type&gt;：指验证的类型，如 Basic, Bearer, Digest, HOBA, Mutual等。 &lt;realm&gt;：保护区域的描述，或指定保护的范围。如果未指定 realm，通常客户端显示一个格式化的主机名来代替。 Authorization 与 Proxy-AuthorizationAuthorization与Proxy-Authorization请求消息首部，包含用来向 (代理) 服务器验证身份的凭证。同样需要指明验证的类型，其后跟着验证信息。验证信息可以被编码或者加密，取决于采用的是哪种验证类型。12Authorization: &lt;type&gt; &lt;credentials&gt;Proxy-Authorization: &lt;type&gt; &lt;credentials&gt; Nginx 搭建 HTTP Basic AuthenticationNginx ngx_http_auth_basic_module 可以实现 HTTP Basic Authentication 协议。1234location / &#123; auth_basic &apos;authentication&apos;; auth_basic_user_file conf.d/htpasswd;&#125; auth_basic: string | off，默认 off，不开启。开启 HTTP Basic Authentication 只需要填写一个字符串，该字符串会作为 realm 的值，在服务器质询客户端的返回头部信息 WWW-Authenticate 中显示，如：WWW-Authenticate: Basic realm=&quot;Authorication&quot;。 auth_basic_user_file: 指定访问的用户名和密码的配置文件，可以是相对路径或绝对路径的文件。当使用相对路径时，则相对 nginx 安装配置目录，如/etc/nginx/或/etc/nginx/conf.d/试了下都可以。文件配置内容格式，如htpasswd： 123# commentname1:password1name2:password2:comment 可以用 # 注释 可以设置多个用户名和密码，每行一个，用户名和密码之间用 : 隔开，注释也可以写在密码后面，用 : 隔开。 用户名直接填写，但是密码需要经过加密。如，Linux 系统，密码 123456 可以用 openssl passwd 123456 生成。 假设，刚刚搭建的服务器地址为：127.0.0.1。从浏览器访问 http://127.0.0.1 就会收到一个 401 质询，弹出一个用户名和密码的输入框。用户输入账号和密码之后，浏览器会用 : 将其连接起来，编成 base64 编码，然后将其放在请求头部的 Authorization 中发送给服务端。服务端验证通过后就可以正常浏览页面的内容了。 HTTP 基础认证过程 假如，nginx 配置好的认证页面为 http://127.0.0.1 telnet 建立一条 http 连接 1telnet 127.0.0.1 80 发送正常的请求，会返回 401 12345678910HEAD / HTTP/1.1Host: 172.16.105.114HTTP/1.1 401 UnauthorizedServer: BDSCAN/1.5.0Date: Wed, 17 Jan 2018 08:26:04 GMTContent-Type: text/htmlContent-Length: 195Connection: keep-aliveWWW-Authenticate: Basic realm=&quot;authentication&quot; 发送带验证信息的请求 12345678910111213HEAD / HTTP/1.1Host: 172.16.105.114Authorization: Basic bGl6czoxMjM0NTY=HTTP/1.1 200 OKServer: BDSCAN/1.5.0Date: Wed, 17 Jan 2018 08:26:59 GMTContent-Type: text/htmlContent-Length: 334Last-Modified: Tue, 16 Jan 2018 08:55:10 GMTConnection: keep-aliveETag: &quot;5a5dbdee-14e&quot;Accept-Ranges: bytes 验证信息放在请求头的 Authorization，即 Authorization: Basic base64-username-and-password。base64-username-and-password 为用户名和密码用 : 连接起来，并经过 base64 编码等到的字符串 (即上面的 bGl6czoxMjM0NTY=) 。Python(python2) 生成：12345import base64username = &apos;lizs&apos;password = &apos;123456&apos;msg = base64.b64encode(&apos;%s:%s&apos; % (username, password))","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"https://lizsgh.github.io/tags/http/"}],"keywords":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}]},{"title":"linux command - find","slug":"linux/cmd_find","date":"2017-12-31T16:00:00.000Z","updated":"2018-09-12T08:31:46.194Z","comments":true,"path":"2018/01/01/linux/cmd_find/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/linux/cmd_find/","excerpt":"","text":"findsearch for files in a directory hierarchy 1find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] -H, -L, -P选项 -H, -L, -P 用来控制软连接的处理。 -H: 默认行为，不搜索软连接下的目录或文件。 -L: 搜索软链接。 -P: 不搜索软链接下的目录或文件，除非 当没有指定 -H, -L, -P时，-H 是默认行为，即不搜索软链接下的目录和文件。同时指定多个选项，最后一个有效。如：find -H -L .，-H 无效，-L 有效。 -D debugopts, -Olevel -D debugopts: 打印诊断信息 -Olevel: 允许查询优化，level: 0, 1, 2, 3 starting-point查询开始路径，默认为当前目录 .。 expressionexpression 表达式可以由以下部分组成：tests, actions, global options, positional options, operators。 tests -name pattern按目录名或文件名查找。pattern 不能够有 /，否则无效，如：-name a/b 无效。 123find -name &quot;apps.py&quot; # 查找当前目录下的 apps.py 文件find -name &quot;apps&quot; # 查找当前目录下名称为 apps 的文件或目录find /home -name &quot;app*&quot; # 查找 /home 目录下名称匹配 app* 的文件或目录 -iname patterniname(insensitive name). 用法同 -name，只是 pattern 对大小写不敏感。 -path pattern按路径查找。pattern 是路径。 1234find -path &quot;apps&quot; # 无结果，因为 apps 不是路径find -path &quot;./apps&quot; # 查找当前目录下的 apps 目录或文件find -path &quot;./apps*&quot; # 查找当前目录下路径以 apps 开头的目录或文件find /home -path &quot;*apps*&quot; # 在 /home 目录下查找包含 apps 的目录或文件 -ipath patterninsensitive path, 用法同 -path, 只是 pattern 对大小写不敏感。 -regex pattern和 -path 差不多。 -user uname按照文件或目录所属用户查找。 -group gname按照文件或目录所属组查找。 更多选项查看 find --help 或 man find。 actions -exec command ;对搜索的结果执行命令 command。如果命令是用搜索结果作为参数的，可以用 {} 作为占位符。 12find -path &quot;./apps*&quot; -execfind -path &quot;./apps*&quot; -exec file &#123;&#125; \\; -ok command ;类似 -exec，不过在执行命令 command 之前先要经过用户同意 (y/n) operators (expr)优先操作符，和一般运算的 () 一样。 ! expr取反 expr1 expr2与，即 expr1 和 expr2，相当于 Python 表达式 expr1 and expr2。 expr1 -a expr2同 expr1 expr2 expr1 -and expr2同 expr1 expr2，但是不遵循 POSIX。 expr1 -o expr2或，即 expr1 或 expr2，相当于 Python 表达式 expr1 or expr2。 expr1 -or expr2同 expr1 -o expr2，但是不遵循 POSIX。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"cmd","slug":"cmd","permalink":"https://lizsgh.github.io/tags/cmd/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"TCP/IP - TCP 三次握手连接和四次握手关闭","slug":"tcp/3-handshake_and_4-waves","date":"2017-12-31T16:00:00.000Z","updated":"2018-12-04T08:55:00.033Z","comments":true,"path":"2018/01/01/tcp/3-handshake_and_4-waves/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/tcp/3-handshake_and_4-waves/","excerpt":"","text":"TCP 首部TCP 数据被封装在 IP 数据报中： TCP 首部数据格式： 每个 TCP 段都包含了源端口号和目的端口号，用于寻找发端和接收端的应用程序。这两个端口号加上 IP 首部的源端 IP 地址和目的端 IP 地址就可以确定一个TCP连接。 序号：sequence number, 用来标识从 TCP 发端向 TCP 收端发送的数据字节流。 确认序号：acknowledgement number, 确认序号只有在 ACK 标志位开启(值为1)时有效，值为要确认的数据包的 sequence number + 1。如客户端发送了一个数据包(序号为x)给服务端，则服务端收到这个数据包之后要回复一个确认数据包(确认序号为x + 1)。 标志位：共有 6 个，每个标志位用 1 和 0 分别表示开和关状态。 URG: The urgent point is valid. 当 URG=1 时，表示报文段中有紧急数据，应尽快传送。 ACK: The acknowledgement number is valid. 确认标志位，当 ACK=1 时，表示这是一个确认包。 PSH: The receiver should pass this data to the application as soon as possible. 当 PSH=1 时，接收端应尽快将数据交给应用程序。 RST: Reset the connection. 复位标志位，当 RST=1 时，表示 TCP 连接出现了严重错误，必须释放连接，重新建立连接。 SYN: Synchronize sequence numbers to initiate a connection. 在建立连接时，用来同步序号。SYN=1，ACK=0 表示发起请求连接；SYN=1，ACK=1 表示同意建立连接请求。 FIN: The sender is finished sending data. 检验和：该字段检验的范围包括首部和数据，由发送端计算和存储，并由接收端进行检验。 窗口：用来控制对方发送的数据量，通知发放已确定的发送窗口上限。 紧急指针：在标志位 URG=1 时才有效，它指出本报文中的紧急数据的字节数。 每个TCP数据包的格式都是固定的，都包含了端口号，序号，确认序号，标志位等。 三次握手和四次握手TCP 建立连接需要经过三次握手 (three-way handshake)，关闭连接需要经过四次握手。 建立连接的三次握手 第一次，客户端发送一个数据包：TCP首部的标志位SYN被设置为1，并且序号为初始序号ISN(Initial Sequence Number)。此时，客户端处于 SYN_SENT 状态。 第二次，服务器收到客户端的连接请求后，由标志位SYN为1知道这个是建立TCP连接的请求，返回一个数据包：TCP首部的标志位SYN和ACK都被设置为1；序号为服务器端的ISN；确认序号为客户端序号 + 1。此时，服务器处于 SYN_RCVD 状态。 第三次，客户端收到服务端的返回数据之后，由标志位SYN和ACK为1知道服务器同意建立TCP连接的确认数据包。检查确认序号的值(第一次握手客户端发送的序号 + 1)，标志位SYN和ACK都正确之后，返回一个数据报给服务器：SYN=0；ACK=1；序号递增 (即上次序号 + 1)；确认序号的值为服务器发送过来的序号 + 1。服务器收到这个数据包并检查数据报正确之后，客户端和服务端成功建立TCP连接，进入 ESTABLISHED 状态。 关闭连接的四次握手 第一次，主动关闭的那一端(假设为客户端)发送一个关闭连接FIN数据包：TCP首部的标志位FIN设置为1；序号为正常递增值。此时，客户端进入为 FIN_WAIT_1 状态。 第二次，另一端收到数据包之后，由FIN为1知道这是另一端关闭连接的请求。然后返回一个确认数据包：TCP首部标志位ACK设置为1；确认序号为发端序号 + 1；序号正常递增值。此时，服务器进入 CLOSE_WAIT 状态。当客户端收到确认数据包之后进入 FIN_WAIT_2 状态。 第三次，当服务端发送完数据之后，向客户端发送一个关闭连接数据包：TCP首部的标志位FIN设置为1;序号为正常递增值。此时，服务端进入 LAST_ACK 状态。 第四次，客户端收到数据包之后，由FIN为1知道这是服务端要关闭连接了，然后返回一个确认数据包：TCP首部标志位ACK设置为1；确认序号为收到的序号 + 1；序号为正常递增值。此时，客户端进入 TIME_WAIT 状态。 为什么建立连接是三次握手不是两次握手？关闭连接要四次握手？ 建立连接的时候，当客户端收到服务端的确认信息之后(第二次握手)就已经知道了服务端同意了连接，为什么还要再发送确认数据包给服务端(第三次握手)？ 第三次握手，是对第二次握手的确认。假如不进行第三次握手，服务端发送了SYN的确认数据包之后就直接处于 ESTABLISH 状态。这个确认数据包发送过程中出错，没有发送到给客户端怎么办？所以，一定要进行第三次握手。 关闭TCP连接为什么要四次握手？ TCP连接是全双工的通信，关闭的时候需要每个方向进行单独地关闭。当一端主动请求关闭的时候，被动的一端可能还有数据没有发送完毕，不能够立即关闭，所以不能够同时回复FIN + ACK，只能够先回复ACK数据包(第二次握手)，此时属于半关闭状态。当处理完数据之后，被动关闭的一端再发送FIN包给主动关闭的一端关闭连接。 ISNreference","categories":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://lizsgh.github.io/categories/TCP-IP/"}],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"https://lizsgh.github.io/tags/tcp-ip/"}],"keywords":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://lizsgh.github.io/categories/TCP-IP/"}]},{"title":"Terminal - shortcut","slug":"others/terminal_shortcut","date":"2017-12-31T16:00:00.000Z","updated":"2018-09-12T09:45:42.959Z","comments":true,"path":"2018/01/01/others/terminal_shortcut/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/others/terminal_shortcut/","excerpt":"","text":"Linux 终端窗口快捷键 Ctrl + p: 上一条命令 (相当于向上箭头)。 Ctrl + n: 下一条命令 (相当于向下箭头)。 Ctrl + a: 光标回到命令行开始位置。 Ctrl + e: 光标回到命令行开始位置。 Ctrl + b: 光标向左移动一位。 Ctrl + f: 光标向右移动一位。 Ctrl + h: 删除光标左边的一个字符。 Ctrl + d: 删除光标右边的一个字符。 Ctrl + w: 删除光标左边的一个’单词’字符。 Ctrl + u: 删除光标左边的所有字符。 Ctrl + k: 删除光标右边的所有字符。 Ctrl + l: 清屏。","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"git clean","slug":"git/git_clean","date":"2017-02-01T16:00:00.000Z","updated":"2018-09-16T19:46:36.100Z","comments":true,"path":"2017/02/02/git/git_clean/","link":"","permalink":"https://lizsgh.github.io/2017/02/02/git/git_clean/","excerpt":"","text":"使用 Git 版本管理的时候，在常见的 IDE 工具 (如：PyCharm) 上看到未跟踪的文件都会与其它文件是有区别的，如文件名为红色。因此，当想要移除未跟踪的文件的时候会很简单。但是，当项目大并且未跟踪的文件很多分布在各个文件夹里面的时候，或者当没有这些方便的 IDE 工具给你的时候，你想要移除这些未跟踪文件还是很麻烦的。那么有没有方便的方法呢？ 1git-clean - Remove untracked files from the working tree 用法1git clean [-d] [-f] [-i] [-n] [-q] [-e &lt;pattern&gt;] [-x | -X] [--] &lt;path&gt;... git clean 默认从当前目录开始递归移除不在版本管理下的文件，如未跟踪的文件。也可以指定开始的目录 &lt;path&gt;。 git clean 常用参数： -n, --dry-runDon’t actually remove anything, just show what would be done.-n 参数不会真正移除任何东西，仅仅展示当前命令将要做的工作给你看。很有用的一个参数，可以让我们清晰的知道将要移除那些东西。 1234567891011121314# creating a new file test1.py on current clean working tree$ touch test1.py$ git status -s?? test1.py$ git clean -nWould remove test1.py# creating a new directory d1 and a new file test2.py in it$ mkdir d1$ touch d1/test2.py$ git status -s?? d1/?? test1.py$ git clean -nWould remove test1.py 一个很奇怪的现象：当新建一个空目录 (d1)，并在该目录下新建一个文件 (test2.py) 的时候，会发现该文件 (d1/test2.py) 不会被 git clean 移除！怎么回事？ -dRemove untracked directories in addition to untracked files.-d 参数不但会移除未跟踪的文件，还会移除未跟踪的目录。但是，如果未跟踪的目录被其它分支管理的话，将不会被移除。的确要移除只能够用 -f 强制性移除。接着上面的操作来看看： 123$ git clean -ndWould remove d1/Would remove test1.py 可以看到d1文件夹以及里面的内容都将会被移除。注意当文件夹里面有文件被跟踪的时候，这个目录实际上已经被跟踪了。 123456789$ touch d1/test3.py$ git add d1/test3.py$ git status -sA d1/test3.py?? d1/test2.py?? test1.py$ git clean -ndWould remove d1/test2.pyWould remove test1.py -f, --force-f参数会强制性执行移除操作。 -i, --interactiveShow what would be done and clean files interactively.-i会启动一个交互式的操作界面，你可以进一步确定那些东西要移除。 -x-x参数可以删除包括已经被.gitignore文件忽略的文件。接着上面的操作： 12345678910111213141516171819$ touch test4.py d1/test5.py$ git status -sA d1/test3.pyM .gitignore?? d1/test2.py?? d1/test5.py?? test1.py?? test4.py$ cat &lt;&lt;EOF &gt;&gt; .gitignoretest4.pyd1/test5.py$ git clean -n # the .gitignore files won't be removedWould remove d1/test2.pyWould remove test1.py$ git clean -nx # the .gitignore files will be removed tooWould remove d1/test2.pyWould remove d1/test5.pyWould remove test1.pyWould remove test4.py 可以看到git clean是不会移除 .gitignore 忽略的文件的，添加-x参数可以移除.gitignore忽略的文件。 -XRemove only files ignored by Git.仅仅移除被.gitignore文件忽略的文件。接着上面操作： 1234$ git clean -nX...Would remove d1/test5.pyWould remove test4.py","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"git stash","slug":"git/git_stash","date":"2017-01-31T16:00:00.000Z","updated":"2018-09-16T17:56:17.340Z","comments":true,"path":"2017/02/01/git/git_stash/","link":"","permalink":"https://lizsgh.github.io/2017/02/01/git/git_stash/","excerpt":"","text":"情景：工作的时候，你正在项目中属于你的分支下开发一部分功能，但是还没有完善。Leader 突然叫你放下当前的工作，先修改项目中一个非常紧急的 BUG。修 BUG 嘛！家常便饭了。立即切回到上次发布版本(master 最近一次合并)，新建一个分支去修复这个 BUG 。然而，在 checkout 到 master 的时候失败，提示你必须先 commit 当前分支的修改才能够 checkout 到其它分支。问题来了：当前分支的功能只是开发了一部分，不想那么快 commit。不 commit 的话，如果 reset 到前一次 commit 又浪费了之前所做的工作。怎么办？ Git 提供了一个存储机制，用户可以通过git stash或git stash save命令，将修改的跟踪文件与暂存改动存储到一个栈中。 1git stash - Stash the changes in a dirty working directory away 注意，直接git stash或git stash save是不会将未跟踪文件暂存的。所以，当有未跟踪的文件的时候，要先add，或加 -u 参数 如，当前仓库中有文件test1.py和test2.py两个文件而且工作区都是清洁的，然后对test2.py进行修改，并且添加新文件test3.py。1234567891011121314$ git statusOn branch lizsnothing to commit, working tree clean# change test2.py and add test3.py$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py# stashing the work$ git stashSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git status -s?? test3.py # Untracked files won't be stashed 那么，问题又来了。当我们 stash 修改的时候，发现还有文件没有被 stashed，想要将 stash 起来的修改恢复过来，重新 stash。要怎么做呢？ git stash list查看 stashed 的记录 12$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0 git stash apply [&lt;stash&gt;]将存储栈的一条记录重新应用到当前分支，如果不指定&lt;stash&gt;，会默认恢复最近一次 stash 记录存储内容。git stash apply在这里即相当于git stash apply stash@{0}。 1234$ git stash apply$ git status -s M test2.py?? test3.py 打开 test2.py 文件可以看到其内容又回到了 stash 之前的状态了。我们再用 git stash list 查看存储栈的时候，发现刚刚的 stash 记录还在。存储的内容都恢复了，我觉得这条记录没意义了，想要删除了相应的 stash 记录，又要怎么做？ git stash drop [&lt;stash&gt;]删除存储栈的一条 stash 记录。如果不指定&lt;stash&gt;将会默认删除存储栈中最近一次的 stash 记录，git stash drop在这里即相当于git stash drop stash@{0}。 123$ git stash dropDropped refs/stash@&#123;0&#125; (...) $ git stash list # 可以看到最近一次的 stash 记录已经被删除掉了 git stash pop [&lt;stash&gt;]恢复并删除一条 stash 记录的内容。相当于git stash apply和git stash drop命令的结合。用法和git stash apply [&lt;stash&gt;]一样。 总结以上情境中操作：12345678910111213141516171819202122# change test2.py and add test3.py in the clean working tree$ echo \"# hello world\" &gt;&gt; test2.py $ touch test3.py$ git add .$ git status -s M test2.py?? test3.py$ git stashSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean.# checkout to master fix bug$ git checkout master# create a new branch to fix bug$ git checkout -b issue-01# go back wo branch lizs to continue you work after finishing the bug$ git checkout lizs# restore your coding$ git stash pop 注意，恢复存储栈中的内容的时候可能会有冲突需要合并。 git stash --include-untracked或git stash -u将修改的跟踪文件与暂存改动，还有未跟踪的文件存储起来，即相当于先 git add 再 git stash。 123456789101112# change test2.py and add new file test3.py on a clean working tree$ echo \" \" &gt;&gt; test2.py$ touch test3.py $ git status -s M test2.py?? test5.py# stashing the change and untracked file$ git stash -uSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean. git stash save --keep-index和 git stash -u相反，通过git add命令跟踪的文件不存储。注意，--keep-index是git stash save的选项。即，git stash --keep-index是无效的。 1234567891011# change test2.py and add new file test3.py on a clean working tree$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py$ git add -A$ git stash save --keep-indexSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git status -sA test3.py git stash --patchGit 不会直接存储修改过的内容，但是会交互式地提示哪些修改要存储。 git stash branch &lt;branchname&gt; [&lt;stash&gt;]将 stash 的一个记录内容恢复在一个新创建的分支 &lt;branchname&gt; 上。&lt;branchname&gt;，新分支的名称；&lt;stash&gt;，可选，不指定默认为最近一次 stash。 12345678910111213141516171819202122232425262728# change test2.py and add new file test3.py on a clean working tree$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean.# restore the a stash on a new branch$ git stash branch issue-01 Switched to a new branch 'issue-01'On branch issue-01Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: test2.pyUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) test3.pyno changes added to commit (use \"git add\" and/or \"git commit -a\")Dropped refs/stash@&#123;0&#125; (...) 可以看到 git stash branch issue-01用分支 lizs 的一个 stash 记录的内容新建了一个 issue-01 分支，并且会自动删除该 stash 记录，当前位于 issue-01 分支下。那么 lizs 分支会怎么样呢？ 12345$ git checkout lizs$ git status -s M test2.py?? test3.py$ git stash --list # the stash has been dropped 回到 lizs 分支之后，发现用来创建新分支的 stash 的内容居然也恢复在了 lizs 分支！WTF！那这个命令有什么卵用？","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"Git - Basic config","slug":"git/basic_config","date":"2017-01-01T16:00:00.000Z","updated":"2018-09-14T15:37:10.892Z","comments":true,"path":"2017/01/02/git/basic_config/","link":"","permalink":"https://lizsgh.github.io/2017/01/02/git/basic_config/","excerpt":"","text":"初次运行 Git 前的配置 Git 配置文件与命令运行 Git，我们需要先配置下自己的 Git 工作环境。Git 提供了 git config 工具来对 Git 进行配置，也可以通过直接修改 Git 的配置文件： /etc/gitconfig：系统中所有用户普遍使用的配置，用命令git config --system读写的就是这个配置文件。 ~/.gitconfig：当前用户的 Git 配置文件，使用 git config --global 进行的配置保存到这个文件。 .git/config：当前项目下 Git 的配置文件，使用 git config --local 进行配置，这里的配置仅仅针对当前项目有效。 Git 配置文件的优先级别：.git/config &gt; ~/.gitconfig &gt; /etc/gitconfig 配置用户信息12$ git config --global user.name \"lizs\"$ git config --global user.email lizsmail@qq.com 配置完毕之后，我们可以看到~/.gitconfig文件之中多了两行配置：123[user] name = lizs email = lizsmail@qq.com 配置文本编辑器Git 需要你输入一些额外信息的时候，会自动调用一个外部文本编辑器给你用，默认使用系统的默认编辑器。如我我修改提交信息的时候git commit --amend会使用 Ubuntu 系统默认编辑器 nano，使用起来不熟悉。这时候我们可以使用以下方法改变 Git 编辑器： 修改系统编辑器，打开~/.bashrc添加 export EDITOR=vim，然后 source ~/.bashrc。 使用命令 git config --global core.editor vim，修改成功之后，可以在~/.gitconfig文件中多了 core.editor 的配置： 12[core] editor = vim 直接修改 Git 配置文件 .git/config, ~/.gitconfig, /etc/gitconfig。在配置文件添加： 12[core] editor = vim 配置差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。1$ git config --global merge.tool vimdiff Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。 查看配置信息12345678$ git config --listuser.name=lizsuser.email=lizsmail@qq.comcore.editor=vimcore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=true","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"Algorithm - Basic","slug":"algorithm/basic","date":"2016-12-31T16:00:01.000Z","updated":"2018-09-12T07:45:26.526Z","comments":true,"path":"2017/01/01/algorithm/basic/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/algorithm/basic/","excerpt":"","text":"数学基础知识计量单位 B，字节 KB，千字节，2^10 = 1024 B MB，兆字节，2^20 B GB，吉字节，2^30 B 阶乘(factorial)阶乘n!，指从 1 到 n 之间所有整数的乘积，n为大于 0 的整数。如：15! = 1 * 2 * 3 * 4 * 5 特别地，0! = 1。 取模(modulus)取模，指获取整除后的余数。如：15 % 3 = 2 指数幂在数学上，我们把 n 个相同因数 a 相乘的积记做a^n。这种求几个相同因数的积的运算叫做乘方，乘方的结果叫做幂。在a^n中，a叫做底数，n叫做指数。a^n读作：a的n次方，或a的n次幂。 对数在数学中，对数是对求幂的逆运算。如果 N = a^x(a &gt; 0, a != 1)，那么数 x 就叫做以 a 为底 N 的对数(logarithm)，记作 x=logaN。其中，a叫做对数的底数，N叫做真数，x叫做以a为底N的对数。 对数在坐标上过定点 (1, 0)，即 x = 1 时，y = 0。 特别地，以 10 为底的对数称为常用对数(common logarithm)，记为 lg。 以无理数 e(e=2.71828) 为底的对数称为自然对数(natural logarithm)，记为 ln。 零没有对数。 在实数范围内，负数无对数；在复数范围内，负数有对数。 级数级数指将数列的项依次加起来的函数。1∑Un = U1 + U2 + ... + Un 算法分析渐近分析当我们估算一种算法的时间或者其他代价时，经常忽略其系数，只关注其增长率，这称为渐近分析法。准确的说，渐近分析是当输入规模很大，或者达到极限(微积分意义上)时，对一种算法的研究。实践证明忽略这些系数很有用，因此渐近分析也广泛应用于算法比较。 并不是任何情况都能忽略常数。当算法要解决的问题规模 n 很小时，系数就会起到举足轻重的作用。 上限算法运行时间的上限，用来表示该算法可能有的最高增长率。算法有最佳、最差、平均情况下的上限，一般估算最差情况下的上限。 算法增长率的上限，用大 O 表示。如果某种算法的增长率上限(最差情况下)是f(n)，那么就说这种算法“在集合 O(f(n)) 中”，或直接说“在 O(f(n))”中。 下限算法下限，表示最差、最佳、平均情况下的时间下限。用 Ω 表示，读作“大欧米伽”或“欧米伽”。 Θ当算法上限和下限相等时，可用 Θ 表示法，读作“西塔”。 算法最佳、最差、平均情况算法的上(下)限与给定输入规模(如n)的最差(佳)情况不同，上(下)限不是用来确定运行时间(对于给定的n值，即可确定具体的运行时间)的，而是用来确定运行时间的增长率(增长率只能在n值的一个范围内确定)。对于单个点是没有增长率概念的，增长率用于体现伴随输入规模变化的代价变化。 算法的每种输入规模(如n)都存在最佳和最差情况，所以，不要误认为当输入规模尽可能小时出现算法的最佳情况，当输入规模尽可能大时出现算法的最差情况。 理想情况下，当输入规模增大时，可以确定在最佳、最差和平均情况下的增长率。 基本数据结构线性表线性表是由称为元素(element)的数据项组成的一种有限且有序的序列。有序，是指线性表中的每一个元素都有自己的位置。每一个元素也都有一种数据类型。 线性表中不包含任何元素时，称为空表。当前存储的元素数目称为线性表的长度；线性表的开始结点称为表头(head)；结尾结点称为表尾(tail)。 线性表的实现有两种标准方法：顺序表(array-based list 或 sequential list)和链表(linked list)。 顺序表和链表的比较： 顺序表的缺点是大小事先固定，很容易造成空间不足或浪费的情况；优点是对于表中的每个元素没有浪费空间，而链表需要在每个结点上附加一个指针。 链表的优点是只有实际在链表中的对象需要空间，只要存在可用的内存空间分配，链表中的元素个数就没有限制。 一般规律，当线性表元素数目变化较大或者未知时，最好使用链表实现；而如果用户事先知道线性表的大致长度时，使用顺序表的空间效率会更高。 链表的增加/删除操作所需的时间仅为Θ(1)。而顺序表必须将其余的元素向前或向后移动，所需的平均时间和最差时间均为Θ(n)。对于许多应用，插入和删除是最主要的操作，仅就这个原因链表往往比顺序表更好。 链表分为单链表和双链表。双链表存储了两个指针(前驱和后继)，双链表与单链表相比唯一的缺点就是使用更多的空间，双链表的每一个结点需要两个指针。 字典计算机程序一般是用来存储和检索数据的。字典，一个简单的数据库接口，被定义成一个ADT，它提供在数据库中存储、查找和删除记录的功能。 字典用关键码(key)来描述一条数据库记录，并且该关键码是可比的(comparable)。有了这样的关键码，就能够在数据库中顺序地搜索并找出给定关键码值相匹配的记录。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://lizsgh.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://lizsgh.github.io/tags/algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://lizsgh.github.io/categories/Algorithm/"}]},{"title":"lizsgh.github.io","slug":"others/lizsgh.github.io","date":"2016-12-31T16:00:00.000Z","updated":"2018-09-12T08:32:11.774Z","comments":true,"path":"2017/01/01/others/lizsgh.github.io/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/others/lizsgh.github.io/","excerpt":"","text":"Github Pages 和 hexo 搭建个人博客。 Github PagesGithub Pages, Websites for you and your projects. 在 github 上创建名为username.github.io的仓库，其中username为你的 GitHub 账号名称。如我的 GitHub 账号为lizsgh，则创建仓库名为lizsgh.github.io。 在仓库根目录下添加 index.html 页面。这时候，我们登录 http://lizsgh.github.io 就可以看到 index.html 的内容。也就是说，我们可以通过http://lizsgh.github.io来访问这个仓库的静态页面内容。 Jekyll themes。Jekyll 是一个简单的、可扩展的、静态的网站生成器。GitHub Pages 可以选择 Jekyll theme 来作为网站的主题。设置方法：打开仓库，在setting中有一个GitHub Pages的设置选项，其中Theme Chooser可以选择 Jekyll theme 来作为网站的主题。Jekyll 的使用可以看文档：Jekyll Document CNAME。GitHub Pages 还可以让我们自己自定义网站的域名。同样在仓库setting的Github Pages设置选项中有一个Custom domain的选项，可以自定义网站的域名，如 www.lizs.cc。然后，在域名服务商平台将域名解析为 CNAME 类型，值为 lizsgh.github.io。生效之后，就可以通过 www.lizs.cc 来访问了。 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown (或其他渲染引擎) 解析文章，生成静态网页。 个人觉得 Hexo 比 Jekyll 简单好用点，所以抛弃了用 Jekyll theme 来作为 Github Pages 主题。 Hexo 安装前提：Node.js 和 Git。 安装 Hexo 1$ npm install -g hexo-cli 初始化一个 hexo 项目 123$ hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成之后，项目目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 创建文章 1$ hexo new [layout] [title] 如，hexo new test 就会在 source/_posts 目录下生成一篇名为 test.md 的文章。也可以直接在 source/_posts 下新建 test.md 文件来创建文章。 生成静态页面 1$ hexo generate 执行命令会生成一个 public 目录来存放生成的静态页面。如果生成静态页面之前想将之前版本的 public 删除，可以用 hexo clean 命令。 启动本地服务器 1$ hexo server 通过以上命令启动服务器，可以通过 http://localhost:4000/ 地址来访问。 部署到 GitHub Pages 首先，配置 _config.yml 文件 1234deploy: type: git repo: https://github.com/lizsGH/lizsgh.github.io.git branch: master 其中 repo 为你 GitHub Pages 仓库的地址。 然后执行部署命令 1$ hexo deploy 如果出现错误 ERROR Deployer not found: git，则需要安装 hexo-deployer-git 扩展： 1$ npm install hexo-deployer-git --save 自定义域名自定义 GitHub Pages 的域名只需要添加文件 source/CNAME: 1www.lizs.cc 然后，重新部署到 GitHub Pages 即可。 更多详细信息，可以参考 Hexo Document。","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"Python - Built-in functions","slug":"python/builtin_function","date":"2016-12-31T16:00:00.000Z","updated":"2018-11-28T12:48:27.841Z","comments":true,"path":"2017/01/01/python/builtin_function/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/python/builtin_function/","excerpt":"","text":"overview Built-in Functions abs() delattr() hash() memoryview() set() all() dict() help() min() setattr() any() dir() hex() next() slice() ascii() divmod() id() object() sorted() bin() enumerate() input() oct() staticmethod() bool() eval() int() open() str() breakpoint() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() abs(x)返回数值x的绝对值，x可以为：整数和浮点数。如果x是复数，则返回复数的 magnitude，即复数与其共轭复数乘积的正平方根。如：12abs(2 + 2j) # (2 + 2j) * (2 - 2j) 的平方根2.8284271247461903 复数与其共轭复数的乘积运算： (a + bj) * (a - bj) == a ** 2 + b ** 2，因此，abs(a + bj) == math.sqrt(a ** 2 + b ** 2) all(iterable)当iterable中的所有元素为真，或iterable为空时，返回True。 any(iterable)当iterable中有任意一个元素为真时，返回True。 ascii(object)As repr(), return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by repr() using \\x, \\u or \\U escapes. This generates a string similar to that returned by repr() in Python 2. bin(x)将整数x转换为以0b开头的二进制字符串。x为整数或int对象(即该对象必须定义__index__()方法，并返回一个整数)。1234a = bin(3) # '0b11'b = bin(-3) # '-0b11'int(b, base=2)-3 bool([x])根据x的判断值，返回布尔值True或False。如果x为空，返回False。 bool是int的子类，但是，bool不能够被继承，因为bool的实例只有True和False。1234class A(bool): pass TypeError: type 'bool' is not an acceptable base type breakpoint(*args, **kws) New in version 3.7 bytearray([source[, encoding[, errors]]]) bytes([source[, encoding[, errors]]]) Python 2str(object=’’) -&gt; string.Return a nice string representation of the object. If the argument is a string, the return value is the same object. Python 3 bytes(): empty bytes object. bytes(int): bytes object of size given by the parameter initializated with null bytes (‘\\x00’). 12bytes(0) # b''bytes(3) # b'\\x00\\x00\\x00' bytes(iterable_of_ints): bytes 1bytes(range(3)) # b'\\x00\\x01\\x02' bytes(bytes_or_buffer): immutable copy of bytes_of_buffer. 123a = b'abc'b = bytes(a) # b'abc'a == b # True, i.e. id(a) == id(b) bytes(string, encoding[, errors]): bytes. 12a = 'abc' # Unicodebytes(a, 'utf-8') # b'abc' callable(object)判断 object 是否是可调用的，返回Ture/False。 callable函数只是检测object是否可调用，不管object调用是否成功。object为可调用对象时，调用的时候也可能调用失败；object为不可调用对象时，调用就一定失败。 1234567891011class A(object): pass class B(object): def __call__(self): return a # global name 'a' is not defined callable(A) # Truecallable(A()) # Falsecallable(B) # Truecallable(B()) # True 类对象都是可调用的，返回一个类实例。但是类的实例对象是否为可调用对象，取决于类是否定义了__call__()方法。 1234callable(int) # Truecallable(int()) # Falsecallable(bool) # Truecallable(bool()) # False New in version 3.2: This function was first removed in Python 3.0 and then brought back in Python 3.2. chr(i) Python 2: Return a string of one character with oridinal i (0 &lt;= i &lt; 256).Python 3: Return a Unicode string of one character with ordinal i (0 &lt;= i &lt;= 0x10ffff).返回 code point i 对应的 Unicode 的字符，0 &lt;= i &lt;= 0x10ffff。与 ord() 函数作用相反。12chr(65) # Aord('A') # 65 @classmethod compile(source, filename, mode, flags=0, dont_inherit=False, optimize=1)将source编译成 code 对象或 AST 对象。编译成的 Code 对象可以被exec或eval函数执行。 source: 可以是字符串、byte 字符串或 AST 对象。注意，source的内容要符合mode。 filename: 字符串类型，读取代码的文件名。如果不是从文件中读取，可以用一些具有标识性的字符串代替，如&#39;&lt;string&gt;&#39;。 mode: 指定代码编译的类型。 &#39;exec&#39;: 如果source是由一系列的 Python 语句组成的。 &#39;eval&#39;: 如果source是一条表达式，编译成的代码对象可以被eval函数执行。 &#39;single&#39;: 如果source由单一的交互式语句组成。(这种情况下，用exec也是可以的，不知道single的实际作用？！) 1234567891011code_object = compile('a = 1; b = a + 1', '&lt;string&gt;', 'exec')exec(code_object)a, b(1, 2)code_object = compile('1 + 1', '&lt;string&gt;', 'eval')eval(code_object)2code_object = compile('name = input(\"Input your name: \")', '&lt;string&gt;', 'single')exec(code_object)Input your name: lizsprint(name) complex([real[, imag]])返回实部real和虚部imag转换成的复数。 real和imag可以是任意的数值类型，如 int, float，complex 等。real还可以是 sting 类型，但imag永远不能够为 string 类型。real和imag的默认值都为 0。返回real + imag * 1j。 12345678910complex(1, 2.1)(1+2.1j) # 1 + 2.1 * 1j = (1+2.1j)complex(1+2j, 2)(1+4j) # (1+2j) + 2 * 1j = (1+4j)complex(1+2j, 2j)(-1+2j) # (1+2j) + 2j * 1j = (1+2j) - 2 = (-1+2j)complex(-1.1)(-1.1+0j) # -1.1 + 0 * 1j = (1.1+0j)complex()0j # 0 + 0 * 1j = 0j 当real为 string 时，real将转换为复数，imag不能有值。 123456complex('1')(1+0j)complex('1.1+1.2j')(1.1+1.2j)complex('1', '2')TypeError: complex() can't take second arg if first is a string 注意，当real为 string 时，real字符串中的+或-操作符前后不能够有空格。 12345678910complex('1 + 2j')ValueError: complex() arg is a malformed string complex('1 - 2j')ValueError: complex() arg is a malformed string complex('1 ')(1+0j)complex(' -2')(-2+0j)complex(' -2j')-2j delattr(object, name)删除对象object中的属性name。object为对象名称；name为对象的属性名称，字符串类型。实际上，delattr(x, &#39;foobar&#39;)相当于del x.foobar。 dict(kws)/dict(mapping, kws)/dict(iterable, **kws)字典的构建函数。 dict(): new empty dictionary dict(mapping): new dictionary initialized from a mapping object’s (key, value) pairs dict(iterable): new dictionary initialized as if via: 123d = &#123;&#125;for k, v in iterable: d[k] = v dict(**kwargs): new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2). dir([object])返回object的有效的属性名称的列表。如果object为空，则返回当前的局部作用域(局部变量)的名称。 dir([object])只是返回属性或变量的名称，locals()和globals()分别返回局部和全局符号表(一种映射关系，存储了键值对的数据结构)。 如果object定义了__dir__()方法，则dir(object)会调用object.__dir__()方法，__dir__()方法必须返回一个列表。 1234567891011class A(object): def __dir__(self): print('hello world') return ['a', 'b', 0] def name(self): return 'lizs'dir(A())hello world['a', 'b', 0] # in this case, just call __dir__() function, and doesn't has 'name' attribute. 如果object没有定义__dir__()方法，dir(object)会从object.__dict__属性，and from its type object. 1234567891011class B(object): def __init__(self): self.__dict__ = &#123;'a': 1, 'b': 2&#125; def c(self): passdir(B())['__class__', '__delattr__', '__dict__', '__doc__', ..., 'a', 'b', 'c']B().a1 dir([object])的默认机制是： 如果object是 Python 模块，则返回该模块的属性名称组成的列表。 如果object是 type 或 class 对象，则返回object的属性名称，和object基类的属性名称。 否则，则返回object的属性名称，object父类的属性名称，和object父类的基类的属性名称组成的列表。 divmod(a, b)divmod(a, b) -&gt; (a // b, a % b) enumerate(iterable, start=0)返回一个枚举对象，iterable必须是一个序列，或一个迭代器，或其它的迭代对象。12345seasons = ['Spring', 'Summer', 'Fall', 'Winter']list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]list(enumerate(seasons, start=1))[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] 相当于：12345def enumerate(sequence, start=0) n = start for elem in sequence: yield n, elem n += 1 eval(source, globals=None, locals=None)在globals和locals变量的环境下，返回表达式(Python expression)source执行的值。 source，可以是字符串 (Python expression)，也可以是一个 code objects (如 compile() 创建的 code object)。 globals，字典类型，当globals=None时，默认值为当前环境下的globals()。 locals，任意映射类型，当locals=None时，默认值为当前环境下的locals()。 globals和locals参数只能够通过位置参数传参。 12eval('int()', globals=&#123;'a': 1&#125;)TypeError: eval() takes no keyword arguments 如果globals字典参数中没有__builtins__键，则自动添加__builtins__，其值为builtins模块。 12eval('list(globals().keys()), list(locals().keys())', &#123;&#125;, &#123;&#125;)['__builtins__', &#123;&#125;] 如果只有globals参数，则locals参数的值默认为globals参数的值。 12eval('list(locals().keys())', &#123;'a': 1&#125;)['a', '__builtins__'] 当source为 code object 时，如果 code object 使用compile()创建时使用了exec作为参数mode的值，则返回None。 1234print(eval(compile('1 + 2', '&lt;string&gt;', 'eval')))3print(eval(compile('1 + 2', '&lt;string&gt;', 'None')))None 注意，print(&quot;hello world&quot;)只是在屏幕输出内容，表达式没有返回值的。 12345678a = print('hello world')hello world # 屏幕输出print(a)None # print 函数的返回值为 Nonea = eval(\"print('hello world')\")hello world # 屏幕输出print(a)None # eval 函数执行完的返回值为 None 因为source为 Python 表达式 (expression)，所以，当source为 Python 語句 (statement) 时會出錯。如：赋值语句 (=)。 12345eval('a = 1')File \"&lt;string&gt;\", line 1 a = 1 ^SyntaxError: invalid syntax 要执行 Python statements 可以使用 exec() 函数。 exec(source[, globals[, locals]])与eval相似，eval执行 Python 表达式或 code object 并会返回执行结果。exec函数会动态执行source，但返回None。 source可以是 string 或 code object。source可以是动态的 Python 语句，如a = 1; a += 1。 globals和locals: 用法和eval相同。 Python 2 exec不是函数，而是一个内置语句，不会返回值。 123456# Python 2+a = exec('a = 1; a + 1') File \"&lt;ipython-input-21-1d9129f9ba14&gt;\", line 1 b = exec('a = 1; a + 1') ^SyntaxError: invalid syntax Python 3 exec是内置函数，只返回None。 1234# Python 3+a = exec('1 + 1')print(a)None filter(function, iterable) (Python 2) filter(function or None, sequence) -&gt; list, tuple, or stringReturn those items of sequence for which function(item) is true. If function is None, return the items that are true. If sequence is a tuple or string, return the same type, else return a list. (Python 3) filter(function or None, iterable) –&gt; filter objectReturn an iterator yielding those items of iterable for which function(item) is true. If function is None, return the items that are true. filter函数过滤掉iterable中 item 经过function(item)调用返回不为真的 item。 当function为None时，返回iterable中为真的项。 Python2，如果iterable为 tuple 或 string 则返回原来的类型，其余类型返回 list；Python3 返回一个 filter object。 Python 2+: 1234567891011121314151617181920212223filter(int, [0, 1, 2])[1, 2]filter(int, (0, 1, 2))(1, 2)filter(int, &#123;0, 1, 2&#125;)[1, 2]filter(int, '012')'12'def f(x): print(x) return 65 &lt;= ord(x) &lt;= 90 filter(f, 'abAB')abAB'AB' # filter the 'ab'filter(None, [0, 1, 2])[1, 2]filter(None, (0, 1, 2))(1, 2)filter(None, '012')'012' 当iterable为字符串类型并且第一个参数不为None时，会遍历字符串中的每个字符作为 item 传给 function。 Python 3+: 1234567891011121314151617181920212223242526r1 = filter(int, [0, 1, 2])print(r1)&lt;filter object at 0x...&gt;list(r1)[1, 2]def func(x): print(x) return 65 &lt;= ord(x) &lt;= 90r2 = filter(func, 'abAB')next(r2)abA'A' # yielding 'A', beause function('A') == True.next(r2)'B'list(filter(None, (0, 1, 2)))[1, 2]list(filter(None, '012'))['0', '1', '2']list(filter(int, '012'))['1', '2']list(filter(bool, '012'))['0', '1', '2'] float([x])将x转换为浮点数。x可以是 string 或 int。 如果x是 string 类型，x应该是一个十进制数字的字符串，或(inf/Infinity)代表无穷大值，字符串前面可以包含+或-或空格字符。如果没有参数，则返回0.0。123456789101112131415161718float(1)1.0float(1.11)1.11float('1')1.0float('+1.11')1.11float(' -123\\n')-123.0float('1e-003')0.001float(' +1E6')1000000.0float('inf')inf # 正无穷大float('-Infinity')-inf # 负无穷大 format(value[, format_spec])返回value.__format__(format_spec)，format_spec默认值为空字符串。See the Format Specification Mini-Language section of help(‘FORMATTING’) fordetails. forzenset([iterable])创建一个 frozenset 对象。iterable为可迭代对象，如果iterable为空，则创建一个空值的 frozenset 对象。12345678frozenset()frozenset() # an empty frozenset objectfrozenset('abcde')frozenset(&#123;'a', 'b', 'c', 'd', 'e'&#125;)frozenset([0, 1, 2, 'abc'])frozenset(&#123;0, 1, 2, 'abc'&#125;)frozenset(0)TypeError: 'int' object is not iterable getattr(object, name[, default])获取object对象的属性名称为name的值，name必须为字符串类型。即getattr(object, name)相当于object.name。当object.name不存在时，如果指定default的值，则返回default的值；如果不指定default的值，则会引起AttributeError错误。12345678910111213141516class A(object): def __init__(self): self.name = 'lizs' self.age = 18 def address(self): return 'China'getattr(A(), 'name') 'lizs'getattr(A(), 'address')&lt;bound method A.address of &lt;__main__.A object at 0x...&gt;&gt;getattr(A, 'name')AttributeError: type object 'A' has no attribute 'name'getattr(A, 'name', 'lizs')'lizs' globals()返回全局符号表。 hasattr(object, name)判断object对象是否存在属性name，返回True或False。name，字符串类型，属性的名称。e.g. hasattr(People, &#39;age&#39;)相当于People.age。 实际上，hasattr(object, name)调用了getattr(object, name)，然后通过抓取错误来判断是否存在属性。 hash(object)获取object对象的哈希值。哈希值为整数，两个数值比较为相等时，它们的哈希值相同。123456hash(1), hash(1.0), hash(1+0j)(1, 1, 1)1 == 1.0 == 1+0jTrueid(1), id(1.0), id(1+0j)(94326139635240, 94326148389728, 139691410895376) help([object])打印object的帮助文档信息，当没有参数时，启动一个帮助系统的交互界面。 hex(x)将整数x转换为十六进制字符串(以0x开头的小写字母字符串)。1234hex(255)'0xff'hex(-42)'-0x2a' id(object)获取对象的 identity。在对象的生命周期中，identity 是一个具有唯一性的常数。在 CPython 解析器中，identity 就是该对象的内存地址。 input([prompt])从基础输入中读取一行信息，即input()读取到换行符结束。或用户自动出发结束，如Linux系统Ctrl + D。如果提示信息prompt给出，则在基础输出中显示。prompt显示的时候不会自动加换行。1234567input(\"Hi, what is your name: \")Hi, what is your name: lizs # 提示信息不会自动换行，输入信息 'lizs' 会随尾提示后面。'lizs'input(\"Hi, what is your name: \\n\")Hi, what is your name:lizs # input message'lizs' int([x])/int(x, base=10) 当没有参数时，返回 0，即int() == 0。 如果x定义了__int__()，则返回x.__int__()；如果x定义了__trunc__()，则返回x.__trunc__()。 当x为浮点数时，返回整数部分。 12int(1.9)1 当x不是数字的时候，或当指定base的值的时候，x只能是 string, bytes, bytearray 代表的整形字面量(integer literal)。这时x可以以+或-开头，或空格围绕。 12int(' - 101 ') # base=10-101 Python 3+ integer literal definitions: 12345678910integer ::= decinteger | bininteger | octinteger | hexintegerdecinteger ::= nonzerodigit ([\"_\"] digit)* | \"0\"+ ([\"_\"] \"0\")*bininteger ::= \"0\" (\"b\" | \"B\") ([\"_\"] bindigit)+octinteger ::= \"0\" (\"o\" | \"O\") ([\"_\"] octdigit)+hexinteger ::= \"0\" (\"x\" | \"X\") ([\"_\"] hexdigit)+nonzerodigit ::= \"1\"...\"9\"digit ::= \"0\"...\"9\"bindigit ::= \"0\" | \"1\"octdigit ::= \"0\"...\"7\"hexdigit ::= digit | \"a\"...\"f\" | \"A\"...\"F\" Python 2 integer literal definitions: 12345678910longinteger ::= integer (\"l\" | \"L\")integer ::= decimalinteger | octinteger | hexinteger | binintegerdecimalinteger ::= nonzerodigit digit* | \"0\"octinteger ::= \"0\" (\"o\" | \"O\") octdigit+ | \"0\" octdigit+hexinteger ::= \"0\" (\"x\" | \"X\") hexdigit+bininteger ::= \"0\" (\"b\" | \"B\") bindigit+nonzerodigit ::= \"1\"...\"9\"octdigit ::= \"0\"...\"7\"bindigit ::= \"0\" | \"1\"hexdigit ::= digit | \"a\"...\"f\" | \"A\"...\"F\" base表示x的进制数，如int(&#39;101&#39;, 8)表示101是一个八进制的字符串，转换为整数则为：1 * 8 ** 0 + 0 + 1 * 8 ** 2 == 65。base的有效值可以为 0 和 2-36。 当base=0时，意味着x按照 integer literal 转换。但 Python 2+ 与 Python 3+ 的integer literal 有些不同，如当x是以 0 开头时在 Python 3+ 是不合法的，但在 Python 2+ 中为 octinteger int(&#39;010&#39;, 0) == int(&#39;010&#39;, 8)。 当base为 2, 8, 16 时，x可以分别以0b/0B, 0o/0O和0x/0X开头。 当base的值大于 10 时，x可以用字母 a-z 或 A-Z 来表示 10 - 35 (注意，字母必须小于base，如当base=12时，x中只能够有字母a和b)。 12345678910111213141516int('101', 8)65int('101', 0) # decinteger101int('0b101', 0) # bininteger5int('0Xa0', 0) # hexinteger160int('a0', 0)ValueError: invalid literal for int() with base 0: 'a0'int('101', 2)5int('0B101', 2)5int('ab1', 12)1573 isinstance(object, classinfo)判断object是否是classinfo的实例，返回True/False。classinfo可以是一个类或一个由若干个类型组成的元组。当classinfo是元组时，只要object属于classinfo中任意一个类型的实例则返回True。123456isinstance(0, object)Trueisinstance(0, (str, int, dict))Trueisinstance(0, ('a', int))TypeError: isinstance() arg 2 must be a type or tuple of types issubclass(class, classinfo)判断class是否是classinfo的子类，返回True/False。classinfo可以是一个类或一个由若干个类组成的元组。当classinfo是元组的时候，只要class属于classinfo中任意一个类的子类则返回True。1234issubclass(int, object)Trueissubclass(int, (str, object, dict))True 与isinstance(object, classinfo)不同，issubclass(class, classinfo)的第一个参数class必须是一个类，并且class认为是其本身的子类。123456issubclass(0, object)TypeError: issubclass() arg 1 must be a classissubclass(int, int)Trueisinstance(int, int)False iter(object[, sentinel]) iter(collection) -&gt; iteratoriter(callable, sentinel) -&gt; iterator 当没有sentinel参数时，第一个参数只能够是 collection 对象，即支持迭代协议(__iter__()方法)和序列协议(__getitem__()方法)。 123i = iter([0, 1, 2])next(i) # 0next(i) # 1 当第二个参数不为空的时候，第一个参数必须是一个可调用对象。创建的迭代器在每次迭代的时候，会调用callable，当调用的返回值为sentinel时停止。 123with open('mydata.txt') as fp: for line in iter(fp.readline, ''): print(line) len(s)获取对象s的长度(元素个数)。12345678len('abc')3len(&#123;'a', 'b', 'c'&#125;)3len(dict(a=0, b=1, c=2))3len(range(10))10 list([iterable])list() -&gt; new empty listlist(iterable) -&gt; new list initialized from iterable’s items locals()获取当前局部符号表，即当前范围的局部变量组成的字典。 map(function, iterable[, iterable, ..]) (Python2.7) Apply function to every item of iterable and return a list of the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. If one iterable is shorter than another it is assumed to be extended with None items. If function is None, the identity function is assumed; if there are multiple arguments, map() returns a list consisting of tuples containing the corresponding items from all iterables (a kind of transpose operation). The iterable arguments may be a sequence or any iterable object; the result is always a list.(Python3+) Return an iterator that applies function to every item of iterable, yielding the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterable stops when the shortest iterable is exhausted. 将function应用于iterable的每一项，返回列表(Python3+，迭代对象)，列表(迭代对象)中的每一项都是function作用后的结果。注意：Python3+ 返回的是迭代对象。 如果有多个iterable，function将并行应用于iterable的每一项。也即是，所有iterable中相同序列的项同时作为参数传递给function运行。如： 12345678map(lambda x, y: x + y, [1, 2, 3], [4, 5, 6])[5, 7, 9] # Python3+ 返回迭代器&lt;map object&gt;map(lambda x: x * x, [1, 2, 3], [4, 5, 6])TypeError: &lt;lambda&gt;() takes exactly 1 argument (2 given)def func(*args): return argsmap(func, [1, 2, 3], [4, 5, 6], [7, 8, 9])[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 当iterable的个数(注意，不是iterable元素个数)与function函数的参数不一致时会出错。如： 12map(lambda x: x * x, [1, 2, 3], [4, 5, 6])TypeError: &lt;lambda&gt;() takes exactly 1 argument (2 given) 当有多个iterable并且iterable的元素数目不一致时：Python2，会以最长的为准，短自动用None补全。Python3+，以最短的为准，迭代完最短的iterable就会自动结束。 12345678def func(*args): return args# Python2.7map(func, [1, 2, 3], [4, 5, 6, 7])[(1, 4), (2, 5), (3, 6), (None, 7)]# Python3+list(map(func, [1, 2, 3], [4, 5, 6, 7]))[(1, 4), (2, 5), (3, 6)] 当function为None 123456# Python2map(None, [1, 2, 3], [4, 5, 6, 7])[(1, 4), (2, 5), (3, 6), (None, 7)]# Python3+list(map(None, [1, 2, 3], [4, 5, 6, 7]))TypeError: 'NoneType' object is not callable max() max(iterable, *[, key=func, default=obj])max(arg1, arg2, *args[, key=func]) 当只有一个位置参数的时候(即第一种模式)，这个参数只能是一个可迭代对象，函数会返回迭代对象中最大的一个元素。如：list, str, tuple 等。 1234max('0123')3max([0, 1, 2, 3])3 如果有两个或两个以上位置参数(即第二种模式)，则返回这些参数中最大的一个。注意，这些位置参数一定要可比较大小的，不然会出错。Python3 两个不同类型之间不可以比较大小。 12345678max(0, 1, 2)2# Python 2+max('a', 1, 2)'a' # 'a' &gt; 2 == True, in python 2# Python 3+max('a', 1, 2)TypeError: '&gt;' not supported between instances of 'str' and 'int' 除了位置参数之外，max()还有 keyword-only 参数key=func。key参数和list.sort()的key参数类似。key参数的值为接收一个参数的函数(如func(x))，iterable中的元素或各个位置参数会作为参数传给func函数处理，max()函数会根据func函数的返回值进行比较取最大值。 12345# Python 3max(['a', 0, 1, 97], key=lambda x: ord(x) if isinstance(x, str) else x)'a'max('a', 0, 98, key=lambda x: ord(x) if isinstance(x, str) else x)98 原本 Python 3+ 是不能够比较 str 和 int 的，但是key参数自动将字符串转换为了整数。同时，当比较的参数中有相同的时候，会返回第一个最大值(ord(&#39;a&#39;) == 97)。 Python 3.4 以上，第一种模式max(iterable, *[, key=func, default=obj])新增了一个 keyword-only 参数 default=obj。default参数可以指定当iterable为空的时候，函数返回的默认值。 12max('', default=1)1 min() min(iterable, *[, key=func, default=obj])min(arg1, arg2, *args[, key=func]) 用法和max()函数一样，功能相反，返回参数中的最小值。 memoryview(object)创建 memoryview 对象。123456789101112a = bytearray(1000000)sys.getsizeof(a)1000057b = memoryview(a)print(b)&lt;memory at 0x...&gt;print(sys.getsizeof(b))192print(b[1])0print(b[1:3])&lt;memory at 0x...&gt; next(iterator[, default])返回迭代器iterator的下一个元素，即调用iterator.__next__()的返回值。next()的第二个参数为iterator遍历结束时返回的默认值，否则当iterator迭代完的时候会引起StopIteration错误。12345678910a = iter(range(2))next(a) # 0next(a) # 1next(a) # StopIterationa = iter(range(3))next(a) # 0next(a, 3) # 1next(a, default=3) # TypeError: next() takes no keyword argumentsnext(a, 3) # 2next(a, 3) # 3 当给出第二个参数的时候，当迭代器迭代完毕的时候会返回这个默认值，而不会引起StopIteration错误。同时，next()的第二个参数是一个位置参数。 oct(x)将整数x转换为以0o开头的八进制(octal)字符串。x为整数或int对象(即该对象必须定义__index__()方法，并返回一个整数)。注意，Python 2+ 八进制字符串以0开头。1234oct(3) # 0o3oct(10) # 0o12int('0o12', 8)10 open() open(name[, mode[, buffering]])open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) ord(c)获取 Unicode 单个字符c的 code point。与chr(x)功能相反。1234ord('a')97chr(97)'a' pow(x, y[, z])当只有两个参数时，返回 x ** y；当由三个参数时，返回x ** y % z。 print() Python 2+: print()函数实际上是print表达式。Python 3+: print(value, …, sep=’ ‘, end=’\\n’, file=sys.stdout, flush=False) Python 2+，print()函数实际上是print表达式，所以，是没有关键字参数的，并且，多个位置参数时，是当做元组处理。 1234print('a', 'b')('a', 'b')print('a', 'b', sep='|')SyntaxError: invalid syntax Python 3+，print()函数不是关键字参数都会转换成字符串，并且组成一个由sep连接和end结尾的字符串输出。 sep=&#39; &#39;，关键字参数，表示当有多个位置参数时的连接符，默认值为空格。 end=&#39;\\n&#39;，关键字参数，表示添加到字符串结尾的字符。 file=sys.stdout, 关键字参数，必须是有wirite(string)方法的对象。 flush=False，关键字参数，表示是否刷新缓冲区。 12345print('a', 'b') # a bprint('a', 'b', sep='|') # a|bprint('a', 'b', sep='|', end='===') # a|b===with open('test.py', 'w') as fp: print('#!/usr/bin/env', 'python', file=fp) property(fget=None, fset=None, fdel=None, doc=None)创建一个 property 属性。fget是用来获取该属性值的相关函数，fset用来设置该属性值的函数，fdel是用来删除该属性的函数，doc是一个文档信息字符串。 12345class C(object): def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") 这样便通过property()创建了C对象的属性x。 以上操作也可以同 @property 装饰器更简单地实现：12345678910111213141516class C(object): def __init__(self): self._x = None @property def x(self): \"\"\"I am the 'x' property.\"\"\" return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x range() range(stop)range(start, stop[, step]) Python 2+, range()返回一个列表对象；Python 3+，range()返回的是一个 range 对象。 range()遵循左闭右开原则: [start, stop) 当只有一个参数的时候代表的是 stop，start 默认为 0，即 [0, stop)。 当有两个参数的时候，分别为 start 和 stop，即 [start, stop)。 第三个参数 step 代表步长，默认值为 1，。当 step 为负数的时候，start + step &lt; stop 才有意义。12345678910111213141516# python 2+range(10)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # 左闭右开 [0, 10)range(10, 0)[]range(0, 10, 2)[0, 2, 4, 6, 8]range(0, 10, -2)[]range(10, 0, -2)[10, 8, 6, 4, 2]range(0, -10, -2)[0, -2, -4, -6, -8]# python 3+range(10)range(0, 10) 当 step 为负数的时候，range(10, 0, -2)：12345610 8 # 10 - 26 # 8 - 24 # 6 - 22 # 4 - 20 # 2 - 2，左闭右开原则，舍弃 所以，list(range(10, 0, -2)) == [10, 8, 6, 4, 2]。 repr(object)Return the canonical string representation of the object. For many object types, including most builtins, eval(repr(obj)) == obj. A class can control what this function returns for its instances by defininga __repr__() method. reversed(seq)返回seq反转之后的生成器。123456789a = reversed('abcde')print(a)&lt;reversed at 0x...&gt;next(a)'e'next(a)'d'list(a)['c', 'b', 'a'] round(number[, ndigits])返回number四舍五入之后的结果，第二个参数ndigits表示精度。当没有第二个参数或为None时，返回number四舍五入之后的整数。123456789101112round(0.5)0round(1.5)2round(1.545, 0)2.0round(1.545, 1)1.5round(1.545, 2)1.54 # In python 1.545 actually is 1.54499999...round(1.545000001, 2)1.55 set([iterable])set() -&gt; new empty set objectset(iterable) -&gt; new set object Build an unordered collection of unique elements. setattr(object, name, value)Sets the named attribute on the given object to the specified value.setattr(x, &#39;y&#39;, v) is equivalent to x.y = v slice()slice(stop)slice(start, stop[, step]) Create a slice object. This is used for extended slicing (e.g. a[0:10:2])123456789101112a = 'abcdef's = slice(2)print(s)slice(None, 2, None)s1 = slice(1, 5)print(s1)slice(1, 5, None)s2 = slice(10, 1, -2)print(10, 1, -2)a[s] # 'ab'a[s1] # 'bcde'a[s2] # 'fd' sorted(iterable, *, key=None, reverse=False)返回iterable排序之后的列表。 关键字参数key，与max()，min()和list.sort()中的key参数一样，为只有一个参数的函数。如果指定了key=func，iterable中的每个元素 item 会作为唯一参数传递给func(item)，sorted()函数将根据func(item)的返回值进行比较，值越小越靠前。 关键字参数reverse，布尔值True或False，默认值为False。如果为True则将排序好的列表值反转。 1234sorted(('a', 0, 1, 96, 97, 98), key=lambda x: ord(x) if isinstance(x, str) else x)[0, 1, 96, 'a', 97, 98]sorted('abcde', reverse=True)['e', 'd', 'c', 'b', 'a'] @staticmethodConvert a function to be a static method. str str(object=’’) -&gt; strstr(bytes_or_buffer[, encoding[, errors]]) -&gt; str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object).encoding defaults to sys.getdefaultencoding().errors defaults to ‘strict’. sum(iterable[, start])返回iterable中各个元素的总和。如果，给出第二个参数start，则返回iterable + start的总和。1234sum(range(10))45sum(range(10), 10)55 super()super() -&gt; same as super(class, )super(type) -&gt; unbound super objectsuper(type, obj) -&gt; bound super object; requires isinstance(obj, type)super(type, type2) -&gt; bound super object; requires issubclass(type2, type)Typical use to call a cooperative superclass method:12345678class C(B): def meth(self, arg): super().meth(arg)This works for class methods too:class C(B): @classmethod def cmeth(cls, arg): super().cmeth(arg) Python 的super()函数可以用来调用父类的方法，并且有效解决了多重继承中父类方法被多次调用的问题。123456789101112131415161718192021222324252627class A(object): def __init__(self): print('A.__init__') class B(A): def __init__(self): A.__init__(self) print('B.__init__')class C(A): def __init__(self): A.__init__(self) print('C.__init__')class D(B, C): def __init__(self): B.__init__(self) C.__init__(self) print('D.__init__')D()A.__init__B.__init__A.__init__C.__init__D.__init__&lt;__main__.D at 0x7f7c5c410710&gt; 可以看到A被初始化了两次，这不是我们想要的。super()很完美的解决了这个问题。12345678910111213141516171819202122232425class A(object): def __init__(self): print('A.__init__')class B(A): def __init__(self): super().__init__() # super(B, self).__init__() print('B.__init__')class C(A): def __init__(self): super().__init__() # super(C, self).__init__() print('C.__init__')class D(B, C): def __init__(self): super().__init__() # super(D, self).__init__() print('D.__init__')D()A.__init__C.__init__B.__init__D.__init__&lt;__main__.DD at 0x7f6281c98c18&gt; 这次并没有重复的了，A, B, C, D都是只初始化了一次。super()会根据 MRO (method resolution search order) 来查找。12D.mro()[__main__.D, __main__.B, __main__.C, __main__.A, object] 开始执行D.__init__()的时候，遇到了super()/super(D, self)，则以当前类D (第一个遇到super的类) 的 MRO 来查找。如super(D, self)则查找 MRO 中 D 右侧的下一个对象 B，将 B 的__init__()绑定到当前的self(D()) 执行。 当执行B.__init__()的时候，又遇到了一个super()/super(B, self)，这时候还是以之前的 D.mro() 来查找，找到了 B 的下一个 C，继续执行。 当执行C.__init__()的时候，又遇到了一个super()/super(C, self)，还是以第一次的 D.mro() 来查找，找到了 C 的下一个 A，继续执行。 当执行A.__init__()的时候，没有super()。OK，执行完，依次返回：A.__init__(), C.__init__(), B.__init__(), D.__init__()。 再来看一个对比的例子：123456789101112131415161718192021222324252627282930class A(object): def __init__(self): print('A.__init__')class B(object): def __init__(self): print('B.__init__')class C(A): def __init__(self): super().__init__() # super(C, self).__init__() print('C.__init__')class D(A): def __init__(self): super().__init__() # super(D, self).__init__() print('D.__init__')class E(C, B, D): def __init__(self): super().__init__() # super(E, self).__init__() print('E.__init__')E.mro()[__main__.E, __main__.C, __main__.B, __main__.D, __main__.A, object]E()B.__init__C.__init__E.__init__&lt;__main__.E at 0x7f6281c9d3c8&gt; 首先执行E.__init__()，遇到super()/super(E, self)，则按照 E.mro() 来查找。找到了 E 的下一个 C。 执行C.__init__()的时候，遇到super()/super(C, self)，还是按照 E.mro() 来查找。找到了 C 的下一个 B。 执行B.__init__()的时候，没有super()，执行完依次返回: B.__init__, C.__init__, E.__init__。 从以上例子，可以很清楚super(type, obj)就是调用厨师 MRO 中type的下一个对象，并绑定到obj去执行。所以，我们可以指定特别的父类type。同时注意，isinstance(obj, type) == True。 上面的例子改一下 E：123456789101112class E(C, B, D): def __init__(self): super(B, self).__init__() print('E.__init__')E.mro()[__main__.E, __main__.C, __main__.B, __main__.D, __main__.A, object]E()A.__init__D.__init__E.__init__&lt;__main__.E at 0x7f6281c9dbe0&gt; 首先执行E.__init__()，遇到super(B, self)，则以 E.mro() 来查找，找到 B 的下一个 D。 执行D.__init__()的时候，遇到super()/super(D, self)，继续以 E.mro() 来查找 D 的下一个 A。 执行A.__init__()，没有super()，执行完，一次返回：A.__init__, D.__init__, E.__init__。 当super(type, type2)的第二个参数为 type 时，issubclass(type2, type)必须为True。用法和super(type, obj)类似。12345678910111213141516class A(object): @classmethod def cmeth(cls): print('A.cmeth')class B(A): @classmethod def cmeth(cls): super().cmeth() # super(B, cls).cmeth() print('B.cmeth')B.mro()[__main__.B, __main__.A, object]B.cmeth()A.cmethB.cmeth Python 3+, super() -&gt; same as super(class, ) tuple()tuple() -&gt; empty tupletuple(iterable) -&gt; tuple initialized from iterable’s items If the argument is a tuple, the return value is the same object. type()type(object) -&gt; the object’s typetype(name, bases, dict) -&gt; a new type type(object): 返回object的类型。 type(name, bases, dict): 创建一个新的对象。实际上，相当于用class创建类的动态格式，A = type(&#39;AName&#39;, (object,), dict(a=0, b=1))。 name，新建对象的名称，相当于__name__。 bases，元组类型，定义新对象继承的基类，即__bases__属性。 dict，字典类型，定义新对象的属性。123456789101112131415161718192021222324252627 class A(object): def __init__(self): self.name = 'lizs' self.age = 18 def a_func(self): pass class B(object): def __init__(self): self.height = 165 self.weight = 138 def b_func(self): passC = type('CName', (A, B), dict(address='China'))C__main__.CNameC.__name__'CName'C.__bases__(__main__.A, __main__.B)C.mro()[__main__.CName, __main__.A, __main__.B, object]dir(C)['__class__', ..., 'address', 'a_func', 'b_func']dir(C())['__class__', ..., 'address', 'age', 'name', 'a_func', 'b_func'] vars([object])vars([object]) -&gt; dictionary Without arguments, equivalent to locals().With an argument, equivalent to object.dict. zip(*iterables) Python2: zip(seq1[, seq2, seq3, …]) -&gt; [(seq1[0], seq2[0], seq3[0], …), (seq1[1], seq2[1], seq3[1], …), …]Python3: zip(iter1[, iterf2, iter3, …]) -&gt; zip object zip 函数将各个参数中相同序列的项组成元组，并返回元组组成的迭代器对象(Python 2返回列表)。当各个参数中元素个数不一致时(len(x))，以最短的参数为标准。 Python 3 中 zip 函数的实现实际上等于：1234567891011def zip(*iterable): sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) Examples:12345678# python 2zip(range(3), range(1, 10))[(0, 1), (1, 2), (2, 3)]# Python 3zip(range(3), range(1, 10))&lt;zip object at 0x...&gt;list(range(3), range(1, 10))[(0, 1), (1, 2), (2, 3)] import(name, globals=None, locals=None, fromlist=(), level=0)导入模块，import语句导入模块的时候就是调用了这个函数。其实想要以编程的方式导入模块，最好用importlib.import_module()。 name: 模块名称。 globals/locals: potentially using the given globals and locals to determine how to interpret the name in a package context. The standard implementation does not use its locals argument at all, and uses its globals only to determine the package context of the import statement. fromlist: list or tuple, the names of objects or submodules that should be imported from the module given by name. level: The level argument is used to determine whether toperform absolute or relative imports: 0 (python3 default value) is absolute, while a positive number is the number of parent directories to search relative to the current module. 12spam = __import__('spam') # &lt;module 'spam' from '/home/...'&gt;spam = __import__('spam.ham') # &lt;module 'spam' from '/home/...'&gt; 注意: 当name为package.module形式的时候，如果fromlist为空，返回的是最顶级的包 (即第一个点左边的包)；如果fromlist不为空，则返回package.module指定的最终模块。12spam = __import__('spam.meat.ham') # &lt;module 'spam' from '...'&gt;ham = __import__('spam.meat.ham', fromlist=('xx',)) # &lt;module 'ham' ...&gt;","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"},{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-12-31T16:00:00.000Z","updated":"2018-09-12T07:47:33.451Z","comments":true,"path":"2017/01/01/hello-world/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"Django tutorial 1","slug":"python/django_tutorial_1","date":"2016-05-31T16:00:00.000Z","updated":"2018-12-07T13:02:14.773Z","comments":true,"path":"2016/06/01/python/django_tutorial_1/","link":"","permalink":"https://lizsgh.github.io/2016/06/01/python/django_tutorial_1/","excerpt":"","text":"Install Django1pip install Django 查看是否安装成功：1python -m django --version Creating a project1django-admin startproject mysite 运行命令将会在当前目录下创建名为mysite的项目，项目名称应避免使用 Python 内置的模块名称或 Django 组件名称，如，django, test等。mysite项目结构如下：1234567mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py mysite：外层mysite目录，只是项目的外壳容器，可以随便重命名，不影响 Django 项目；内层mysite，名称不能更改，因为，当导入这个目录下的内容的时候，会用到这个包名 (如import mysite.urls)。 manage.py：Django 项目管理的命令行工具。详细查看django-admin and manage.py。 mysite/__init__.py：声明 Python 包的空文件。 mysite/settings.py：项目配置文件。详细查看Django settings。 mysite/urls.py：配置项目 URLs 的文件。详细查看URL dispatcher。 mysite/wsgi.py：WSGI 服务器入口文件。 The development server在项目的根目录，即外层mysite目录下，执行：1python manage.py runserver 可以看到：1234567891011Performing system checks...System check identified no issues (0 silenced).You have 15 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.Run 'python manage.py migrate' to apply them.December 06, 2018 - 16:39:26Django version 2.1.3, using settings 'mysite.settings'Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. 现在已经启动了 Django 自带的轻量级的服务器，可以通过地址http://127.0.0.1:8000/来访问。(注意，这个服务器只适合平时开发环境使用。) Changing the port默认情况下，runserver命令使用8000端口。但是，你可以启动服务器的时候指定端口： 1python manage.py runserver 8080 # http://127.0.0.1:8080 Changing the address同样可以指定服务器的访问地址，不过指定地址的时候一定要同时指定端口，如： 1python manage.py runserver 0:8000 # 0.0.0.:8000 0 为地址0.0.0.0的缩写，如果只指定地址会出错，如python manage.py runserver 127.0.0.1。 Creating app项目中的功能需求可以合理地拆分成一个个功能性的 app，同一个 app 可以重用到不同的项目中，一个项目可以包含多个 app。Django 提供了startapp命令创建 Django 项目的基本 app。Django 项目的 app 可以放在 Python 路径的任何地方，不过最好放在项目的根目录下 (即外层mysite目录下) 这样不同 app 之间或者和项目包 (内层mysite) 之间导入的时候，就可以作为高层模块直接导入。也就是说，可以直接import app_name或import mysite。 在项目根目录下 (外层mysite)，执行：1python manage.py startapp polls 成功执行完之后，会在当前目录下生成一个名为polls的 app 包：123456789polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py Write your first view接着编写 polls app 的第一个视图页面。在polls/views.py中编辑：12345from django.http import HttpResponsedef index(request): return HttpResponse(\"Hello, world. You're at the polls index.\") 添加视图到相应 URL，添加 app 的 URL 配置文件polls/urls.py:1234567from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),] 再将 polls 的 URL 配置添加到项目的 URL (mysite/urls.py)中去：12345678from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('polls/', include('polls.urls')), path('admin/', admin.site.urls),] 现在，开启服务器python manage.py runserver，然后访问http://localhost:8000/polls/就可以看到上面编辑的视图内容了。","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://lizsgh.github.io/categories/Python/Django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://lizsgh.github.io/tags/django/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://lizsgh.github.io/categories/Python/Django/"}]}]}