{"meta":{"title":"lizs","subtitle":"www.lizs.cc","description":"www.lizs.cc","author":"lizs","url":"https://lizsgh.github.io"},"pages":[],"posts":[{"title":"Object Oriented Programming","slug":"python/object_oriented_programming","date":"2018-11-22T09:16:42.918Z","updated":"2018-11-22T09:16:42.910Z","comments":true,"path":"2018/11/22/python/object_oriented_programming/","link":"","permalink":"https://lizsgh.github.io/2018/11/22/python/object_oriented_programming/","excerpt":"","text":"OOP (Object Oriented Programming)面向对象的三大基本特征：封装、继承、多态。 封装：把客观事物封装成抽象的类，而且类中特定的属性或方法可以只提供给特定的类或对象使用，从而做到隐蔽性和安全性。 继承：继承可以让新创建的类获得被继承的类的属性和方法。通过继承创建的新类成为“子类”或“派生类”，被继承的类成为“父类”、“基类”或“超类”。继承概念的实现：实现继承和接口继承。 实现继承，是指子类可以直接使用基类的属性和方法； 接口继承，是指基类仅提供了一个接口方法，子类必须先实现了才能够使用。 某些 OOP 语言中，一个子类可以继承多个基类 (多重继承)。 多态：指子类重新定义父类的虚方法 (virtual, abstract)。当子类重新定义了父类的虚方法后，父类根据赋给它的不同子类，动态调用属于子类的该方法。 面向对象的五大基本原则：单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则。 单一职责原则 (SRP, Single Responsibility Principle)：就一个类而言，应该仅有一个引起它变化的原因。简言之，就是一个类的功能要单一。 开放封闭原则 (OCP, Open-Close Principle)：对扩展开放，对修改封闭。 里氏替换原则 (LSP, the Liskov Substitution Principle)：子类应当可以替换父类出现在父类能够出现的任何地方。 依赖倒置原则 (DIP, the Dependency Inversion Principle)：传统结构化编程中，最上层的模块通常要依赖下层模块来实现，即高层依赖底层。DIP 原则就是要让高层不依赖底层，二者都依赖于抽象。抽象不依赖于具体，而具体依赖于抽象。模块间的依赖通过抽象发生，实现类之间不产生直接的依赖关系，而是通过接口或抽象类产生。接口或抽象类不依赖于实现类；实现类依赖于接口或抽象类。 接口隔离原则 (ISP, Interface Segregation Principle)：使用多个专门的接口比使用大一的总接口要好。使用多个专门的接口比使用大一的总接口要好 重载与覆盖重载 (overload)重载，指函数具有相同的函数名，但这些同名函数具有不同的参数列表 (如：参数个数、参数类型、参数顺序等)。返回值可以相同也可以不同。 重载的实现：编译器根据不同的参数表对同名函数的名称做修饰，如：function func(p:integer) -&gt; integer_func； function func(p:string) -&gt; string_func。对编译器而言，这些同名方法就成了不同的方法，而且它们的调用地址在编译期间就绑定了，可以说是“早绑定”或“静态绑定”。 覆盖/重写 (override)覆盖存在类中，子类重写从父类继承过来的函数。但函数名、返回值、参数列表都必须和父类一样。当子类的实例对象调用的时候，会先调用自身的，没有再调用父类的。 如果子类覆盖的是基类的虚函数，则可以实现多态。当子类重新定义基类的虚函数后，基类指针可以根据赋给它的不同子类指针动态的调用子类中的该函数，可以做到动态绑定，即多态。 重载与覆盖 重载要求函数名相同，但是参数列表不同，返回值可以相同也可以不同；覆盖要求函数名、参数列表和返回值都相同。 在类中，重载是同一个类中不同成员函数之间的关系；而覆盖则是子类和基类之间不同成员函数之间的关系。 重载函数的调用是根据参数列表来决定调用哪个函数；覆盖函数的调用则根据对象的不同来决定调用哪个函数。 在类中，函数重载不能够实现多态；而子类对基类虚函数的覆盖则可以实现多态。 多态与重载 多态：基于对抽象方法的覆盖来实现，当子类重新定义基类的虚函数后，基类根据赋给它的不同子类，动态的调用子类中的该函数。多态可以说是“晚绑定”或“动态绑定”。 重载：指函数具有相同的函数名，但这些同名函数具有不同的参数列表。在编译期间就已经绑定调用地址了，是“早绑定”或“静态绑定”。而且，重载只是一种语言特性，一种语法规则，与多态无关，与面向对象也无关。 构造函数与析构函数构造函数：一种特殊的方法，主要用于在创建对象时初始化对象。析构函数：与构造函数相反，当对象结束其生命周期 (如对象所在的函数已调用完毕)，系统自动执行析构函数。 Python 分别用__init__()和__del__()来实现构造函数和析构函数。 OOP - Python 在 Python 中一切都是对象。 Python 支持多重继承，内置函数super()可以解决多重继承中父类方法被多次调用的问题。 Python 并没有覆盖 (override) 的概念，所以严格来说，Python 不支持多态。 12345678910111213141516171819202122232425262728class A(object): def __init__(self): pass def __del__(self): pass def func(self): return 'A.func'class B(A): def func(self, arg=0): return 'B.func'class C(A): passB().func() # B.funcB.func&lt;function __main__.B.func&gt;B().func&lt;bound method B.func of &lt;__main__.B object at 0x7f..&gt;&gt;C().func() # A.funcC.func&lt;function __main__.A.func&gt;C().func&lt;bound method A.func of &lt;__main__.A object at 0x7f...&gt;&gt; Python 中没有覆盖 (override) 的概念，子类重写父类的方法，其实只是把同名函数绑定到不同的函数对象。 为了解决继承结构中接口和实现的问题，可以人为的设计一些规范。 123class A(object): def func(self): raise NotImplementdError 继承A的子类如果要使用func方法就要先实现，不然抛出异常。纵然如此，A还是可以被实例化的，而且无法强制A的子类必须实现func接口。 Python 不支持多态，也不用支持多态，Python 是一种动态语言，崇尚鸭子类型 (duck typing，当看到一只鸟走起来像鸭子、游泳起来像鸭子和叫起来也像鸭子，那么这只鸟就可以被成为鸭子)。鸭子类型不关注对象的类型，而是关注对象的行为 (方法)。鸭子类型像多态一样工作，但是没有继承关系。类与类之间不用共同继承同一个父类，只需要将它们做的像同一种事物，就能够实现：面向接口编程，而不是面向实现编程。 耦合与内聚耦合耦合性，也称块间联系，是软件系统结构中模块间相互关联紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。耦合程度取决于各个模块间接口的复杂程度、调用的方式，以及传递的信息。耦合分为七种： 内容耦合：一个模块直接访问另一个模块的内容。具体表现为： 一个模块直接访问另一个模块的内部数据。 一个模块不通过正常入口而直接转入到另一个模块的内部。 两个模块有一部分代码重叠 (该部分代码具有一定的独立功能)。 一个模块有多个入口。 公共耦合：一组模块都访问同一个公共数据环境。公共数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。 外部耦合：一组模块访问同一全局简单变量而不是同一全局数据结构，而且不通过参数传递该全局变量的信息。 控制耦合：模块之间传递的不是数据信息，而是控制信息 (如，标志、开关量等)，一个模块控制了另一个模块的功能。 标记耦合：调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称特征耦合。标记耦合的模块间传递的不是简单变量，而是像高级语言中的数据名、记录名和文件名等数据结果，这些名字即为标记，其实传递的是地址。 数据耦合：调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的值传递。 非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，非直接耦合的模块独立性最强。 耦合是影响软件复杂程度和设计质量的一个重要因素，为提高模块的独立性，应建立模块间尽可能松散的系统，在设计上我们应采用一下原则：若模块间必须存在耦合，应尽量使用数据耦合，少用控制耦合，慎用或有控制地使用公共耦合，并限制公共耦合的范围，尽量避免内容耦合。 内聚内聚性，又称内联系，指模块的功能强度的度量，即一个模块内容各个元素彼此结合的紧密程度的度量。若一个模块内个元素 (语名之间、程序段之间) 联系的越紧密，则它的内聚性就越高。 所谓高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一职责原则。 内聚有如下分类 (顺序按照内聚度由弱到强)： 偶然内聚：也称巧合内聚，模块内的各部分之间没有联系，或即使有联系也和松散，只是偶然地被凑到一起。 逻辑内聚：把几种相关的功能组合到一起，每次被调用时，由传递给模块的参数来确定该模块应该完成哪种功能。 时间内聚：又称经典内聚，这种模块大多为多功能模块，但模块的各个功能的执行与时间有关，通常要求所有功能必须在同一时间内执行。例如，初始化模块和终止模块。 过程内聚：构件或者操作的组合方式时，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。模块完成多个需要按一定的步骤一次完成的功能。(过程相关—控制耦合)。例如：在用程序流程图设计模块时，若将程序流程图中的一部分划出各自组成模块，便形成过程内聚。 通信内聚：指模块内所有处理元素都在同一个数据结构上操作或所有处理功能都通过公用数据而发生关联 (有时称之为信息内聚)。即指模块内各个组成部分都是用相同的数据或产生相同的数据结构。 顺序内聚：一个模块中各个处理元素和同一个功能密切相关，而且这些处理必须顺序执行，通常一个处理元素的输出是后一个处理元素的输入。顺序内聚的内聚度比较高，但缺点是不如功能内聚易于维护。 功能内聚：模块内所有元素的各个组成部分都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分。即模块仅包括为完成某个功能所必须的所有成分，这些成分紧密联系、缺一不可。 功能内聚是最强的内聚，其优点是功能明确。判断一个模块是否功能内聚，一般从模块名称就能够看出。如果模块名称只有一个动词和一个特定的目标 (单数名词)，一般来说就是功能内聚，如：“计算水费”、“计算产值”等模块。 模块划分时，要遵循“一个模块，一个功能”的原则，尽可能使模块达到功能内聚。","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"Data model","slug":"python/data_model","date":"2018-11-08T07:06:15.150Z","updated":"2018-11-08T07:06:15.142Z","comments":true,"path":"2018/11/08/python/data_model/","link":"","permalink":"https://lizsgh.github.io/2018/11/08/python/data_model/","excerpt":"","text":"Objects, values and typesAll data in a Python program is represented by objects or by relations between objects.Every object has an identity, a type and a value. Python 对象创建之后，identity 是不会变的，你可以将它看成该对象在内存中的地址。 Python 的 is 操作符比较的就是对象的 identity，== 比较的是 value。 Python 的内置函数 id() 可以获取一个整数，代表了该对象的 identity。CPython 和 IPython id() 获取的是内存的地址。 Python 对象的 type 也是不可以改变的，可以用内置函数 type() 获取对象的 type。 Python 对象根据 value 是否可以改变分为：可变对象(mutable)和不可变对象(immutable)。 常见的 mutable 对象：list, dict, bytearray, set, etc；immutable 对象：int, float, complex, str, tuple, bytes, frozeset, etc。 如果 immutable 对象中包含了 mutable 对象，该 mutable 对象的 value 是可变的。如： 123456789101112131415&gt;&gt;&gt; a = []&gt;&gt;&gt; id(a)140537664498648&gt;&gt;&gt; b = (a, 1)&gt;&gt;&gt; b([], 1)&gt;&gt;&gt; id(b)140537664384752&gt;&gt;&gt; a.append(0)&gt;&gt;&gt; b([0], 1)&gt;&gt;&gt; id(a)140537664498648&gt;&gt;&gt; id(b)140537664384752 For immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed. 新建的 immutable 对象可能是已经存在 imutable 对象的一个引用，新建的 mutable 对象是一个新的对象。 123456789101112&gt;&gt;&gt; a = &apos;abcde&apos;&gt;&gt;&gt; b = &apos;abcde&apos;&gt;&gt;&gt; id(a)140537664090832&gt;&gt;&gt; id(b)140537664090832&gt;&gt;&gt; c = []&gt;&gt;&gt; d = []&gt;&gt;&gt; id(c)140537664333368&gt;&gt;&gt; id(d)140537664498648 对于 int 类型的 imutable 对象，值在 -5 - 256 之间的时候，新建对象都是引用。 12345678910111213141516&gt;&gt;&gt; a = -6&gt;&gt;&gt; b = -6&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a = -5&gt;&gt;&gt; b = -5&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a = 256&gt;&gt;&gt; b = 256&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a = 257&gt;&gt;&gt; b = 257&gt;&gt;&gt; a is bFalse 注意：c = d = []，mutable 对象 c 和 d 是引用关系，指向同一个对象。 12345678&gt;&gt;&gt; c = d = []&gt;&gt;&gt; id(c)140537664175712&gt;&gt;&gt; id(d)140537664175712&gt;&gt;&gt; e = c&gt;&gt;&gt; id(e)140537664175712 Python Garbage Collection","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"},{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"HTTP - Basic Authentication","slug":"http/basic_http_authorization","date":"2018-01-31T16:00:00.000Z","updated":"2018-09-12T07:44:44.871Z","comments":true,"path":"2018/02/01/http/basic_http_authorization/","link":"","permalink":"https://lizsgh.github.io/2018/02/01/http/basic_http_authorization/","excerpt":"","text":"HTTP 基本认证中，web 服务器拒绝一个事务，质询客户端，请用户提供有效的用户名和密码。同时，返回 401 状态码，并用 WWW-Authenticate 响应首部指定要访问的安全域(realm)。然后，客户端用 Authorization 请求首部发送经过 base64 加密之后的用户名密码(用户名:密码)给服务器。 Nginx 搭建 HTTP Basic AuthorizationNginx ngx_http_auth_basic_module 可以实现 HTTP Basic Authorization 协议。1234location / &#123; auth_basic &apos;authorization&apos;; auth_basic_user_file conf/htpasswd;&#125; auth_basic: string | off，默认 off，不开启。开启 HTTP Basic Authorization 只需要填写一个字符串，该字符串会作为 realm 的值，在服务器质询客户端的返回头部信息 WWW-Authenticate 中显示，如：WWW-Authenticate: Basic realm=&quot;Authorication&quot;。 auth_basic_user_file: 指定访问的用户名和密码的配置文件，如，htpasswd： 123# commentname1:password1name2:password2:comment 可以用 # 注释 可以设置多个用户名和密码，每行一个，用户名和密码之间用 : 隔开，注释也可以写在密码后面，用 : 隔开。 用户名直接填写，但是密码需要经过加密。如，Linux 系统，密码 123456 可以用 openssl passwd 123456 生成。 假设，刚刚搭建的服务器地址为：127.0.0.1。从浏览器访问 http://127.0.0.1 就会收到一个 401 质询，弹出一个用户名和密码的输入框。用户输入账号和密码之后，浏览器会用 : 将其连接起来，编成 base64 编码，然后将其放在请求头部的 Authorization 中发送给服务端。服务端验证通过后就可以正常浏览页面的内容了。 HTTP 基础认证过程 假如，nginx 配置好的认证页面为 http://127.0.0.1 telnet 建立一条 http 连接 1telnet 127.0.0.1 80 发送正常的请求，会返回 401 12345678910HEAD / HTTP/1.1Host: 172.16.105.114HTTP/1.1 401 UnauthorizedServer: BDSCAN/1.5.0Date: Wed, 17 Jan 2018 08:26:04 GMTContent-Type: text/htmlContent-Length: 195Connection: keep-aliveWWW-Authenticate: Basic realm=&quot;authorization&quot; 发送带验证信息的请求 12345678910111213HEAD / HTTP/1.1Host: 172.16.105.114Authorization: Basic bGl6czoxMjM0NTY=HTTP/1.1 200 OKServer: BDSCAN/1.5.0Date: Wed, 17 Jan 2018 08:26:59 GMTContent-Type: text/htmlContent-Length: 334Last-Modified: Tue, 16 Jan 2018 08:55:10 GMTConnection: keep-aliveETag: &quot;5a5dbdee-14e&quot;Accept-Ranges: bytes 验证信息放在请求头的 Authorization，即 Authorization: Basic base64-username-and-password。base64-username-and-password 为用户名和密码用 : 连接起来，并经过 base64 编码等到的字符串 (即上面的 bGl6czoxMjM0NTY=) 。Python(python2) 生成：12345import base64username = &apos;lizs&apos;password = &apos;123456&apos;msg = base64.b64encode(&apos;%s:%s&apos; % (username, password))","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"https://lizsgh.github.io/tags/http/"}],"keywords":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}]},{"title":"linux command - find","slug":"linux/cmd_find","date":"2017-12-31T16:00:00.000Z","updated":"2018-09-12T08:31:46.194Z","comments":true,"path":"2018/01/01/linux/cmd_find/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/linux/cmd_find/","excerpt":"","text":"findsearch for files in a directory hierarchy 1find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] -H, -L, -P选项 -H, -L, -P 用来控制软连接的处理。 -H: 默认行为，不搜索软连接下的目录或文件。 -L: 搜索软链接。 -P: 不搜索软链接下的目录或文件，除非 当没有指定 -H, -L, -P时，-H 是默认行为，即不搜索软链接下的目录和文件。同时指定多个选项，最后一个有效。如：find -H -L .，-H 无效，-L 有效。 -D debugopts, -Olevel -D debugopts: 打印诊断信息 -Olevel: 允许查询优化，level: 0, 1, 2, 3 starting-point查询开始路径，默认为当前目录 .。 expressionexpression 表达式可以由以下部分组成：tests, actions, global options, positional options, operators。 tests -name pattern按目录名或文件名查找。pattern 不能够有 /，否则无效，如：-name a/b 无效。 123find -name &quot;apps.py&quot; # 查找当前目录下的 apps.py 文件find -name &quot;apps&quot; # 查找当前目录下名称为 apps 的文件或目录find /home -name &quot;app*&quot; # 查找 /home 目录下名称匹配 app* 的文件或目录 -iname patterniname(insensitive name). 用法同 -name，只是 pattern 对大小写不敏感。 -path pattern按路径查找。pattern 是路径。 1234find -path &quot;apps&quot; # 无结果，因为 apps 不是路径find -path &quot;./apps&quot; # 查找当前目录下的 apps 目录或文件find -path &quot;./apps*&quot; # 查找当前目录下路径以 apps 开头的目录或文件find /home -path &quot;*apps*&quot; # 在 /home 目录下查找包含 apps 的目录或文件 -ipath patterninsensitive path, 用法同 -path, 只是 pattern 对大小写不敏感。 -regex pattern和 -path 差不多。 -user uname按照文件或目录所属用户查找。 -group gname按照文件或目录所属组查找。 更多选项查看 find --help 或 man find。 actions -exec command ;对搜索的结果执行命令 command。如果命令是用搜索结果作为参数的，可以用 {} 作为占位符。 12find -path &quot;./apps*&quot; -execfind -path &quot;./apps*&quot; -exec file &#123;&#125; \\; -ok command ;类似 -exec，不过在执行命令 command 之前先要经过用户同意 (y/n) operators (expr)优先操作符，和一般运算的 () 一样。 ! expr取反 expr1 expr2与，即 expr1 和 expr2，相当于 Python 表达式 expr1 and expr2。 expr1 -a expr2同 expr1 expr2 expr1 -and expr2同 expr1 expr2，但是不遵循 POSIX。 expr1 -o expr2或，即 expr1 或 expr2，相当于 Python 表达式 expr1 or expr2。 expr1 -or expr2同 expr1 -o expr2，但是不遵循 POSIX。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"cmd","slug":"cmd","permalink":"https://lizsgh.github.io/tags/cmd/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"Terminal - shortcut","slug":"others/terminal_shortcut","date":"2017-12-31T16:00:00.000Z","updated":"2018-09-12T09:45:42.959Z","comments":true,"path":"2018/01/01/others/terminal_shortcut/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/others/terminal_shortcut/","excerpt":"","text":"Linux 终端窗口快捷键 Ctrl + p: 上一条命令 (相当于向上箭头)。 Ctrl + n: 下一条命令 (相当于向下箭头)。 Ctrl + a: 光标回到命令行开始位置。 Ctrl + e: 光标回到命令行开始位置。 Ctrl + b: 光标向左移动一位。 Ctrl + f: 光标向右移动一位。 Ctrl + h: 删除光标左边的一个字符。 Ctrl + d: 删除光标右边的一个字符。 Ctrl + w: 删除光标左边的一个’单词’字符。 Ctrl + u: 删除光标左边的所有字符。 Ctrl + k: 删除光标右边的所有字符。 Ctrl + l: 清屏。","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"TCP/IP - TCP 三次握手连接和四次握手关闭","slug":"tcp/3-handshake_and_4-waves","date":"2017-12-31T16:00:00.000Z","updated":"2018-09-12T10:04:31.511Z","comments":true,"path":"2018/01/01/tcp/3-handshake_and_4-waves/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/tcp/3-handshake_and_4-waves/","excerpt":"","text":"TCP 首部TCP 数据被封装在 IP 数据报中： TCP 首部数据格式： 每个 TCP 段都包含了源端口号和目的端口号，用于寻找发端和接收端的应用程序。这两个端口号加上 IP 首部的源端 IP 地址和目的端 IP 地址就可以确定一个TCP连接。 序号：sequence number, 用来标识从 TCP 发端向 TCP 收端发送的数据字节流。 确认序号：acknowledgement number, 确认序号只有在 ACK 标志位开启(值为1)时有效，值为要确认的数据包的 sequence number + 1。如客户端发送了一个数据包(序号为x)给服务端，则服务端收到这个数据包之后要回复一个确认数据包(确认序号为x + 1)。 标志位：共有 6 个，每个标志位用 1 和 0 分别表示开和关状态。 URG: The urgent point is valid. ACK: The acknowledgement number is valid. PSH: The receiver should pass this data to the application as soon as possible. RST: Reset the connection. SYN: Synchronize sequence numbers to initiate a connection. FIN: The sender is finished sending data. 每个TCP数据包的格式都是固定的，都包含了端口号，序号，确认序号，标志位等。 三次握手和四次握手TCP 建立连接需要经过三次握手 (three-way handshake)，关闭连接需要经过四次握手。 建立连接的三次握手 第一次，客户端发送一个数据包：TCP首部的标志位SYN被设置为1，并且序号为初始序号ISN(Initial Sequence Number)。 第二次，服务器收到客户端的连接请求后，由标志位SYN为1知道这个是建立TCP连接的请求，返回一个数据包：TCP首部的标志位SYN和ACK都被设置为1；序号为服务器端的ISN；确认序号为客户端序号 + 1。此时，服务器处于 SYN_RCVD 状态。 第三次，客户端收到服务端的返回数据之后，由标志位SYN和ACK为1知道服务器同意建立TCP连接的确认数据包。检查确认序号的值(第一次握手客户端发送的序号 + 1)，标志位SYN和ACK都正确之后，返回一个数据报给服务器：标志位ACK设置为1、序号和确认序号的值为服务器发送过来的序号 + 1。服务器收到这个数据包并检查数据报正确之后，客户端和服务端成功建立TCP连接，进入 ESTABLISHED 状态。 关闭连接的四次握手 第一次，主动关闭的那一端(假设为客户端)发送一个关闭连接FIN数据包：TCP首部的标志位FIN设置为1；序号为正常递增值。此时，客户端进入为 FIN_WAIT_1 状态。 第二次，另一端收到数据包之后，由FIN为1知道这是另一端关闭连接的请求。然后返回一个确认数据包：TCP首部标志位ACK设置为1；确认序号为发端序号 + 1；序号正常递增值。此时，服务器进入 CLOSE_WAIT 状态。当客户端收到确认数据包之后进入 FIN_WAIT_2 状态。 第三次，当服务端发送完数据之后，向客户端发送一个关闭连接数据包：TCP首部的标志位FIN设置为1;序号为正常递增值。此时，服务端进入 LAST_ACK 状态。 第四次，客户端收到数据包之后，由FIN为1知道这是服务端要关闭连接了，然后返回一个确认数据包：TCP首部标志位ACK设置为1；确认序号为收到的序号 + 1；序号为正常递增值。此时，客户端进入 TIME_WAIT 状态。 为什么建立连接是三次握手不是两次握手？关闭连接要四次握手？ 建立连接的时候，当客户端收到服务端的确认信息之后(第二次握手)就已经知道了服务端同意了连接，为什么还要再发送确认数据包给服务端(第三次握手)？ 第三次握手，是对第二次握手的确认。假如不进行第三次握手，服务端发送了SYN的确认数据包之后就直接处于 ESTABLISH 状态。这个确认数据包发送过程中出错，没有发送到给客户端怎么办？所以，一定要进行第三次握手。 关闭TCP连接为什么要四次握手？ TCP连接是全双工的通信，关闭的时候需要每个方向进行单独地关闭。当一端主动请求关闭的时候，被动的一端可能还有数据没有发送完毕，不能够立即关闭，所以不能够同时回复FIN + ACK，只能够先回复ACK数据包(第二次握手)，此时属于半关闭状态。当处理完数据之后，被动关闭的一端再发送FIN包给主动关闭的一端关闭连接。 ISNreference","categories":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://lizsgh.github.io/categories/TCP-IP/"}],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"https://lizsgh.github.io/tags/tcp-ip/"}],"keywords":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://lizsgh.github.io/categories/TCP-IP/"}]},{"title":"git clean","slug":"git/git_clean","date":"2017-02-01T16:00:00.000Z","updated":"2018-09-16T19:46:36.100Z","comments":true,"path":"2017/02/02/git/git_clean/","link":"","permalink":"https://lizsgh.github.io/2017/02/02/git/git_clean/","excerpt":"","text":"使用 Git 版本管理的时候，在常见的 IDE 工具 (如：PyCharm) 上看到未跟踪的文件都会与其它文件是有区别的，如文件名为红色。因此，当想要移除未跟踪的文件的时候会很简单。但是，当项目大并且未跟踪的文件很多分布在各个文件夹里面的时候，或者当没有这些方便的 IDE 工具给你的时候，你想要移除这些未跟踪文件还是很麻烦的。那么有没有方便的方法呢？ 1git-clean - Remove untracked files from the working tree 用法1git clean [-d] [-f] [-i] [-n] [-q] [-e &lt;pattern&gt;] [-x | -X] [--] &lt;path&gt;... git clean 默认从当前目录开始递归移除不在版本管理下的文件，如未跟踪的文件。也可以指定开始的目录 &lt;path&gt;。 git clean 常用参数： -n, --dry-runDon’t actually remove anything, just show what would be done.-n 参数不会真正移除任何东西，仅仅展示当前命令将要做的工作给你看。很有用的一个参数，可以让我们清晰的知道将要移除那些东西。 1234567891011121314# creating a new file test1.py on current clean working tree$ touch test1.py$ git status -s?? test1.py$ git clean -nWould remove test1.py# creating a new directory d1 and a new file test2.py in it$ mkdir d1$ touch d1/test2.py$ git status -s?? d1/?? test1.py$ git clean -nWould remove test1.py 一个很奇怪的现象：当新建一个空目录 (d1)，并在该目录下新建一个文件 (test2.py) 的时候，会发现该文件 (d1/test2.py) 不会被 git clean 移除！怎么回事？ -dRemove untracked directories in addition to untracked files.-d 参数不但会移除未跟踪的文件，还会移除未跟踪的目录。但是，如果未跟踪的目录被其它分支管理的话，将不会被移除。的确要移除只能够用 -f 强制性移除。接着上面的操作来看看： 123$ git clean -ndWould remove d1/Would remove test1.py 可以看到d1文件夹以及里面的内容都将会被移除。注意当文件夹里面有文件被跟踪的时候，这个目录实际上已经被跟踪了。 123456789$ touch d1/test3.py$ git add d1/test3.py$ git status -sA d1/test3.py?? d1/test2.py?? test1.py$ git clean -ndWould remove d1/test2.pyWould remove test1.py -f, --force-f参数会强制性执行移除操作。 -i, --interactiveShow what would be done and clean files interactively.-i会启动一个交互式的操作界面，你可以进一步确定那些东西要移除。 -x-x参数可以删除包括已经被.gitignore文件忽略的文件。接着上面的操作： 12345678910111213141516171819$ touch test4.py d1/test5.py$ git status -sA d1/test3.pyM .gitignore?? d1/test2.py?? d1/test5.py?? test1.py?? test4.py$ cat &lt;&lt;EOF &gt;&gt; .gitignoretest4.pyd1/test5.py$ git clean -n # the .gitignore files won't be removedWould remove d1/test2.pyWould remove test1.py$ git clean -nx # the .gitignore files will be removed tooWould remove d1/test2.pyWould remove d1/test5.pyWould remove test1.pyWould remove test4.py 可以看到git clean是不会移除 .gitignore 忽略的文件的，添加-x参数可以移除.gitignore忽略的文件。 -XRemove only files ignored by Git.仅仅移除被.gitignore文件忽略的文件。接着上面操作： 1234$ git clean -nX...Would remove d1/test5.pyWould remove test4.py","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"git stash","slug":"git/git_stash","date":"2017-01-31T16:00:00.000Z","updated":"2018-09-16T17:56:17.340Z","comments":true,"path":"2017/02/01/git/git_stash/","link":"","permalink":"https://lizsgh.github.io/2017/02/01/git/git_stash/","excerpt":"","text":"情景：工作的时候，你正在项目中属于你的分支下开发一部分功能，但是还没有完善。Leader 突然叫你放下当前的工作，先修改项目中一个非常紧急的 BUG。修 BUG 嘛！家常便饭了。立即切回到上次发布版本(master 最近一次合并)，新建一个分支去修复这个 BUG 。然而，在 checkout 到 master 的时候失败，提示你必须先 commit 当前分支的修改才能够 checkout 到其它分支。问题来了：当前分支的功能只是开发了一部分，不想那么快 commit。不 commit 的话，如果 reset 到前一次 commit 又浪费了之前所做的工作。怎么办？ Git 提供了一个存储机制，用户可以通过git stash或git stash save命令，将修改的跟踪文件与暂存改动存储到一个栈中。 1git stash - Stash the changes in a dirty working directory away 注意，直接git stash或git stash save是不会将未跟踪文件暂存的。所以，当有未跟踪的文件的时候，要先add，或加 -u 参数 如，当前仓库中有文件test1.py和test2.py两个文件而且工作区都是清洁的，然后对test2.py进行修改，并且添加新文件test3.py。1234567891011121314$ git statusOn branch lizsnothing to commit, working tree clean# change test2.py and add test3.py$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py# stashing the work$ git stashSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git status -s?? test3.py # Untracked files won't be stashed 那么，问题又来了。当我们 stash 修改的时候，发现还有文件没有被 stashed，想要将 stash 起来的修改恢复过来，重新 stash。要怎么做呢？ git stash list查看 stashed 的记录 12$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0 git stash apply [&lt;stash&gt;]将存储栈的一条记录重新应用到当前分支，如果不指定&lt;stash&gt;，会默认恢复最近一次 stash 记录存储内容。git stash apply在这里即相当于git stash apply stash@{0}。 1234$ git stash apply$ git status -s M test2.py?? test3.py 打开 test2.py 文件可以看到其内容又回到了 stash 之前的状态了。我们再用 git stash list 查看存储栈的时候，发现刚刚的 stash 记录还在。存储的内容都恢复了，我觉得这条记录没意义了，想要删除了相应的 stash 记录，又要怎么做？ git stash drop [&lt;stash&gt;]删除存储栈的一条 stash 记录。如果不指定&lt;stash&gt;将会默认删除存储栈中最近一次的 stash 记录，git stash drop在这里即相当于git stash drop stash@{0}。 123$ git stash dropDropped refs/stash@&#123;0&#125; (...) $ git stash list # 可以看到最近一次的 stash 记录已经被删除掉了 git stash pop [&lt;stash&gt;]恢复并删除一条 stash 记录的内容。相当于git stash apply和git stash drop命令的结合。用法和git stash apply [&lt;stash&gt;]一样。 总结以上情境中操作：12345678910111213141516171819202122# change test2.py and add test3.py in the clean working tree$ echo \"# hello world\" &gt;&gt; test2.py $ touch test3.py$ git add .$ git status -s M test2.py?? test3.py$ git stashSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean.# checkout to master fix bug$ git checkout master# create a new branch to fix bug$ git checkout -b issue-01# go back wo branch lizs to continue you work after finishing the bug$ git checkout lizs# restore your coding$ git stash pop 注意，恢复存储栈中的内容的时候可能会有冲突需要合并。 git stash --include-untracked或git stash -u将修改的跟踪文件与暂存改动，还有未跟踪的文件存储起来，即相当于先 git add 再 git stash。 123456789101112# change test2.py and add new file test3.py on a clean working tree$ echo \" \" &gt;&gt; test2.py$ touch test3.py $ git status -s M test2.py?? test5.py# stashing the change and untracked file$ git stash -uSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean. git stash save --keep-index和 git stash -u相反，通过git add命令跟踪的文件不存储。注意，--keep-index是git stash save的选项。即，git stash --keep-index是无效的。 1234567891011# change test2.py and add new file test3.py on a clean working tree$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py$ git add -A$ git stash save --keep-indexSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git status -sA test3.py git stash --patchGit 不会直接存储修改过的内容，但是会交互式地提示哪些修改要存储。 git stash branch &lt;branchname&gt; [&lt;stash&gt;]将 stash 的一个记录内容恢复在一个新创建的分支 &lt;branchname&gt; 上。&lt;branchname&gt;，新分支的名称；&lt;stash&gt;，可选，不指定默认为最近一次 stash。 12345678910111213141516171819202122232425262728# change test2.py and add new file test3.py on a clean working tree$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean.# restore the a stash on a new branch$ git stash branch issue-01 Switched to a new branch 'issue-01'On branch issue-01Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: test2.pyUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) test3.pyno changes added to commit (use \"git add\" and/or \"git commit -a\")Dropped refs/stash@&#123;0&#125; (...) 可以看到 git stash branch issue-01用分支 lizs 的一个 stash 记录的内容新建了一个 issue-01 分支，并且会自动删除该 stash 记录，当前位于 issue-01 分支下。那么 lizs 分支会怎么样呢？ 12345$ git checkout lizs$ git status -s M test2.py?? test3.py$ git stash --list # the stash has been dropped 回到 lizs 分支之后，发现用来创建新分支的 stash 的内容居然也恢复在了 lizs 分支！WTF！那这个命令有什么卵用？","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"Git - Basic config","slug":"git/basic_config","date":"2017-01-01T16:00:00.000Z","updated":"2018-09-14T15:37:10.892Z","comments":true,"path":"2017/01/02/git/basic_config/","link":"","permalink":"https://lizsgh.github.io/2017/01/02/git/basic_config/","excerpt":"","text":"初次运行 Git 前的配置 Git 配置文件与命令运行 Git，我们需要先配置下自己的 Git 工作环境。Git 提供了 git config 工具来对 Git 进行配置，也可以通过直接修改 Git 的配置文件： /etc/gitconfig：系统中所有用户普遍使用的配置，用命令git config --system读写的就是这个配置文件。 ~/.gitconfig：当前用户的 Git 配置文件，使用 git config --global 进行的配置保存到这个文件。 .git/config：当前项目下 Git 的配置文件，使用 git config --local 进行配置，这里的配置仅仅针对当前项目有效。 Git 配置文件的优先级别：.git/config &gt; ~/.gitconfig &gt; /etc/gitconfig 配置用户信息12$ git config --global user.name \"lizs\"$ git config --global user.email lizsmail@qq.com 配置完毕之后，我们可以看到~/.gitconfig文件之中多了两行配置：123[user] name = lizs email = lizsmail@qq.com 配置文本编辑器Git 需要你输入一些额外信息的时候，会自动调用一个外部文本编辑器给你用，默认使用系统的默认编辑器。如我我修改提交信息的时候git commit --amend会使用 Ubuntu 系统默认编辑器 nano，使用起来不熟悉。这时候我们可以使用以下方法改变 Git 编辑器： 修改系统编辑器，打开~/.bashrc添加 export EDITOR=vim，然后 source ~/.bashrc。 使用命令 git config --global core.editor vim，修改成功之后，可以在~/.gitconfig文件中多了 core.editor 的配置： 12[core] editor = vim 直接修改 Git 配置文件 .git/config, ~/.gitconfig, /etc/gitconfig。在配置文件添加： 12[core] editor = vim 配置差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。1$ git config --global merge.tool vimdiff Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。 查看配置信息12345678$ git config --listuser.name=lizsuser.email=lizsmail@qq.comcore.editor=vimcore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=true","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"Algorithm - Basic","slug":"algorithm/basic","date":"2016-12-31T16:00:01.000Z","updated":"2018-09-12T07:45:26.526Z","comments":true,"path":"2017/01/01/algorithm/basic/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/algorithm/basic/","excerpt":"","text":"数学基础知识计量单位 B，字节 KB，千字节，2^10 = 1024 B MB，兆字节，2^20 B GB，吉字节，2^30 B 阶乘(factorial)阶乘n!，指从 1 到 n 之间所有整数的乘积，n为大于 0 的整数。如：15! = 1 * 2 * 3 * 4 * 5 特别地，0! = 1。 取模(modulus)取模，指获取整除后的余数。如：15 % 3 = 2 指数幂在数学上，我们把 n 个相同因数 a 相乘的积记做a^n。这种求几个相同因数的积的运算叫做乘方，乘方的结果叫做幂。在a^n中，a叫做底数，n叫做指数。a^n读作：a的n次方，或a的n次幂。 对数在数学中，对数是对求幂的逆运算。如果 N = a^x(a &gt; 0, a != 1)，那么数 x 就叫做以 a 为底 N 的对数(logarithm)，记作 x=logaN。其中，a叫做对数的底数，N叫做真数，x叫做以a为底N的对数。 对数在坐标上过定点 (1, 0)，即 x = 1 时，y = 0。 特别地，以 10 为底的对数称为常用对数(common logarithm)，记为 lg。 以无理数 e(e=2.71828) 为底的对数称为自然对数(natural logarithm)，记为 ln。 零没有对数。 在实数范围内，负数无对数；在复数范围内，负数有对数。 级数级数指将数列的项依次加起来的函数。1∑Un = U1 + U2 + ... + Un 算法分析渐近分析当我们估算一种算法的时间或者其他代价时，经常忽略其系数，只关注其增长率，这称为渐近分析法。准确的说，渐近分析是当输入规模很大，或者达到极限(微积分意义上)时，对一种算法的研究。实践证明忽略这些系数很有用，因此渐近分析也广泛应用于算法比较。 并不是任何情况都能忽略常数。当算法要解决的问题规模 n 很小时，系数就会起到举足轻重的作用。 上限算法运行时间的上限，用来表示该算法可能有的最高增长率。算法有最佳、最差、平均情况下的上限，一般估算最差情况下的上限。 算法增长率的上限，用大 O 表示。如果某种算法的增长率上限(最差情况下)是f(n)，那么就说这种算法“在集合 O(f(n)) 中”，或直接说“在 O(f(n))”中。 下限算法下限，表示最差、最佳、平均情况下的时间下限。用 Ω 表示，读作“大欧米伽”或“欧米伽”。 Θ当算法上限和下限相等时，可用 Θ 表示法，读作“西塔”。 算法最佳、最差、平均情况算法的上(下)限与给定输入规模(如n)的最差(佳)情况不同，上(下)限不是用来确定运行时间(对于给定的n值，即可确定具体的运行时间)的，而是用来确定运行时间的增长率(增长率只能在n值的一个范围内确定)。对于单个点是没有增长率概念的，增长率用于体现伴随输入规模变化的代价变化。 算法的每种输入规模(如n)都存在最佳和最差情况，所以，不要误认为当输入规模尽可能小时出现算法的最佳情况，当输入规模尽可能大时出现算法的最差情况。 理想情况下，当输入规模增大时，可以确定在最佳、最差和平均情况下的增长率。 基本数据结构线性表线性表是由称为元素(element)的数据项组成的一种有限且有序的序列。有序，是指线性表中的每一个元素都有自己的位置。每一个元素也都有一种数据类型。 线性表中不包含任何元素时，称为空表。当前存储的元素数目称为线性表的长度；线性表的开始结点称为表头(head)；结尾结点称为表尾(tail)。 线性表的实现有两种标准方法：顺序表(array-based list 或 sequential list)和链表(linked list)。 顺序表和链表的比较： 顺序表的缺点是大小事先固定，很容易造成空间不足或浪费的情况；优点是对于表中的每个元素没有浪费空间，而链表需要在每个结点上附加一个指针。 链表的优点是只有实际在链表中的对象需要空间，只要存在可用的内存空间分配，链表中的元素个数就没有限制。 一般规律，当线性表元素数目变化较大或者未知时，最好使用链表实现；而如果用户事先知道线性表的大致长度时，使用顺序表的空间效率会更高。 链表的增加/删除操作所需的时间仅为Θ(1)。而顺序表必须将其余的元素向前或向后移动，所需的平均时间和最差时间均为Θ(n)。对于许多应用，插入和删除是最主要的操作，仅就这个原因链表往往比顺序表更好。 链表分为单链表和双链表。双链表存储了两个指针(前驱和后继)，双链表与单链表相比唯一的缺点就是使用更多的空间，双链表的每一个结点需要两个指针。 字典计算机程序一般是用来存储和检索数据的。字典，一个简单的数据库接口，被定义成一个ADT，它提供在数据库中存储、查找和删除记录的功能。 字典用关键码(key)来描述一条数据库记录，并且该关键码是可比的(comparable)。有了这样的关键码，就能够在数据库中顺序地搜索并找出给定关键码值相匹配的记录。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://lizsgh.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://lizsgh.github.io/tags/algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://lizsgh.github.io/categories/Algorithm/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-12-31T16:00:00.000Z","updated":"2018-09-12T07:47:33.451Z","comments":true,"path":"2017/01/01/hello-world/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"lizsgh.github.io","slug":"others/lizsgh.github.io","date":"2016-12-31T16:00:00.000Z","updated":"2018-09-12T08:32:11.774Z","comments":true,"path":"2017/01/01/others/lizsgh.github.io/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/others/lizsgh.github.io/","excerpt":"","text":"Github Pages 和 hexo 搭建个人博客。 Github PagesGithub Pages, Websites for you and your projects. 在 github 上创建名为username.github.io的仓库，其中username为你的 GitHub 账号名称。如我的 GitHub 账号为lizsgh，则创建仓库名为lizsgh.github.io。 在仓库根目录下添加 index.html 页面。这时候，我们登录 http://lizsgh.github.io 就可以看到 index.html 的内容。也就是说，我们可以通过http://lizsgh.github.io来访问这个仓库的静态页面内容。 Jekyll themes。Jekyll 是一个简单的、可扩展的、静态的网站生成器。GitHub Pages 可以选择 Jekyll theme 来作为网站的主题。设置方法：打开仓库，在setting中有一个GitHub Pages的设置选项，其中Theme Chooser可以选择 Jekyll theme 来作为网站的主题。Jekyll 的使用可以看文档：Jekyll Document CNAME。GitHub Pages 还可以让我们自己自定义网站的域名。同样在仓库setting的Github Pages设置选项中有一个Custom domain的选项，可以自定义网站的域名，如 www.lizs.cc。然后，在域名服务商平台将域名解析为 CNAME 类型，值为 lizsgh.github.io。生效之后，就可以通过 www.lizs.cc 来访问了。 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown (或其他渲染引擎) 解析文章，生成静态网页。 个人觉得 Hexo 比 Jekyll 简单好用点，所以抛弃了用 Jekyll theme 来作为 Github Pages 主题。 Hexo 安装前提：Node.js 和 Git。 安装 Hexo 1$ npm install -g hexo-cli 初始化一个 hexo 项目 123$ hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成之后，项目目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 创建文章 1$ hexo new [layout] [title] 如，hexo new test 就会在 source/_posts 目录下生成一篇名为 test.md 的文章。也可以直接在 source/_posts 下新建 test.md 文件来创建文章。 生成静态页面 1$ hexo generate 执行命令会生成一个 public 目录来存放生成的静态页面。如果生成静态页面之前想将之前版本的 public 删除，可以用 hexo clean 命令。 启动本地服务器 1$ hexo server 通过以上命令启动服务器，可以通过 http://localhost:4000/ 地址来访问。 部署到 GitHub Pages 首先，配置 _config.yml 文件 1234deploy: type: git repo: https://github.com/lizsGH/lizsgh.github.io.git branch: master 其中 repo 为你 GitHub Pages 仓库的地址。 然后执行部署命令 1$ hexo deploy 如果出现错误 ERROR Deployer not found: git，则需要安装 hexo-deployer-git 扩展： 1$ npm install hexo-deployer-git --save 自定义域名自定义 GitHub Pages 的域名只需要添加文件 source/CNAME: 1www.lizs.cc 然后，重新部署到 GitHub Pages 即可。 更多详细信息，可以参考 Hexo Document。","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"Python - Built-in functions","slug":"python/builtin_function","date":"2016-12-31T16:00:00.000Z","updated":"2018-11-07T09:45:51.521Z","comments":true,"path":"2017/01/01/python/builtin_function/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/python/builtin_function/","excerpt":"","text":"overview Built-in Functions abs() delattr() hash() memoryview() set() all() dict() help() min() setattr() any() dir() hex() next() slice() ascii() divmod() id() object() sorted() bin() enumerate() input() oct() staticmethod() bool() eval() int() open() str() breakpoint() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() abs(x)返回数值x的绝对值，x可以为：整数和浮点数。如果x是复数，则返回复数的 magnitude，即复数与其共轭复数乘积的正平方根。如：12abs(2 + 2j) # (2 + 2j) * (2 - 2j) 的平方根2.8284271247461903 复数与其共轭复数的乘积运算： (a + bj) * (a - bj) == a ** 2 + b ** 2，因此，abs(a + bj) == math.sqrt(a ** 2 + b ** 2) all(iterable)当iterable中的所有元素为真，或iterable为空时，返回True。 any(iterable)当iterable中有任意一个元素为真时，返回True。 ascii(object)As repr(), return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by repr() using \\x, \\u or \\U escapes. This generates a string similar to that returned by repr() in Python 2. bin(x)将整数x转换为以0b开头的二进制字符串。x为整数或int对象(即该对象必须定义__index__()方法，并返回一个整数)。1234a = bin(3) # '0b11'b = bin(-3) # '-0b11'int(b, base=2)-3 bool([x])根据x的判断值，返回布尔值True或False。如果x为空，返回False。 bool是int的子类，但是，bool不能够被继承，因为bool的实例只有True和False。1234class A(bool): pass TypeError: type 'bool' is not an acceptable base type breakpoint(*args, **kws) New in version 3.7 bytearray([source[, encoding[, errors]]]) bytes([source[, encoding[, errors]]]) callable(object)判断 object 是否是可调用的，返回Ture/False。 callable函数只是检测object是否可调用，不管object调用是否成功。object为可调用对象时，调用的时候也可能调用失败；object为不可调用对象时，调用就一定失败。 1234567891011class A(object): pass class B(object): def __call__(self): return a # global name 'a' is not defined callable(A) # Truecallable(A()) # Falsecallable(B) # Truecallable(B()) # True 类对象都是可调用的，返回一个类实例。但是类的实例对象是否为可调用对象，取决于类是否定义了__call__()方法。 1234callable(int) # Truecallable(int()) # Falsecallable(bool) # Truecallable(bool()) # False New in version 3.2: This function was first removed in Python 3.0 and then brought back in Python 3.2. chr(i)Return a Unicode string of one character with ordinal i (0 &lt;= i &lt;= 0x10ffff).返回 code point i 对应的 Unicode 的字符，0 &lt;= i &lt;= 0x10ffff。与 ord() 函数作用相反。12chr(65) # Aord('A') # 65 @classmethod compile(source, filename, mode, flags=0, dont_inherit=False, optimize=1)将source编译成 code 对象或 AST 对象。编译成的 Code 对象可以被exec或eval函数执行。 source: 可以是字符串、byte 字符串或 AST 对象。注意，source的内容要符合mode。 filename: 字符串类型，读取代码的文件名。如果不是从文件中读取，可以用一些具有标识性的字符串代替，如&#39;&lt;string&gt;&#39;。 mode: 指定代码编译的类型。 &#39;exec&#39;: 如果source是由一系列的 Python 语句组成的。 &#39;eval&#39;: 如果source是一条表达式，编译成的代码对象可以被eval函数执行。 &#39;single&#39;: 如果source由单一的交互式语句组成。(这种情况下，用exec也是可以的，不知道single的实际作用？！) 1234567891011code_object = compile('a = 1; b = a + 1', '&lt;string&gt;', 'exec')exec(code_object)a, b(1, 2)code_object = compile('1 + 1', '&lt;string&gt;', 'eval')eval(code_object)2code_object = compile('name = input(\"Input your name: \")', '&lt;string&gt;', 'single')exec(code_object)Input your name: lizsprint(name) complex([real[, imag]])返回实部real和虚部imag转换成的复数。 real和imag可以是任意的数值类型，如 int, float，complex 等。real还可以是 sting 类型，但imag永远不能够为 string 类型。real和imag的默认值都为 0。返回real + imag * 1j。 12345678910complex(1, 2.1)(1+2.1j) # 1 + 2.1 * 1j = (1+2.1j)complex(1+2j, 2)(1+4j) # (1+2j) + 2 * 1j = (1+4j)complex(1+2j, 2j)(-1 + 2j) # (1+2j) + 2j * 1j = (1+2j) - 2 = (-1+2j)complex(-1.1)(-1.1+0j) # -1.1 + 0 * 1j = (1.1+0j)complex()0j # 0 + 0 * 1j = (0j) 当real为 string 时，real将转换为复数，imag不能有值。 123456complex('1')(1+0j)complex('1.1+1.2j')(1.1+1.2j)complex('1', '2')TypeError: complex() can't take second arg if first is a string 注意，当real为 string 时，real字符串中的+或-操作符前后不能够由空格。 12345678910complex('1 + 2j')ValueError: complex() arg is a malformed string complex('1 - 2j')ValueError: complex() arg is a malformed string complex('1 ')(1+0j)complex(' -2')(-2+0j)complex(' -2j')-2j delattr(object, name)删除对象object中的属性name。object为对象名称；name为对象的属性名称，字符串类型。实际上，delattr(x, &#39;foobar&#39;)相当于del x.foobar。 dict(kws)/dict(mapping, kws)/dict(iterable, **kws)字典的构建函数。 dict(): new empty dictionary dict(mapping): new dictionary initialized from a mapping object’s (key, value) pairs dict(iterable): new dictionary initialized as if via: 123d = &#123;&#125;for k, v in iterable: d[k] = v dict(**kwargs): new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2). dir([object])返回object的有效的属性名称的列表。如果object为空，则返回当前的局部作用域(局部变量)的名称。 dir([object])只是返回属性或变量的名称，locals()和globals()分别返回局部和全局符号表(一种映射关系，存储了键值对的数据结构)。 如果object定义了__dir__()方法，则dir(object)会调用object.__dir__()方法，__dir__()方法必须返回一个列表。 1234567891011class A(object): def __dir__(self): print('hello world') return ['a', 'b', 0] def name(self): return 'lizs'dir(A())hello world['a', 'b', 0] # in this case, just call __dir__() function, and doesn't has 'name' attribute. 如果object没有定义__dir__()方法，dir(object)会从object.__dict__属性，and from its type object. 1234567891011class B(object): def __init__(self): self.__dict__ = &#123;'a': 1, 'b': 2&#125; def c(self): passdir(B())['__class__', '__delattr__', '__dict__', '__doc__', ..., 'a', 'b', 'c']B().a1 dir([object])的默认机制是： 如果object是 Python 模块，则返回该模块的属性名称组成的列表。 如果object是 type 或 class 对象，则返回object的属性名称，和object基类的属性名称。 否则，则返回object的属性名称，object父类的属性名称，和object父类的基类的属性名称组成的列表。 divmod(a, b)divmod(a, b) -&gt; (a // b, a % b) enumerate(iterable, start=0)返回一个枚举对象，iterable必须是一个序列，或一个迭代器，或其它的迭代对象。12345seasons = ['Spring', 'Summer', 'Fall', 'Winter']list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]list(enumerate(seasons, start=1))[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] 相当于：12345def enumerate(sequence, start=0) n = start for elem in sequence: yield n, elem n +=1 eval(expression, globals=None, locals=None)在globals和locals变量的环境下，返回表达式expression执行的值。 expression，可以是字符串，也可以是一个 code objects (如 compile() 创建的 code object)。 globals，字典类型，当globals=None时，默认值为当前环境下的globals()。 locals，任意映射类型，当locals=None时，默认值为当前环境下的locals()。 globals和locals参数只能够通过位置参数传参。 12eval('int()', globals=&#123;'a': 1&#125;)TypeError: eval() takes no keyword arguments 如果globals字典参数中没有__builtins__键，则自动添加__builtins__，其值为builtins模块。 12eval('list(globals().keys()), list(locals().keys())', &#123;&#125;, &#123;&#125;)['__builtins__', &#123;&#125;] 如果只有globals参数，则locals参数的值默认为globals参数的值。 12eval('list(locals().keys())', &#123;'a': 1&#125;)['a', '__builtins__'] 当expression为 code object 时，如果 code object 使用compile()创建时使用了exec作为参数mode的值，则返回None。 1234print(eval(compile('1 + 2', '&lt;string&gt;', 'eval')))3print(eval(compile('1 + 2', '&lt;string&gt;', 'None')))None 注意，print(&quot;hello world&quot;)只是在屏幕输出内容，表达式没有返回值的。 12345678a = print('hello world')hello world # 屏幕输出print(a)None # print 函数的返回值为 Nonea = eval(\"print('hello world')\")hello world # 屏幕输出print(a)None # eval 函数执行完的返回值为 None 当expression为賦值語句(=)时會出錯。 12345eval('a = 1')File \"&lt;string&gt;\", line 1 a = 1 ^SyntaxError: invalid syntax exec(object[, globals[, locals]])与eval相似，eval执行expression并返回执行结果。exec函数会动态执行object，返回None。 object与eval的expression相似，可以是 string 或 code object。但是object可以是动态的 Python 语句，如a = 1; a += 1。这条 Python 如果用eval执行是会报错的。 globals和locals: 用法和eval相同。 Python 2 exec不是函数，而是一个内置语句，不会返回值。 123456# Python 2+a = exec('a = 1; a + 1') File \"&lt;ipython-input-21-1d9129f9ba14&gt;\", line 1 b = exec('a = 1; a + 1') ^SyntaxError: invalid syntax Python 3 exec是内置函数，只返回None。 1234# Python 3+a = exec('1 + 1')print(a)None filter(function, iterable) (Python 2) filter(function or None, sequence) -&gt; list, tuple, or stringReturn those items of sequence for which function(item) is true. If function is None, return the items that are true. If sequence is a tuple or string, return the same type, else return a list. (Python 3) filter(function or None, iterable) –&gt; filter objectReturn an iterator yielding those items of iterable for which function(item) is true. If function is None, return the items that are true. filter函数过滤掉iterable中 item 经过function(item)调用返回不为真的 item。 当function为None时，返回iterable中为真的项。 Python2，返回iterable原来的类型；Python3 返回一个 filter object。 Python 2+: 12345678910111213141516171819filter(int, [0, 1, 2])[1, 2]filter(int, (0, 1, 2))(1, 2)def f(x): print(x) return 65 &lt;= ord(x) &lt;= 90 filter(f, 'abAB')abAB'AB' # filter the 'ab'filter(None, [0, 1, 2])[0, 1, 2]filter(None, (0, 1, 2))(0, 1, 2)filter(None, '012')'012' 当iterable为字符串类型时，会遍历字符串中的每个字符作为 item 传给 function。 Python 3+: 1234567891011121314151617181920r1 = filter(int, [0, 1, 2])print(r1)&lt;filter object at 0x...&gt;list(r1)[0, 1, 2]def func(x): print(x) return 65 &lt;= ord(x) &lt;= 90r2 = filter(func, 'abAB')next(r2)abA'A' # yielding 'A', beause function('A') == True.next(r2)'B'list(filter(None, (0, 1, 2)))[1, 2] float([x])将x转换为浮点数。x可以是 string 或 int。 如果x是 string 类型，x应该是一个十进制数字的字符串，或(inf/Infinity)代表无穷大值，字符串前面可以包含+或-或空格字符。如果没有参数，则返回0.0。123456789101112131415161718float(1)1.0float(1.11)1.11float('1')1.0float('+1.11')1.11float(' -123\\n')-123.0float('1e-003')0.001float(' +1E6')1000000.0float('inf')inf # 正无穷大float('-Infinity')-inf # 负无穷大 format(value[, format_spec])返回value.__format__(format_spec)，format_spec默认值为空字符串。See the Format Specification Mini-Language section of help(‘FORMATTING’) fordetails. forzenset([iterable])创建一个 frozenset 对象。iterable为可迭代对象，如果iterable为空，则创建一个空值的 frozenset 对象。12345678frozenset()frozenset() # an empty frozenset objectfrozenset('abcde')frozenset(&#123;'a', 'b', 'c', 'd', 'e'&#125;)frozenset([0, 1, 2, 'abc'])frozenset(&#123;0, 1, 2, 'abc'&#125;)frozenset(0)TypeError: 'int' object is not iterable getattr(object, name[, default])获取object对象的属性名称为name的值，name必须为字符串类型。即getattr(object, name)相当于object.name。当object.name不存在时，如果指定default的值，则返回default的值；如果不指定default的值，则会引起AttributeError错误。12345678910111213141516class A(object): def __init__(self): self.name = 'lizs' self.age = 18 def address(self): return 'China'getattr(A(), 'name') 'lizs'getattr(A(), 'address')&lt;bound method A.address of &lt;__main__.A object at 0x...&gt;&gt;getattr(A, 'name')AttributeError: type object 'A' has no attribute 'name'getattr(A, 'name', 'lizs')'lizs' globals()返回全局符号表。 hasattr(object, name)判断object对象是否存在属性name，返回True或False。name，字符串类型，属性的名称。e.g. hasattr(People, &#39;age&#39;)相当于People.age。 实际上，hasattr(object, name)调用了getattr(object, name)，然后通过抓取错误来判断是否存在属性。 hash(object)获取object对象的哈希值。哈希值为整数，两个数值比较为相等时，它们的哈希值相同。123456hash(1), hash(1.0), hash(1+0j)(1, 1, 1)1 == 1.0 == 1+0jTrueid(1), id(1.0), id(1+0j)(94326139635240, 94326148389728, 139691410895376) help([object])打印object的帮助文档信息，当没有参数时，启动一个帮助系统的交互界面。 hex(x)将整数x转换为十六进制字符串(以0x开头的小写字母字符串)。1234hex(255)'0xff'hex(-42)'-0x2a' id(object)获取对象的 identity。在对象的生命周期中，identity 是一个具有唯一性的常数。在 CPython 解析器中，identity 就是该对象的内存地址。 input([prompt])从基础输入中读取一行信息，即input()读取到换行符结束。或用户自动出发结束，如Linux系统Ctrl + D。如果提示信息prompt给出，则在基础输出中显示。prompt显示的时候不会自动加换行。1234567input(\"Hi, what is your name: \")Hi, what is your name: lizs # 提示信息不会自动换行，输入信息 'lizs' 会随尾提示后面。'lizs'input(\"Hi, what is your name: \\n\")Hi, what is your name:lizs # input message'lizs' int([x])/int(x, base=10) 当没有参数时，返回 0，即int() == 0。 如果x定义了__int__()，则返回x.__int__()；如果x定义了__trunc__()，则返回x.__trunc__()。 当x为浮点数时，返回整数部分。 12int(1.9)1 当x不是数字的时候，或当指定base的值的时候，x只能是 string, bytes, bytearray 代表的整形字面量(integer literal)。这时x可以以+或-开头，或空格围绕。 12int(' - 101 ') # base=10-101 Python 3+ integer literal definitions: 12345678910integer ::= decinteger | bininteger | octinteger | hexintegerdecinteger ::= nonzerodigit ([\"_\"] digit)* | \"0\"+ ([\"_\"] \"0\")*bininteger ::= \"0\" (\"b\" | \"B\") ([\"_\"] bindigit)+octinteger ::= \"0\" (\"o\" | \"O\") ([\"_\"] octdigit)+hexinteger ::= \"0\" (\"x\" | \"X\") ([\"_\"] hexdigit)+nonzerodigit ::= \"1\"...\"9\"digit ::= \"0\"...\"9\"bindigit ::= \"0\" | \"1\"octdigit ::= \"0\"...\"7\"hexdigit ::= digit | \"a\"...\"f\" | \"A\"...\"F\" Python 2 integer literal definitions: 12345678910longinteger ::= integer (\"l\" | \"L\")integer ::= decimalinteger | octinteger | hexinteger | binintegerdecimalinteger ::= nonzerodigit digit* | \"0\"octinteger ::= \"0\" (\"o\" | \"O\") octdigit+ | \"0\" octdigit+hexinteger ::= \"0\" (\"x\" | \"X\") hexdigit+bininteger ::= \"0\" (\"b\" | \"B\") bindigit+nonzerodigit ::= \"1\"...\"9\"octdigit ::= \"0\"...\"7\"bindigit ::= \"0\" | \"1\"hexdigit ::= digit | \"a\"...\"f\" | \"A\"...\"F\" base表示x的进制数，如int(&#39;101&#39;, 8)表示101是一个八进制的字符串，转换为整数则为：1 8 ** 0 + 0 + 1 8 ** 2 == 65。base的有效值可以为 0 和 2-36。 当base=0时，意味着x按照 integer literal 转换。但 Python 2+ 与 Python 3+ 的integer literal 有些不同，如当x是以 0 开头时在 Python 3+ 是不合法的，但在 Python 2+ 中为 octinteger int(&#39;010&#39;, 0) == int(&#39;010&#39;, 8)。 当base为 2, 8, 16 时，x可以分别以0b/0B, 0o/0O和0x/0X开头。 当base的值大于 10 时，x可以用字母 a-z 或 A-Z 来表示 10 - 35 (注意，字母必须小于base，如当base=12时，x中只能够有字母a和b)。 12345678910111213141516int('101', 8)65int('101', 0) # decinteger101int('0b101', 0) # bininteger5int('0Xa0', 0) # hexinteger160int('a0', 0)ValueError: invalid literal for int() with base 0: 'a0'int('101', 2)5int('0B101', 2)5int('ab1', 12)1573 isinstance(object, classinfo)判断object是否是classinfo的实例，返回True/False。classinfo可以是一个类或一个由若干个类型组成的元组。当classinfo是元组时，只要object属于classinfo中任意一个类型的实例则返回True。123456isinstance(0, object)Trueisinstance(0, (str, int, dict))Trueisinstance(0, ('a', int))TypeError: isinstance() arg 2 must be a type or tuple of types issubclass(class, classinfo)判断class是否是classinfo的子类，返回True/False。classinfo可以是一个类或一个由若干个类组成的元组。当classinfo是元组的时候，只要class属于classinfo中任意一个类的子类则返回True。1234issubclass(int, object)Trueissubclass(int, (str, object, dict))True 与isinstance(object, classinfo)不同，issubclass(class, classinfo)的第一个参数class必须是一个类，并且class认为是其本身的子类。123456issubclass(0, object)TypeError: issubclass() arg 1 must be a classissubclass(int, int)Trueisinstance(int, int)False iter(object[, sentinel]) iter(collection) -&gt; iteratoriter(callable, sentinel) -&gt; iterator 当没有sentinel参数时，第一个参数只能够是 collection 对象，即支持迭代协议(__iter__()方法)和序列协议(__getitem__()方法)。 123i = iter([0, 1, 2])next(i) # 0next(i) # 1 当第二个参数不为空的时候，第一个参数必须是一个可调用对象。创建的迭代器在每次迭代的时候，会调用callable，当调用的返回值为sentinel时停止。 123with open('mydata.txt') as fp: for line in iter(fp.readline, ''): print(line) len(s)获取对象s的长度(元素个数)。12345678len('abc')3len(&#123;'a', 'b', 'c'&#125;)3len(dict(a=0, b=1, c=2))3len(range(10))10 list([iterable])list() -&gt; new empty listlist(iterable) -&gt; new list initialized from iterable’s items locals()获取当前局部符号表，即当前范围的局部变量组成的字典。 map(function, iterable[, iterable, ..]) (Python2.7) Apply function to every item of iterable and return a list of the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. If one iterable is shorter than another it is assumed to be extended with None items. If function is None, the identity function is assumed; if there are multiple arguments, map() returns a list consisting of tuples containing the corresponding items from all iterables (a kind of transpose operation). The iterable arguments may be a sequence or any iterable object; the result is always a list.(Python3+) Return an iterator that applies function to every item of iterable, yielding the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterable stops when the shortest iterable is exhausted. 将function应用于iterable的每一项，返回列表(Python3+，迭代对象)，列表(迭代对象)中的每一项都是function作用后的结果。注意：Python3+ 返回的是迭代对象。 如果有多个iterable，function将并行应用于iterable的每一项。也即是，所有iterable中相同序列的项同时作为参数传递给function运行。如： 12345678map(lambda x, y: x + y, [1, 2, 3], [4, 5, 6])[5, 7, 9] # Python3+ 返回迭代器&lt;map object&gt;map(lambda x: x * x, [1, 2, 3], [4, 5, 6])TypeError: &lt;lambda&gt;() takes exactly 1 argument (2 given)def func(*args): return argsmap(func, [1, 2, 3], [4, 5, 6], [7, 8, 9])[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 当iterable的个数(注意，不是iterable元素个数)与function函数的参数不一致时会出错。如： 12map(lambda x: x * x, [1, 2, 3], [4, 5, 6])TypeError: &lt;lambda&gt;() takes exactly 1 argument (2 given) 当有多个iterable并且iterable的元素数目不一致时：Python2，会以最长的为准，短自动用None补全。Python3+，以最短的为准，迭代完最短的iterable就会自动结束。 12345678def func(*args): return args# Python2.7map(func, [1, 2, 3], [4, 5, 6, 7])[(1, 4), (2, 5), (3, 6), (None, 7)]# Python3+list(map(func, [1, 2, 3], [4, 5, 6, 7]))[(1, 4), (2, 5), (3, 6)] 当function为None 123456# Python2map(None, [1, 2, 3], [4, 5, 6, 7])[(1, 4), (2, 5), (3, 6), (None, 7)]# Python3+list(map(None, [1, 2, 3], [4, 5, 6, 7]))TypeError: 'NoneType' object is not callable max() max(iterable, *[, key=func, default=obj])max(arg1, arg2, *args[, key=func]) 当只有一个位置参数的时候(即第一种模式)，这个参数只能是一个可迭代对象，函数会返回迭代对象中最大的一个元素。如：list, str, tuple 等。 1234max('0123')3max([0, 1, 2, 3])3 如果有两个或两个以上位置参数(即第二种模式)，则返回这些参数中最大的一个。注意，这些位置参数一定要可比较大小的，不然会出错。Python3 两个不同类型之间不可以比较大小。 12345678max(0, 1, 2)2# Python 2+max('a', 1, 2)'a' # 'a' &gt; 2 == True, in python 2# Python 3+max('a', 1, 2)TypeError: '&gt;' not supported between instances of 'str' and 'int' 除了位置参数之外，max()还有 keyword-only 参数key=func。key参数和list.sort()的key参数类似。key参数的值为接收一个参数的函数(如func(x))，iterable中的元素或各个位置参数会作为参数传给func函数处理，max()函数会根据func函数的返回值进行比较取最大值。 12345# Python 3max(['a', 0, 1, 97], key=lambda x: ord(x) if isinstance(x, str) else x)'a'max('a', 0, 98, key=lambda x: ord(x) if isinstance(x, str) else x)98 原本 Python 3+ 是不能够比较 str 和 int 的，但是key参数自动将字符串转换为了整数。同时，当比较的参数中有相同的时候，会返回第一个最大值(ord(&#39;a&#39;) == 97)。 Python 3.4 以上，第一种模式max(iterable, *[, key=func, default=obj])新增了一个 keyword-only 参数 default=obj。default参数可以指定当iterable为空的时候，函数返回的默认值。 12max('', default=1)1 min() min(iterable, *[, key=func, default=obj])min(arg1, arg2, *args[, key=func]) 用法和max()函数一样，功能相反，返回参数中的最小值。 memoryview(object)创建 memoryview 对象。123456789101112a = bytearray(1000000)sys.getsizeof(a)1000057b = memoryview(a)print(b)&lt;memory at 0x...&gt;print(sys.getsizeof(b))192print(b[1])0print(b[1:3])&lt;memory at 0x...&gt; next(iterator[, default])返回迭代器iterator的下一个元素，即调用iterator.__next__()的返回值。next()的第二个参数为iterator遍历结束时返回的默认值，否则当iterator迭代完的时候会引起StopIteration错误。12345678910a = iter(range(2))next(a) # 0next(a) # 1next(a) # StopIterationa = iter(range(3))next(a) # 0next(a, 3) # 1next(a, default=3) # TypeError: next() takes no keyword argumentsnext(a, 3) # 2next(a, 3) # 3 当给出第二个参数的时候，当迭代器迭代完毕的时候会返回这个默认值，而不会引起StopIteration错误。同时，next()的第二个参数是一个位置参数。 oct(x)将整数x转换为以0o开头的八进制字符串。x为整数或int对象(即该对象必须定义__index__()方法，并返回一个整数)。注意，Python 2+ 八进制字符串以0开头。1234oct(3) # 0o3oct(10) # 0o12int('0o12', 8)10 open() open(name[, mode[, buffering]])open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) ord(c)获取 Unicode 单个字符c的 code point。与chr(x)功能相反。1234ord('a')97chr(97)'a' pow(x, y[, z])当只有两个参数时，返回 x ** y；当由三个参数时，返回x ** y % z。 print() Python 2+: print()函数实际上是print表达式。Python 3+: print(value, …, sep=’ ‘, end=’\\n’, file=sys.stdout, flush=False) Python 2+，print()函数实际上是print表达式，所以，是没有关键字参数的，并且，多个位置参数时，是当做元组处理。 1234print('a', 'b')('a', 'b')print('a', 'b', sep='|')SyntaxError: invalid syntax Python 3+，print()函数不是关键字参数都会转换成字符串，并且组成一个由sep连接和end结尾的字符串输出。 sep=&#39; &#39;，关键字参数，表示当有多个位置参数时的连接符，默认值为空格。 end=&#39;\\n&#39;，关键字参数，表示添加到字符串结尾的字符。 file=sys.stdout, 关键字参数，必须是有wirite(string)方法的对象。 flush=False，关键字参数，表示是否刷新缓冲区。 12345print('a', 'b') # a bprint('a', 'b', sep='|') # a|bprint('a', 'b', sep='|', end='===') # a|b===with open('test.py', 'w') as fp: print('#!/usr/bin/env', 'python', file=fp) property(fget=None, fset=None, fdel=None, doc=None)创建一个 property 属性。fget是用来获取该属性值的相关函数，fset用来设置该属性值的函数，fdel是用来删除该属性的函数，doc是一个文档信息字符串。 12345class C(object): def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") 这样便通过property()创建了C对象的属性x。 以上操作也可以同 @property 装饰器更简单地实现：12345678910111213141516class C(object): def __init__(self): self._x = None @property def x(self): \"\"\"I am the 'x' property.\"\"\" return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x range() range(stop)range(start, stop[, step]) Python 2+, range()返回一个列表对象；Python 3+，range()返回的是一个 range 对象。 range()遵循左闭右开原则: [start, stop) 当只有一个参数的时候代表的是 stop，start 默认为 0，即 [0, stop)。 当有两个参数的时候，分别为 start 和 stop，即 [start, stop)。 第三个参数 step 代表步长，默认值为 1，。当 step 为负数的时候，start + step &lt; stop 才有意义。12345678910111213141516# python 2+range(10)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # 左闭右开 [0, 10)range(10, 0)[]range(0, 10, 2)[0, 2, 4, 6, 8]range(0, 10, -2)[]range(10, 0, -2)[10, 8, 6, 4, 2]range(0, -10, -2)[0, -2, -4, -6, -8]# python 3+range(10)range(0, 10) 当 step 为负数的时候，range(10, 0, -2)：12345610 8 # 10 - 26 # 8 - 24 # 6 - 22 # 4 - 20 # 2 - 2，左闭右开原则，舍弃 所以，list(range(10, 0, -2)) == [10, 8, 6, 4, 2]。 repr(object)Return the canonical string representation of the object. For many object types, including most builtins, eval(repr(obj)) == obj. A class can control what this function returns for its instances by defininga __repr__() method. reversed(seq)返回seq反转之后的生成器。123456789a = reversed('abcde')print(a)&lt;reversed at 0x...&gt;next(a)'e'next(a)'d'list(a)['c', 'b', 'a'] round(number[, ndigits])返回number四舍五入之后的结果，第二个参数ndigits表示精度。当没有第二个参数或为None时，返回number四舍五入之后的整数。123456789101112round(0.5)0round(1.5)2round(1.545, 0)2.0round(1.545, 1)1.5round(1.545, 2)1.54 # In python 1.545 actually is 1.5499999...round(1.545000001, 2)1.55 set([iterable])set() -&gt; new empty set objectset(iterable) -&gt; new set object Build an unordered collection of unique elements. setattr(object, name, value)Sets the named attribute on the given object to the specified value.setattr(x, &#39;y&#39;, v) is equivalent to x.y = v slice()slice(stop)slice(start, stop[, step]) Create a slice object. This is used for extended slicing (e.g. a[0:10:2])123456789101112a = &apos;abcdef&apos;s = slice(2)print(s)slice(None, 2, None)s1 = slice(1, 5)print(s1)slice(1, 5, None)s2 = slice(10, 1, -2)print(10, 1, -2)a[s] # &apos;ab&apos;a[s1] # &apos;bcde&apos;a[s2] # &apos;fd&apos; sorted(iterable, *, key=None, reverse=False)返回iterable排序之后的列表。 关键字参数key，与max()，min()和list.sort()中的key参数一样，为只有一个参数的函数。如果指定了key=func，iterable中的每个元素 item 会作为唯一参数传递给func(item)，sorted()函数将根据func(item)的返回值进行比较，值越小越靠前。 关键字参数reverse，布尔值True或False，默认值为False。如果为True则将排序好的列表值反转。 1234sorted(('a', 0, 1, 96, 97, 98), key=lambda x: ord(x) if isinstance(x, str) else x)[0, 1, 96, 'a', 97, 98]sorted('abcde', reverse=True)['e', 'd', 'c', 'b', 'a'] @staticmethodConvert a function to be a static method. str str(object=’’) -&gt; strstr(bytes_or_buffer[, encoding[, errors]]) -&gt; str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object).encoding defaults to sys.getdefaultencoding().errors defaults to ‘strict’. sum(iterable[, start])返回iterable中各个元素的总和。如果，给出第二个参数start，则返回iterable + start的总和。1234sum(range(10))45sum(range(10), 10)55 super()super() -&gt; same as super(class, )super(type) -&gt; unbound super objectsuper(type, obj) -&gt; bound super object; requires isinstance(obj, type)super(type, type2) -&gt; bound super object; requires issubclass(type2, type)Typical use to call a cooperative superclass method:12345678class C(B): def meth(self, arg): super().meth(arg)This works for class methods too:class C(B): @classmethod def cmeth(cls, arg): super().cmeth(arg) Python 的super()函数可以用来调用父类的方法，并且有效解决了多重继承中父类方法被多次调用的问题。123456789101112131415161718192021222324252627class A(object): def __init__(self): print('A.__init__') class B(A): def __init__(self): A.__init__(self) print('B.__init__')class C(A): def __init__(self): A.__init__(self) print('C.__init__')class D(B, C): def __init__(self): B.__init__(self) C.__init__(self) print('D.__init__')D()A.__init__B.__init__A.__init__C.__init__D.__init__&lt;__main__.D at 0x7f7c5c410710&gt; 可以看到A被初始化了两次，这不是我们想要的。super()很完美的解决了这个问题。12345678910111213141516171819202122232425class A(object): def __init__(self): print('A.__init__')class B(A): def __init__(self): super().__init__() # super(B, self).__init__() print('B.__init__')class C(A): def __init__(self): super().__init__() # super(C, self).__init__() print('C.__init__')class D(B, C): def __init__(self): super().__init__() # super(D, self).__init__() print('D.__init__')D()A.__init__C.__init__B.__init__D.__init__&lt;__main__.DD at 0x7f6281c98c18&gt; 这次并没有重复的了，A, B, C, D都是只初始化了一次。super()会根据 MRO (method resolution search order) 来查找。12D.mro()[__main__.D, __main__.B, __main__.C, __main__.A, object] 开始执行D.__init__()的时候，遇到了super()/super(D, self)，则以当前类D (第一个遇到super的类) 的 MRO 来查找。如super(D, self)则查找 MRO 中 D 右侧的下一个对象 B，将 B 的__init__()绑定到当前的self(D()) 执行。 当执行B.__init__()的时候，又遇到了一个super()/super(B, self)，这时候还是以之前的 D.mro() 来查找，找到了 B 的下一个 C，继续执行。 当执行C.__init__()的时候，又遇到了一个super()/super(C, self)，还是以第一次的 D.mro() 来查找，找到了 C 的下一个 A，继续执行。 当执行A.__init__()的时候，没有super()。OK，执行完，依次返回：A.__init__(), C.__init__(), B.__init__(), D.__init__()。 再来看一个对比的例子：123456789101112131415161718192021222324252627282930class A(object): def __init__(self): print('A.__init__')class B(object): def __init__(self): print('B.__init__')class C(A): def __init__(self): super().__init__() # super(C, self).__init__() print('C.__init__')class D(A): def __init__(self): super().__init__() # super(D, self).__init__() print('D.__init__')class E(C, B, D): def __init__(self): super().__init__() # super(E, self).__init__() print('E.__init__')E.mro()[__main__.E, __main__.C, __main__.B, __main__.D, __main__.A, object]E()B.__init__C.__init__E.__init__&lt;__main__.E at 0x7f6281c9d3c8&gt; 首先执行E.__init__()，遇到super()/super(E, self)，则按照 E.mro() 来查找。找到了 E 的下一个 C。 执行C.__init__()的时候，遇到super()/super(C, self)，还是按照 E.mro() 来查找。找到了 C 的下一个 B。 执行B.__init__()的时候，没有super()，执行完依次返回: B.__init__, C.__init__, E.__init__。 从以上例子，可以很清楚super(type, obj)就是调用厨师 MRO 中type的下一个对象，并绑定到obj去执行。所以，我们可以指定特别的父类type。同时注意，isinstance(obj, type) == True。 上面的例子改一下 E：123456789101112class E(C, B, D): def __init__(self): super(B, self).__init__() print('E.__init__')E.mro()[__main__.E, __main__.C, __main__.B, __main__.D, __main__.A, object]E()A.__init__D.__init__E.__init__&lt;__main__.E at 0x7f6281c9dbe0&gt; 首先执行E.__init__()，遇到super(B, self)，则以 E.mro() 来查找，找到 B 的下一个 D。 执行D.__init__()的时候，遇到super()/super(D, self)，继续以 E.mro() 来查找 D 的下一个 A。 执行A.__init__()，没有super()，执行完，一次返回：A.__init__, D.__init__, E.__init__。 当super(type, type2)的第二个参数为 type 时，issubclass(type2, type)必须为True。用法和super(type, obj)类似。12345678910111213141516class A(object): @classmethod def cmeth(cls): print('A.cmeth')class B(A): @classmethod def cmeth(cls): super().cmeth() # super(B, cls).cmeth() print('B.cmeth')B.mro()[__main__.B, __main__.A, object]B.cmeth()A.cmethB.cmeth Python 3+, super() -&gt; same as super(class, ) tuple()tuple() -&gt; empty tupletuple(iterable) -&gt; tuple initialized from iterable’s items If the argument is a tuple, the return value is the same object. type()type(object) -&gt; the object’s typetype(name, bases, dict) -&gt; a new type type(object): 返回object的类型。 type(name, bases, dict): 创建一个新的对象。实际上，相当于用class创建类的动态格式，A = type(&#39;AName&#39;, (object,), dict(a=0, b=1))。 name，新建对象的名称，相当于__name__。 bases，元组类型，定义新对象继承的基类，即__bases__属性。 dict，字典类型，定义新对象的属性。123456789101112131415161718192021222324252627 class A(object): def __init__(self): self.name = 'lizs' self.age = 18 def a_func(self): passclass B(object): def __init__(self): self.height = 165 self.weight = 138 def b_func(self): passC = type('CName', (A, B), dict(address='China'))C__main__.CNameC.__name__'CName'C.__bases__(__main__.A, __main__.B)C.mro()[__main__.CName, __main__.A, __main__.B, object]dir(C)['__class__', ..., 'address', 'a_func', 'b_func']dir(C())['__class__', ..., 'address', 'age', 'name', 'a_func', 'b_func'] vars([object])vars([object]) -&gt; dictionary Without arguments, equivalent to locals().With an argument, equivalent to object.dict. zip(*iterables) Python2: zip(seq1[, seq2, seq3, …]) -&gt; [(seq1[0], seq2[0], seq3[0], …), (seq1[1], seq2[1], seq3[1], …), …]Python3: zip(iter1[, iterf2, iter3, …]) -&gt; zip object zip 函数将各个参数中相同序列的项组成元组，并返回元组组成的迭代器对象(Python 2返回列表)。当各个参数中元素个数不一致时(len(x))，以最短的参数为标准。 Python 3 中 zip 函数的实现实际上等于：1234567891011def zip(*iterable): sentinel = object() iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: elem = next(it, sentinel) if elem is sentinel: return result.append(elem) yield tuple(result) Examples:12345678# python 2zip(range(3), range(1, 10))[(0, 1), (1, 2), (2, 3)]# Python 3zip(range(3), range(1, 10))&lt;zip object at 0x...&gt;list(range(3), range(1, 10))[(0, 1), (1, 2), (2, 3)] import(name, globals=None, locals=None, fromlist=(), level=0)导入模块，import语句导入模块的时候就是调用了这个函数。其实想要以编程的方式导入模块，最好用importlib.import_module()。 name: 模块名称。 globals/locals: potentially using the given globals and locals to determine how to interpret the name in a package context. The standard implementation does not use its locals argument at all, and uses its globals only to determine the package context of the import statement. fromlist: list or tuple, the names of objects or submodules that should be imported from the module given by name. level: The level argument is used to determine whether toperform absolute or relative imports: 0 (python3 default value) is absolute, while a positive number is the number of parent directories to search relative to the current module. 12spam = __import__('spam') # &lt;module 'spam' from '/home/...'&gt;spam = __import__('spam.ham') # &lt;module 'spam' from '/home/...'&gt; 注意: 当name为package.module形式的时候，如果fromlist为空，返回的是最顶级的包 (即第一个点左边的包)；如果fromlist不为空，则返回package.module指定的最终模块。12spam = __import__('spam.meat.ham') # &lt;module 'spam' from '...'&gt;ham = __import__('spam.meat.ham', fromlist=('xx',)) # &lt;module 'ham' ...&gt;","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"},{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]}]}