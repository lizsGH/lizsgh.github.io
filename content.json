{"meta":{"title":"lizs","subtitle":"www.lizs.cc","description":"www.lizs.cc","author":"lizs","url":"https://lizsgh.github.io"},"pages":[],"posts":[{"title":"HTTP - Basic Authentication","slug":"http/basic_http_authorization","date":"2018-01-31T16:00:00.000Z","updated":"2018-09-12T07:44:44.871Z","comments":true,"path":"2018/02/01/http/basic_http_authorization/","link":"","permalink":"https://lizsgh.github.io/2018/02/01/http/basic_http_authorization/","excerpt":"","text":"HTTP 基本认证中，web 服务器拒绝一个事务，质询客户端，请用户提供有效的用户名和密码。同时，返回 401 状态码，并用 WWW-Authenticate 响应首部指定要访问的安全域(realm)。然后，客户端用 Authorization 请求首部发送经过 base64 加密之后的用户名密码(用户名:密码)给服务器。 Nginx 搭建 HTTP Basic AuthorizationNginx ngx_http_auth_basic_module 可以实现 HTTP Basic Authorization 协议。1234location / &#123; auth_basic &apos;authorization&apos;; auth_basic_user_file conf/htpasswd;&#125; auth_basic: string | off，默认 off，不开启。开启 HTTP Basic Authorization 只需要填写一个字符串，该字符串会作为 realm 的值，在服务器质询客户端的返回头部信息 WWW-Authenticate 中显示，如：WWW-Authenticate: Basic realm=&quot;Authorication&quot;。 auth_basic_user_file: 指定访问的用户名和密码的配置文件，如，htpasswd： 123# commentname1:password1name2:password2:comment 可以用 # 注释 可以设置多个用户名和密码，每行一个，用户名和密码之间用 : 隔开，注释也可以写在密码后面，用 : 隔开。 用户名直接填写，但是密码需要经过加密。如，Linux 系统，密码 123456 可以用 openssl passwd 123456 生成。 假设，刚刚搭建的服务器地址为：127.0.0.1。从浏览器访问 http://127.0.0.1 就会收到一个 401 质询，弹出一个用户名和密码的输入框。用户输入账号和密码之后，浏览器会用 : 将其连接起来，编成 base64 编码，然后将其放在请求头部的 Authorization 中发送给服务端。服务端验证通过后就可以正常浏览页面的内容了。 HTTP 基础认证过程 假如，nginx 配置好的认证页面为 http://127.0.0.1 telnet 建立一条 http 连接 1telnet 127.0.0.1 80 发送正常的请求，会返回 401 12345678910HEAD / HTTP/1.1Host: 172.16.105.114HTTP/1.1 401 UnauthorizedServer: BDSCAN/1.5.0Date: Wed, 17 Jan 2018 08:26:04 GMTContent-Type: text/htmlContent-Length: 195Connection: keep-aliveWWW-Authenticate: Basic realm=&quot;authorization&quot; 发送带验证信息的请求 12345678910111213HEAD / HTTP/1.1Host: 172.16.105.114Authorization: Basic bGl6czoxMjM0NTY=HTTP/1.1 200 OKServer: BDSCAN/1.5.0Date: Wed, 17 Jan 2018 08:26:59 GMTContent-Type: text/htmlContent-Length: 334Last-Modified: Tue, 16 Jan 2018 08:55:10 GMTConnection: keep-aliveETag: &quot;5a5dbdee-14e&quot;Accept-Ranges: bytes 验证信息放在请求头的 Authorization，即 Authorization: Basic base64-username-and-password。base64-username-and-password 为用户名和密码用 : 连接起来，并经过 base64 编码等到的字符串 (即上面的 bGl6czoxMjM0NTY=) 。Python(python2) 生成：12345import base64username = &apos;lizs&apos;password = &apos;123456&apos;msg = base64.b64encode(&apos;%s:%s&apos; % (username, password))","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"https://lizsgh.github.io/tags/http/"}],"keywords":[{"name":"HTTP","slug":"HTTP","permalink":"https://lizsgh.github.io/categories/HTTP/"}]},{"title":"TCP/IP - TCP 三次握手连接和四次握手关闭","slug":"tcp/3-handshake_and_4-waves","date":"2017-12-31T16:00:00.000Z","updated":"2018-09-12T10:04:31.511Z","comments":true,"path":"2018/01/01/tcp/3-handshake_and_4-waves/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/tcp/3-handshake_and_4-waves/","excerpt":"","text":"TCP 首部TCP 数据被封装在 IP 数据报中： TCP 首部数据格式： 每个 TCP 段都包含了源端口号和目的端口号，用于寻找发端和接收端的应用程序。这两个端口号加上 IP 首部的源端 IP 地址和目的端 IP 地址就可以确定一个TCP连接。 序号：sequence number, 用来标识从 TCP 发端向 TCP 收端发送的数据字节流。 确认序号：acknowledgement number, 确认序号只有在 ACK 标志位开启(值为1)时有效，值为要确认的数据包的 sequence number + 1。如客户端发送了一个数据包(序号为x)给服务端，则服务端收到这个数据包之后要回复一个确认数据包(确认序号为x + 1)。 标志位：共有 6 个，每个标志位用 1 和 0 分别表示开和关状态。 URG: The urgent point is valid. ACK: The acknowledgement number is valid. PSH: The receiver should pass this data to the application as soon as possible. RST: Reset the connection. SYN: Synchronize sequence numbers to initiate a connection. FIN: The sender is finished sending data. 每个TCP数据包的格式都是固定的，都包含了端口号，序号，确认序号，标志位等。 三次握手和四次握手TCP 建立连接需要经过三次握手 (three-way handshake)，关闭连接需要经过四次握手。 建立连接的三次握手 第一次，客户端发送一个数据包：TCP首部的标志位SYN被设置为1，并且序号为初始序号ISN(Initial Sequence Number)。 第二次，服务器收到客户端的连接请求后，由标志位SYN为1知道这个是建立TCP连接的请求，返回一个数据包：TCP首部的标志位SYN和ACK都被设置为1；序号为服务器端的ISN；确认序号为客户端序号 + 1。此时，服务器处于 SYN_RCVD 状态。 第三次，客户端收到服务端的返回数据之后，由标志位SYN和ACK为1知道服务器同意建立TCP连接的确认数据包。检查确认序号的值(第一次握手客户端发送的序号 + 1)，标志位SYN和ACK都正确之后，返回一个数据报给服务器：标志位ACK设置为1、序号和确认序号的值为服务器发送过来的序号 + 1。服务器收到这个数据包并检查数据报正确之后，客户端和服务端成功建立TCP连接，进入 ESTABLISHED 状态。 关闭连接的四次握手 第一次，主动关闭的那一端(假设为客户端)发送一个关闭连接FIN数据包：TCP首部的标志位FIN设置为1；序号为正常递增值。此时，客户端进入为 FIN_WAIT_1 状态。 第二次，另一端收到数据包之后，由FIN为1知道这是另一端关闭连接的请求。然后返回一个确认数据包：TCP首部标志位ACK设置为1；确认序号为发端序号 + 1；序号正常递增值。此时，服务器进入 CLOSE_WAIT 状态。当客户端收到确认数据包之后进入 FIN_WAIT_2 状态。 第三次，当服务端发送完数据之后，向客户端发送一个关闭连接数据包：TCP首部的标志位FIN设置为1;序号为正常递增值。此时，服务端进入 LAST_ACK 状态。 第四次，客户端收到数据包之后，由FIN为1知道这是服务端要关闭连接了，然后返回一个确认数据包：TCP首部标志位ACK设置为1；确认序号为收到的序号 + 1；序号为正常递增值。此时，客户端进入 TIME_WAIT 状态。 为什么建立连接是三次握手不是两次握手？关闭连接要四次握手？ 建立连接的时候，当客户端收到服务端的确认信息之后(第二次握手)就已经知道了服务端同意了连接，为什么还要再发送确认数据包给服务端(第三次握手)？ 第三次握手，是对第二次握手的确认。假如不进行第三次握手，服务端发送了SYN的确认数据包之后就直接处于 ESTABLISH 状态。这个确认数据包发送过程中出错，没有发送到给客户端怎么办？所以，一定要进行第三次握手。 关闭TCP连接为什么要四次握手？ TCP连接是全双工的通信，关闭的时候需要每个方向进行单独地关闭。当一端主动请求关闭的时候，被动的一端可能还有数据没有发送完毕，不能够立即关闭，所以不能够同时回复FIN + ACK，只能够先回复ACK数据包(第二次握手)，此时属于半关闭状态。当处理完数据之后，被动关闭的一端再发送FIN包给主动关闭的一端关闭连接。 ISNreference","categories":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://lizsgh.github.io/categories/TCP-IP/"}],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"https://lizsgh.github.io/tags/tcp-ip/"}],"keywords":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://lizsgh.github.io/categories/TCP-IP/"}]},{"title":"Terminal - shortcut","slug":"others/terminal_shortcut","date":"2017-12-31T16:00:00.000Z","updated":"2018-09-12T09:45:42.959Z","comments":true,"path":"2018/01/01/others/terminal_shortcut/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/others/terminal_shortcut/","excerpt":"","text":"Linux 终端窗口快捷键 Ctrl + p: 上一条命令 (相当于向上箭头)。 Ctrl + n: 下一条命令 (相当于向下箭头)。 Ctrl + a: 光标回到命令行开始位置。 Ctrl + e: 光标回到命令行开始位置。 Ctrl + b: 光标向左移动一位。 Ctrl + f: 光标向右移动一位。 Ctrl + h: 删除光标左边的一个字符。 Ctrl + d: 删除光标右边的一个字符。 Ctrl + w: 删除光标左边的一个’单词’字符。 Ctrl + u: 删除光标左边的所有字符。 Ctrl + k: 删除光标右边的所有字符。 Ctrl + l: 清屏。","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"linux command - find","slug":"linux/cmd_find","date":"2017-12-31T16:00:00.000Z","updated":"2018-09-12T08:31:46.194Z","comments":true,"path":"2018/01/01/linux/cmd_find/","link":"","permalink":"https://lizsgh.github.io/2018/01/01/linux/cmd_find/","excerpt":"","text":"findsearch for files in a directory hierarchy 1find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] -H, -L, -P选项 -H, -L, -P 用来控制软连接的处理。 -H: 默认行为，不搜索软连接下的目录或文件。 -L: 搜索软链接。 -P: 不搜索软链接下的目录或文件，除非 当没有指定 -H, -L, -P时，-H 是默认行为，即不搜索软链接下的目录和文件。同时指定多个选项，最后一个有效。如：find -H -L .，-H 无效，-L 有效。 -D debugopts, -Olevel -D debugopts: 打印诊断信息 -Olevel: 允许查询优化，level: 0, 1, 2, 3 starting-point查询开始路径，默认为当前目录 .。 expressionexpression 表达式可以由以下部分组成：tests, actions, global options, positional options, operators。 tests -name pattern按目录名或文件名查找。pattern 不能够有 /，否则无效，如：-name a/b 无效。 123find -name &quot;apps.py&quot; # 查找当前目录下的 apps.py 文件find -name &quot;apps&quot; # 查找当前目录下名称为 apps 的文件或目录find /home -name &quot;app*&quot; # 查找 /home 目录下名称匹配 app* 的文件或目录 -iname patterniname(insensitive name). 用法同 -name，只是 pattern 对大小写不敏感。 -path pattern按路径查找。pattern 是路径。 1234find -path &quot;apps&quot; # 无结果，因为 apps 不是路径find -path &quot;./apps&quot; # 查找当前目录下的 apps 目录或文件find -path &quot;./apps*&quot; # 查找当前目录下路径以 apps 开头的目录或文件find /home -path &quot;*apps*&quot; # 在 /home 目录下查找包含 apps 的目录或文件 -ipath patterninsensitive path, 用法同 -path, 只是 pattern 对大小写不敏感。 -regex pattern和 -path 差不多。 -user uname按照文件或目录所属用户查找。 -group gname按照文件或目录所属组查找。 更多选项查看 find --help 或 man find。 actions -exec command ;对搜索的结果执行命令 command。如果命令是用搜索结果作为参数的，可以用 {} 作为占位符。 12find -path &quot;./apps*&quot; -execfind -path &quot;./apps*&quot; -exec file &#123;&#125; \\; -ok command ;类似 -exec，不过在执行命令 command 之前先要经过用户同意 (y/n) operators (expr)优先操作符，和一般运算的 () 一样。 ! expr取反 expr1 expr2与，即 expr1 和 expr2，相当于 Python 表达式 expr1 and expr2。 expr1 -a expr2同 expr1 expr2 expr1 -and expr2同 expr1 expr2，但是不遵循 POSIX。 expr1 -o expr2或，即 expr1 或 expr2，相当于 Python 表达式 expr1 or expr2。 expr1 -or expr2同 expr1 -o expr2，但是不遵循 POSIX。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lizsgh.github.io/tags/linux/"},{"name":"cmd","slug":"cmd","permalink":"https://lizsgh.github.io/tags/cmd/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://lizsgh.github.io/categories/Linux/"}]},{"title":"git clean","slug":"git/git_clean","date":"2017-02-01T16:00:00.000Z","updated":"2018-09-16T19:46:36.100Z","comments":true,"path":"2017/02/02/git/git_clean/","link":"","permalink":"https://lizsgh.github.io/2017/02/02/git/git_clean/","excerpt":"","text":"使用 Git 版本管理的时候，在常见的 IDE 工具 (如：PyCharm) 上看到未跟踪的文件都会与其它文件是有区别的，如文件名为红色。因此，当想要移除未跟踪的文件的时候会很简单。但是，当项目大并且未跟踪的文件很多分布在各个文件夹里面的时候，或者当没有这些方便的 IDE 工具给你的时候，你想要移除这些未跟踪文件还是很麻烦的。那么有没有方便的方法呢？ 1git-clean - Remove untracked files from the working tree 用法1git clean [-d] [-f] [-i] [-n] [-q] [-e &lt;pattern&gt;] [-x | -X] [--] &lt;path&gt;... git clean 默认从当前目录开始递归移除不在版本管理下的文件，如未跟踪的文件。也可以指定开始的目录 &lt;path&gt;。 git clean 常用参数： -n, --dry-runDon’t actually remove anything, just show what would be done.-n 参数不会真正移除任何东西，仅仅展示当前命令将要做的工作给你看。很有用的一个参数，可以让我们清晰的知道将要移除那些东西。 1234567891011121314# creating a new file test1.py on current clean working tree$ touch test1.py$ git status -s?? test1.py$ git clean -nWould remove test1.py# creating a new directory d1 and a new file test2.py in it$ mkdir d1$ touch d1/test2.py$ git status -s?? d1/?? test1.py$ git clean -nWould remove test1.py 一个很奇怪的现象：当新建一个空目录 (d1)，并在该目录下新建一个文件 (test2.py) 的时候，会发现该文件 (d1/test2.py) 不会被 git clean 移除！怎么回事？ -dRemove untracked directories in addition to untracked files.-d 参数不但会移除未跟踪的文件，还会移除未跟踪的目录。但是，如果未跟踪的目录被其它分支管理的话，将不会被移除。的确要移除只能够用 -f 强制性移除。接着上面的操作来看看： 123$ git clean -ndWould remove d1/Would remove test1.py 可以看到d1文件夹以及里面的内容都将会被移除。注意当文件夹里面有文件被跟踪的时候，这个目录实际上已经被跟踪了。 123456789$ touch d1/test3.py$ git add d1/test3.py$ git status -sA d1/test3.py?? d1/test2.py?? test1.py$ git clean -ndWould remove d1/test2.pyWould remove test1.py -f, --force-f参数会强制性执行移除操作。 -i, --interactiveShow what would be done and clean files interactively.-i会启动一个交互式的操作界面，你可以进一步确定那些东西要移除。 -x-x参数可以删除包括已经被.gitignore文件忽略的文件。接着上面的操作： 12345678910111213141516171819$ touch test4.py d1/test5.py$ git status -sA d1/test3.pyM .gitignore?? d1/test2.py?? d1/test5.py?? test1.py?? test4.py$ cat &lt;&lt;EOF &gt;&gt; .gitignoretest4.pyd1/test5.py$ git clean -n # the .gitignore files won't be removedWould remove d1/test2.pyWould remove test1.py$ git clean -nx # the .gitignore files will be removed tooWould remove d1/test2.pyWould remove d1/test5.pyWould remove test1.pyWould remove test4.py 可以看到git clean是不会移除 .gitignore 忽略的文件的，添加-x参数可以移除.gitignore忽略的文件。 -XRemove only files ignored by Git.仅仅移除被.gitignore文件忽略的文件。接着上面操作： 1234$ git clean -nX...Would remove d1/test5.pyWould remove test4.py","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"git stash","slug":"git/git_stash","date":"2017-01-31T16:00:00.000Z","updated":"2018-09-16T17:56:17.340Z","comments":true,"path":"2017/02/01/git/git_stash/","link":"","permalink":"https://lizsgh.github.io/2017/02/01/git/git_stash/","excerpt":"","text":"情景：工作的时候，你正在项目中属于你的分支下开发一部分功能，但是还没有完善。Leader 突然叫你放下当前的工作，先修改项目中一个非常紧急的 BUG。修 BUG 嘛！家常便饭了。立即切回到上次发布版本(master 最近一次合并)，新建一个分支去修复这个 BUG 。然而，在 checkout 到 master 的时候失败，提示你必须先 commit 当前分支的修改才能够 checkout 到其它分支。问题来了：当前分支的功能只是开发了一部分，不想那么快 commit。不 commit 的话，如果 reset 到前一次 commit 又浪费了之前所做的工作。怎么办？ Git 提供了一个存储机制，用户可以通过git stash或git stash save命令，将修改的跟踪文件与暂存改动存储到一个栈中。 1git stash - Stash the changes in a dirty working directory away 注意，直接git stash或git stash save是不会将未跟踪文件暂存的。所以，当有未跟踪的文件的时候，要先add，或加 -u 参数 如，当前仓库中有文件test1.py和test2.py两个文件而且工作区都是清洁的，然后对test2.py进行修改，并且添加新文件test3.py。1234567891011121314$ git statusOn branch lizsnothing to commit, working tree clean# change test2.py and add test3.py$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py# stashing the work$ git stashSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git status -s?? test3.py # Untracked files won't be stashed 那么，问题又来了。当我们 stash 修改的时候，发现还有文件没有被 stashed，想要将 stash 起来的修改恢复过来，重新 stash。要怎么做呢？ git stash list查看 stashed 的记录 12$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0 git stash apply [&lt;stash&gt;]将存储栈的一条记录重新应用到当前分支，如果不指定&lt;stash&gt;，会默认恢复最近一次 stash 记录存储内容。git stash apply在这里即相当于git stash apply stash@{0}。 1234$ git stash apply$ git status -s M test2.py?? test3.py 打开 test2.py 文件可以看到其内容又回到了 stash 之前的状态了。我们再用 git stash list 查看存储栈的时候，发现刚刚的 stash 记录还在。存储的内容都恢复了，我觉得这条记录没意义了，想要删除了相应的 stash 记录，又要怎么做？ git stash drop [&lt;stash&gt;]删除存储栈的一条 stash 记录。如果不指定&lt;stash&gt;将会默认删除存储栈中最近一次的 stash 记录，git stash drop在这里即相当于git stash drop stash@{0}。 123$ git stash dropDropped refs/stash@&#123;0&#125; (...) $ git stash list # 可以看到最近一次的 stash 记录已经被删除掉了 git stash pop [&lt;stash&gt;]恢复并删除一条 stash 记录的内容。相当于git stash apply和git stash drop命令的结合。用法和git stash apply [&lt;stash&gt;]一样。 总结以上情境中操作：12345678910111213141516171819202122# change test2.py and add test3.py in the clean working tree$ echo \"# hello world\" &gt;&gt; test2.py $ touch test3.py$ git add .$ git status -s M test2.py?? test3.py$ git stashSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean.# checkout to master fix bug$ git checkout master# create a new branch to fix bug$ git checkout -b issue-01# go back wo branch lizs to continue you work after finishing the bug$ git checkout lizs# restore your coding$ git stash pop 注意，恢复存储栈中的内容的时候可能会有冲突需要合并。 git stash --include-untracked或git stash -u将修改的跟踪文件与暂存改动，还有未跟踪的文件存储起来，即相当于先 git add 再 git stash。 123456789101112# change test2.py and add new file test3.py on a clean working tree$ echo \" \" &gt;&gt; test2.py$ touch test3.py $ git status -s M test2.py?? test5.py# stashing the change and untracked file$ git stash -uSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean. git stash save --keep-index和 git stash -u相反，通过git add命令跟踪的文件不存储。注意，--keep-index是git stash save的选项。即，git stash --keep-index是无效的。 1234567891011# change test2.py and add new file test3.py on a clean working tree$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py$ git add -A$ git stash save --keep-indexSaved working directory and index state WIP on lizs: 0df0b87 V1.0$ git status -sA test3.py git stash --patchGit 不会直接存储修改过的内容，但是会交互式地提示哪些修改要存储。 git stash branch &lt;branchname&gt; [&lt;stash&gt;]将 stash 的一个记录内容恢复在一个新创建的分支 &lt;branchname&gt; 上。&lt;branchname&gt;，新分支的名称；&lt;stash&gt;，可选，不指定默认为最近一次 stash。 12345678910111213141516171819202122232425262728# change test2.py and add new file test3.py on a clean working tree$ echo \" \" &gt;&gt; test2.py$ touch test3.py$ git status -s M test2.py?? test3.py$ git stash liststash@&#123;0&#125;: WIP on lizs: 0df0b87 V1.0$ git statusOn branch lizsnothing to commit, working tree clean.# restore the a stash on a new branch$ git stash branch issue-01 Switched to a new branch 'issue-01'On branch issue-01Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: test2.pyUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) test3.pyno changes added to commit (use \"git add\" and/or \"git commit -a\")Dropped refs/stash@&#123;0&#125; (...) 可以看到 git stash branch issue-01用分支 lizs 的一个 stash 记录的内容新建了一个 issue-01 分支，并且会自动删除该 stash 记录，当前位于 issue-01 分支下。那么 lizs 分支会怎么样呢？ 12345$ git checkout lizs$ git status -s M test2.py?? test3.py$ git stash --list # the stash has been dropped 回到 lizs 分支之后，发现用来创建新分支的 stash 的内容居然也恢复在了 lizs 分支！WTF！那这个命令有什么卵用？","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"Git - Basic config","slug":"git/basic_config","date":"2017-01-01T16:00:00.000Z","updated":"2018-09-14T15:37:10.892Z","comments":true,"path":"2017/01/02/git/basic_config/","link":"","permalink":"https://lizsgh.github.io/2017/01/02/git/basic_config/","excerpt":"","text":"初次运行 Git 前的配置 Git 配置文件与命令运行 Git，我们需要先配置下自己的 Git 工作环境。Git 提供了 git config 工具来对 Git 进行配置，也可以通过直接修改 Git 的配置文件： /etc/gitconfig：系统中所有用户普遍使用的配置，用命令git config --system读写的就是这个配置文件。 ~/.gitconfig：当前用户的 Git 配置文件，使用 git config --global 进行的配置保存到这个文件。 .git/config：当前项目下 Git 的配置文件，使用 git config --local 进行配置，这里的配置仅仅针对当前项目有效。 Git 配置文件的优先级别：.git/config &gt; ~/.gitconfig &gt; /etc/gitconfig 配置用户信息12$ git config --global user.name \"lizs\"$ git config --global user.email lizsmail@qq.com 配置完毕之后，我们可以看到~/.gitconfig文件之中多了两行配置：123[user] name = lizs email = lizsmail@qq.com 配置文本编辑器Git 需要你输入一些额外信息的时候，会自动调用一个外部文本编辑器给你用，默认使用系统的默认编辑器。如我我修改提交信息的时候git commit --amend会使用 Ubuntu 系统默认编辑器 nano，使用起来不熟悉。这时候我们可以使用以下方法改变 Git 编辑器： 修改系统编辑器，打开~/.bashrc添加 export EDITOR=vim，然后 source ~/.bashrc。 使用命令 git config --global core.editor vim，修改成功之后，可以在~/.gitconfig文件中多了 core.editor 的配置： 12[core] editor = vim 直接修改 Git 配置文件 .git/config, ~/.gitconfig, /etc/gitconfig。在配置文件添加： 12[core] editor = vim 配置差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。1$ git config --global merge.tool vimdiff Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。 查看配置信息12345678$ git config --listuser.name=lizsuser.email=lizsmail@qq.comcore.editor=vimcore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=true","categories":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lizsgh.github.io/tags/git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://lizsgh.github.io/categories/Git/"}]},{"title":"Algorithm - Basic","slug":"algorithm/basic","date":"2016-12-31T16:00:01.000Z","updated":"2018-09-12T07:45:26.526Z","comments":true,"path":"2017/01/01/algorithm/basic/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/algorithm/basic/","excerpt":"","text":"数学基础知识计量单位 B，字节 KB，千字节，2^10 = 1024 B MB，兆字节，2^20 B GB，吉字节，2^30 B 阶乘(factorial)阶乘n!，指从 1 到 n 之间所有整数的乘积，n为大于 0 的整数。如：15! = 1 * 2 * 3 * 4 * 5 特别地，0! = 1。 取模(modulus)取模，指获取整除后的余数。如：15 % 3 = 2 指数幂在数学上，我们把 n 个相同因数 a 相乘的积记做a^n。这种求几个相同因数的积的运算叫做乘方，乘方的结果叫做幂。在a^n中，a叫做底数，n叫做指数。a^n读作：a的n次方，或a的n次幂。 对数在数学中，对数是对求幂的逆运算。如果 N = a^x(a &gt; 0, a != 1)，那么数 x 就叫做以 a 为底 N 的对数(logarithm)，记作 x=logaN。其中，a叫做对数的底数，N叫做真数，x叫做以a为底N的对数。 对数在坐标上过定点 (1, 0)，即 x = 1 时，y = 0。 特别地，以 10 为底的对数称为常用对数(common logarithm)，记为 lg。 以无理数 e(e=2.71828) 为底的对数称为自然对数(natural logarithm)，记为 ln。 零没有对数。 在实数范围内，负数无对数；在复数范围内，负数有对数。 级数级数指将数列的项依次加起来的函数。1∑Un = U1 + U2 + ... + Un 算法分析渐近分析当我们估算一种算法的时间或者其他代价时，经常忽略其系数，只关注其增长率，这称为渐近分析法。准确的说，渐近分析是当输入规模很大，或者达到极限(微积分意义上)时，对一种算法的研究。实践证明忽略这些系数很有用，因此渐近分析也广泛应用于算法比较。 并不是任何情况都能忽略常数。当算法要解决的问题规模 n 很小时，系数就会起到举足轻重的作用。 上限算法运行时间的上限，用来表示该算法可能有的最高增长率。算法有最佳、最差、平均情况下的上限，一般估算最差情况下的上限。 算法增长率的上限，用大 O 表示。如果某种算法的增长率上限(最差情况下)是f(n)，那么就说这种算法“在集合 O(f(n)) 中”，或直接说“在 O(f(n))”中。 下限算法下限，表示最差、最佳、平均情况下的时间下限。用 Ω 表示，读作“大欧米伽”或“欧米伽”。 Θ当算法上限和下限相等时，可用 Θ 表示法，读作“西塔”。 算法最佳、最差、平均情况算法的上(下)限与给定输入规模(如n)的最差(佳)情况不同，上(下)限不是用来确定运行时间(对于给定的n值，即可确定具体的运行时间)的，而是用来确定运行时间的增长率(增长率只能在n值的一个范围内确定)。对于单个点是没有增长率概念的，增长率用于体现伴随输入规模变化的代价变化。 算法的每种输入规模(如n)都存在最佳和最差情况，所以，不要误认为当输入规模尽可能小时出现算法的最佳情况，当输入规模尽可能大时出现算法的最差情况。 理想情况下，当输入规模增大时，可以确定在最佳、最差和平均情况下的增长率。 基本数据结构线性表线性表是由称为元素(element)的数据项组成的一种有限且有序的序列。有序，是指线性表中的每一个元素都有自己的位置。每一个元素也都有一种数据类型。 线性表中不包含任何元素时，称为空表。当前存储的元素数目称为线性表的长度；线性表的开始结点称为表头(head)；结尾结点称为表尾(tail)。 线性表的实现有两种标准方法：顺序表(array-based list 或 sequential list)和链表(linked list)。 顺序表和链表的比较： 顺序表的缺点是大小事先固定，很容易造成空间不足或浪费的情况；优点是对于表中的每个元素没有浪费空间，而链表需要在每个结点上附加一个指针。 链表的优点是只有实际在链表中的对象需要空间，只要存在可用的内存空间分配，链表中的元素个数就没有限制。 一般规律，当线性表元素数目变化较大或者未知时，最好使用链表实现；而如果用户事先知道线性表的大致长度时，使用顺序表的空间效率会更高。 链表的增加/删除操作所需的时间仅为Θ(1)。而顺序表必须将其余的元素向前或向后移动，所需的平均时间和最差时间均为Θ(n)。对于许多应用，插入和删除是最主要的操作，仅就这个原因链表往往比顺序表更好。 链表分为单链表和双链表。双链表存储了两个指针(前驱和后继)，双链表与单链表相比唯一的缺点就是使用更多的空间，双链表的每一个结点需要两个指针。 字典计算机程序一般是用来存储和检索数据的。字典，一个简单的数据库接口，被定义成一个ADT，它提供在数据库中存储、查找和删除记录的功能。 字典用关键码(key)来描述一条数据库记录，并且该关键码是可比的(comparable)。有了这样的关键码，就能够在数据库中顺序地搜索并找出给定关键码值相匹配的记录。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://lizsgh.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://lizsgh.github.io/tags/algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://lizsgh.github.io/categories/Algorithm/"}]},{"title":"lizsgh.github.io","slug":"others/lizsgh.github.io","date":"2016-12-31T16:00:00.000Z","updated":"2018-09-12T08:32:11.774Z","comments":true,"path":"2017/01/01/others/lizsgh.github.io/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/others/lizsgh.github.io/","excerpt":"","text":"Github Pages 和 hexo 搭建个人博客。 Github PagesGithub Pages, Websites for you and your projects. 在 github 上创建名为username.github.io的仓库，其中username为你的 GitHub 账号名称。如我的 GitHub 账号为lizsgh，则创建仓库名为lizsgh.github.io。 在仓库根目录下添加 index.html 页面。这时候，我们登录 http://lizsgh.github.io 就可以看到 index.html 的内容。也就是说，我们可以通过http://lizsgh.github.io来访问这个仓库的静态页面内容。 Jekyll themes。Jekyll 是一个简单的、可扩展的、静态的网站生成器。GitHub Pages 可以选择 Jekyll theme 来作为网站的主题。设置方法：打开仓库，在setting中有一个GitHub Pages的设置选项，其中Theme Chooser可以选择 Jekyll theme 来作为网站的主题。Jekyll 的使用可以看文档：Jekyll Document CNAME。GitHub Pages 还可以让我们自己自定义网站的域名。同样在仓库setting的Github Pages设置选项中有一个Custom domain的选项，可以自定义网站的域名，如 www.lizs.cc。然后，在域名服务商平台将域名解析为 CNAME 类型，值为 lizsgh.github.io。生效之后，就可以通过 www.lizs.cc 来访问了。 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown (或其他渲染引擎) 解析文章，生成静态网页。 个人觉得 Hexo 比 Jekyll 简单好用点，所以抛弃了用 Jekyll theme 来作为 Github Pages 主题。 Hexo 安装前提：Node.js 和 Git。 安装 Hexo 1$ npm install -g hexo-cli 初始化一个 hexo 项目 123$ hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成之后，项目目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 创建文章 1$ hexo new [layout] [title] 如，hexo new test 就会在 source/_posts 目录下生成一篇名为 test.md 的文章。也可以直接在 source/_posts 下新建 test.md 文件来创建文章。 生成静态页面 1$ hexo generate 执行命令会生成一个 public 目录来存放生成的静态页面。如果生成静态页面之前想将之前版本的 public 删除，可以用 hexo clean 命令。 启动本地服务器 1$ hexo server 通过以上命令启动服务器，可以通过 http://localhost:4000/ 地址来访问。 部署到 GitHub Pages 首先，配置 _config.yml 文件 1234deploy: type: git repo: https://github.com/lizsGH/lizsgh.github.io.git branch: master 其中 repo 为你 GitHub Pages 仓库的地址。 然后执行部署命令 1$ hexo deploy 如果出现错误 ERROR Deployer not found: git，则需要安装 hexo-deployer-git 扩展： 1$ npm install hexo-deployer-git --save 自定义域名自定义 GitHub Pages 的域名只需要添加文件 source/CNAME: 1www.lizs.cc 然后，重新部署到 GitHub Pages 即可。 更多详细信息，可以参考 Hexo Document。","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]},{"title":"Python - Built-in functions","slug":"python/builtin_function","date":"2016-12-31T16:00:00.000Z","updated":"2018-09-27T18:02:25.656Z","comments":true,"path":"2017/01/01/python/builtin_function/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/python/builtin_function/","excerpt":"","text":"overview Built-in Functions abs() delattr() hash() memoryview() set() all() dict() help() min() setattr() any() dir() hex() next() slice() ascii() divmod() id() object() sorted() bin() enumerate() input() oct() staticmethod() bool() eval() int() open() str() breakpoint() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() abs(x)返回数值x的绝对值，x可以为：整数和浮点数。如果x是复数，则返回复数的 magnitude，即复数与其共轭复数乘积的正平方根。如：12abs(2 + 2j) # (2 + 2j) * (2 - 2j) 的平方根2.8284271247461903 复数与其共轭复数的乘积运算： (a + bj) * (a - bj) == a ** 2 + b ** 2，因此，abs(a + bj) == math.sqrt(a ** 2 + b ** 2) all(iterable)当iterable中的所有元素为真，或iterable为空时，返回True。 any(iterable)当iterable中有任意一个元素为真时，返回True。 ascii(object)As repr(), return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by repr() using \\x, \\u or \\U escapes. This generates a string similar to that returned by repr() in Python 2. bin(x)将整数x转换为以0b开头的二进制字符串。x为整数或int对象(即该对象必须定义__index__()方法，并返回一个整数)。1234a = bin(3) # '0b11'b = bin(-3) # '-0b11'int(b, base=2)-3 bool([x])根据x的判断值，返回布尔值True或False。如果x为空，返回False。 bool是int的子类，但是，bool不能够被继承，因为bool的实例只有True和False。1234class A(bool): pass TypeError: type 'bool' is not an acceptable base type breakpoint(*args, **kws) New in version 3.7 bytearray([source[, encoding[, errors]]]) bytes([source[, encoding[, errors]]]) callable(object)判断 object 是否是可调用的，返回Ture/False。 callable函数只是检测object是否可调用，不管object调用是否成功。object为可调用对象时，调用的时候也可能调用失败；object为不可调用对象时，调用就一定失败。 1234567891011class A(object): pass class B(object): def __call__(self): return a # global name 'a' is not defined callable(A) # Truecallable(A()) # Falsecallable(B) # Truecallable(B()) # True 类对象都是可调用的，返回一个类实例。但是类的实例对象是否为可调用对象，取决于类是否定义了__call__()方法。 1234callable(int) # Truecallable(int()) # Falsecallable(bool) # Truecallable(bool()) # False New in version 3.2: This function was first removed in Python 3.0 and then brought back in Python 3.2. chr(i)Return a Unicode string of one character with ordinal i (0 &lt;= i &lt;= 0x10ffff).返回 code point i 对应的 Unicode 的字符，0 &lt;= i &lt;= 0x10ffff。与 ord() 函数作用相反。12chr(65) # Aord('A') # 65 @classmethod compile(source, filename, mode, flags=0, dont_inherit=False, optimize=1)将source编译成 code 对象或 AST 对象。编译成的 Code 对象可以被exec或eval函数执行。 source: 可以是字符串、byte 字符串或 AST 对象。注意，source的内容要符合mode。 filename: 字符串类型，读取代码的文件名。如果不是从文件中读取，可以用一些具有标识性的字符串代替，如&#39;&lt;string&gt;&#39;。 mode: 指定代码编译的类型。 &#39;exec&#39;: 如果source是由一系列的 Python 语句组成的。 &#39;eval&#39;: 如果source是一条表达式，编译成的代码对象可以被eval函数执行。 &#39;single&#39;: 如果source由单一的交互式语句组成。(这种情况下，用exec也是可以的，不知道single的实际作用？！) 1234567891011code_object = compile('a = 1; b = a + 1', '&lt;string&gt;', 'exec')exec(code_object)a, b(1, 2)code_object = compile('1 + 1', '&lt;string&gt;', 'eval')eval(code_object)2code_object = compile('name = input(\"Input your name: \")', '&lt;string&gt;', 'single')exec(code_object)Input your name: lizsprint(name) complex([real[, imag]])返回实部real和虚部imag转换成的复数。 real和imag可以是任意的数值类型，如 int, float，complex 等。real还可以是 sting 类型，但imag永远不能够为 string 类型。real和imag的默认值都为 0。返回real + imag * 1j。 12345678910complex(1, 2.1)(1+2.1j) # 1 + 2.1 * 1j = (1+2.1j)complex(1+2j, 2)(1+4j) # (1+2j) + 2 * 1j = (1+4j)complex(1+2j, 2j)(-1 + 2j) # (1+2j) + 2j * 1j = (1+2j) - 2 = (-1+2j)complex(-1.1)(-1.1+0j) # -1.1 + 0 * 1j = (1.1+0j)complex()0j # 0 + 0 * 1j = (0j) 当real为 string 时，real将转换为复数，imag不能有值。 123456complex('1')(1+0j)complex('1.1+1.2j')(1.1+1.2j)complex('1', '2')TypeError: complex() can't take second arg if first is a string 注意，当real为 string 时，real字符串中的+或-操作符前后不能够由空格。 12345678910complex('1 + 2j')ValueError: complex() arg is a malformed string complex('1 - 2j')ValueError: complex() arg is a malformed string complex('1 ')(1+0j)complex(' -2')(-2+0j)complex(' -2j')-2j delattr(object, name)删除对象object中的属性name。object为对象名称；name为对象的属性名称，字符串类型。实际上，delattr(x, &#39;foobar&#39;)相当于del x.foobar。 dict(kws)/dict(mapping, kws)/dict(iterable, **kws)字典的构建函数。 dict(): new empty dictionary dict(mapping): new dictionary initialized from a mapping object’s (key, value) pairs dict(iterable): new dictionary initialized as if via: 123d = &#123;&#125;for k, v in iterable: d[k] = v dict(**kwargs): new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2). dir([object])返回object的有效的属性名称的列表。如果object为空，则返回当前的局部作用域(局部变量)的名称。 dir([object])只是返回属性或变量的名称，locals()和globals()分别返回局部和全局符号表(一种映射关系，存储了键值对的数据结构)。 如果object定义了__dir__()方法，则dir(object)会调用object.__dir__()方法，__dir__()方法必须返回一个列表。 1234567891011class A(object): def __dir__(self): print('hello world') return ['a', 'b', 0] def name(self): return 'lizs'dir(A())hello world['a', 'b', 0] # in this case, just call __dir__() function, and doesn't has 'name' attribute. 如果object没有定义__dir__()方法，dir(object)会从object.__dict__属性，and from its type object. 1234567891011class B(object): def __init__(self): self.__dict__ = &#123;'a': 1, 'b': 2&#125; def c(self): passdir(B())['__class__', '__delattr__', '__dict__', '__doc__', ..., 'a', 'b', 'c']B().a1 dir([object])的默认机制是： 如果object是 Python 模块，则返回该模块的属性名称组成的列表。 如果object是 type 或 class 对象，则返回object的属性名称，和object基类的属性名称。 否则，则返回object的属性名称，object父类的属性名称，和object父类的基类的属性名称组成的列表。 divmod(a, b)divmod(a, b) -&gt; (a // b, a % b) enumerate(iterable, start=0)返回一个枚举对象，iterable必须是一个序列，或一个迭代器，或其它的迭代对象。12345seasons = ['Spring', 'Summer', 'Fall', 'Winter']list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]list(enumerate(seasons, start=1))[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] 相当于：12345def enumerate(sequence, start=0) n = start for elem in sequence: yield n, elem n +=1 eval(expression, globals=None, locals=None)在globals和locals变量的环境下，返回表达式expression执行的值。 expression，可以是字符串，也可以是一个 code objects (如 compile() 创建的 code object)。 globals，字典类型，当globals=None时，默认值为当前环境下的globals()。 locals，任意映射类型，当locals=None时，默认值为当前环境下的locals()。 globals和locals参数只能够通过位置参数传参。 12eval('int()', globals=&#123;'a': 1&#125;)TypeError: eval() takes no keyword arguments 如果globals字典参数中没有__builtins__键，则自动添加__builtins__，其值为builtins模块。 12eval('list(globals().keys()), list(locals().keys())', &#123;&#125;, &#123;&#125;)['__builtins__', &#123;&#125;] 如果只有globals参数，则locals参数的值默认为globals参数的值。 12eval('list(locals().keys())', &#123;'a': 1&#125;)['a', '__builtins__'] 当expression为 code object 时，如果 code object 使用compile()创建时使用了exec作为参数mode的值，则返回None。 1234print(eval(compile('1 + 2', '&lt;string&gt;', 'eval')))3print(eval(compile('1 + 2', '&lt;string&gt;', 'None')))None 注意，print(&quot;hello world&quot;)只是在屏幕输出内容，表达式没有返回值的。 12345678a = print('hello world')hello world # 屏幕输出print(a)None # print 函数的返回值为 Nonea = eval(\"print('hello world')\")hello world # 屏幕输出print(a)None # eval 函数执行完的返回值为 None 当expression为賦值語句(=)时會出錯。 12345eval('a = 1')File \"&lt;string&gt;\", line 1 a = 1 ^SyntaxError: invalid syntax exec(object[, globals[, locals]])与eval相似，eval执行expression并返回执行结果。exec函数会动态执行object，返回None。 object与eval的expression相似，可以是 string 或 code object。但是object可以是动态的 Python 语句，如a = 1; a += 1。这条 Python 如果用eval执行是会报错的。 globals和locals: 用法和eval相同。 Python 2 exec不是函数，而是一个内置语句，不会返回值。 123456# Python 2+a = exec('a = 1; a + 1') File \"&lt;ipython-input-21-1d9129f9ba14&gt;\", line 1 b = exec('a = 1; a + 1') ^SyntaxError: invalid syntax Python 3 exec是内置函数，只返回None。 1234# Python 3+a = exec('1 + 1')print(a)None filter(function, iterable) (Python 2) filter(function or None, sequence) -&gt; list, tuple, or stringReturn those items of sequence for which function(item) is true. If function is None, return the items that are true. If sequence is a tuple or string, return the same type, else return a list. (Python 3) filter(function or None, iterable) –&gt; filter objectReturn an iterator yielding those items of iterable for which function(item) is true. If function is None, return the items that are true. filter函数过滤掉iterable中 item 经过function(item)调用返回不为真的 item。 当function为None时，返回iterable中为真的项。 Python2，返回iterable原来的类型；Python3 返回一个 filter object。 Python 2+: 12345678910111213141516171819filter(int, [0, 1, 2])[1, 2]filter(int, (0, 1, 2))(1, 2)def f(x): print(x) return 65 &lt;= ord(x) &lt;= 90 filter(f, 'abAB')abAB'AB' # filter the 'ab'filter(None, [0, 1, 2])[0, 1, 2]filter(None, (0, 1, 2))(0, 1, 2)filter(None, '012')'012' 当iterable为字符串类型时，会遍历字符串中的每个字符作为 item 传给 function。 Python 3+: 1234567891011121314151617181920r1 = filter(int, [0, 1, 2])print(r1)&lt;filter object at 0x...&gt;list(r1)[0, 1, 2]def func(x): print(x) return 65 &lt;= ord(x) &lt;= 90r2 = filter(func, 'abAB')next(r2)abA'A' # yielding 'A', beause function('A') == True.next(r2)'B'list(filter(None, (0, 1, 2)))[1, 2] float([x])将x转换为浮点数。x可以是 string 或 int。 如果x是 string 类型，x应该是一个十进制数字的字符串，或(inf/Infinity)代表无穷大值，字符串前面可以包含+或-或空格字符。如果没有参数，则返回0.0。123456789101112131415161718float(1)1.0float(1.11)1.11float('1')1.0float('+1.11')1.11float(' -123\\n')-123.0float('1e-003')0.001float(' +1E6')1000000.0float('inf')inf # 正无穷大float('-Infinity')-inf # 负无穷大 format(value[, format_spec])返回value.__format__(format_spec)，format_spec默认值为空字符串。See the Format Specification Mini-Language section of help(‘FORMATTING’) fordetails. forzenset([iterable])创建一个 frozenset 对象。iterable为可迭代对象，如果iterable为空，则创建一个空值的 frozenset 对象。12345678frozenset()frozenset() # an empty frozenset objectfrozenset('abcde')frozenset(&#123;'a', 'b', 'c', 'd', 'e'&#125;)frozenset([0, 1, 2, 'abc'])frozenset(&#123;0, 1, 2, 'abc'&#125;)frozenset(0)TypeError: 'int' object is not iterable getattr(object, name[, default])获取object对象的属性名称为name的值，name必须为字符串类型。即getattr(object, name)相当于object.name。当object.name不存在时，如果指定default的值，则返回default的值；如果不指定default的值，则会引起AttributeError错误。12345678910111213141516class A(object): def __init__(self): self.name = 'lizs' self.age = 18 def address(self): return 'China'getattr(A(), 'name') 'lizs'getattr(A(), 'address')&lt;bound method A.address of &lt;__main__.A object at 0x...&gt;&gt;getattr(A, 'name')AttributeError: type object 'A' has no attribute 'name'getattr(A, 'name', 'lizs')'lizs' globals()返回全局符号表。 hasattr(object, name)判断object对象是否存在属性name，返回True或False。name，字符串类型，属性的名称。e.g. hasattr(People, &#39;age&#39;)相当于People.age。 实际上，hasattr(object, name)调用了getattr(object, name)，然后通过抓取错误来判断是否存在属性。 hash(object)获取object对象的哈希值。哈希值为整数，两个数值比较为相等时，它们的哈希值相同。123456hash(1), hash(1.0), hash(1+0j)(1, 1, 1)1 == 1.0 == 1+0jTrueid(1), id(1.0), id(1+0j)(94326139635240, 94326148389728, 139691410895376) help([object])打印object的帮助文档信息，当没有参数时，启动一个帮助系统的交互界面。 hex(x)将整数x转换为十六进制字符串(以0x开头的小写字母字符串)。1234hex(255)'0xff'hex(-42)'-0x2a' id(object)获取对象的 identity。在对象的生命周期中，identity 是一个具有唯一性的常数。在 CPython 解析器中，identity 就是该对象的内存地址。 input([prompt])从基础输入中读取一行信息，即input()读取到换行符结束。或用户自动出发结束，如Linux系统Ctrl + D。如果提示信息prompt给出，则在基础输出中显示。prompt显示的时候不会自动加换行。1234567input(\"Hi, what is your name: \")Hi, what is your name: lizs # 提示信息不会自动换行，输入信息 'lizs' 会随尾提示后面。'lizs'input(\"Hi, what is your name: \\n\")Hi, what is your name:lizs # input message'lizs' int([x])/int(x, base=10) 当没有参数时，返回 0，即int() == 0。 如果x定义了__int__()，则返回x.__int__()；如果x定义了__trunc__()，则返回x.__trunc__()。 当x为浮点数时，返回整数部分。 12int(1.9)1 当x不是数字的时候，或当指定base的值的时候，x只能是 string, bytes, bytearray 代表的整形字面量(integer literal)。这时x可以以+或-开头，或空格围绕。 12int(' - 101 ') # base=10-101 Python 3+ integer literal definitions: 12345678910integer ::= decinteger | bininteger | octinteger | hexintegerdecinteger ::= nonzerodigit ([\"_\"] digit)* | \"0\"+ ([\"_\"] \"0\")*bininteger ::= \"0\" (\"b\" | \"B\") ([\"_\"] bindigit)+octinteger ::= \"0\" (\"o\" | \"O\") ([\"_\"] octdigit)+hexinteger ::= \"0\" (\"x\" | \"X\") ([\"_\"] hexdigit)+nonzerodigit ::= \"1\"...\"9\"digit ::= \"0\"...\"9\"bindigit ::= \"0\" | \"1\"octdigit ::= \"0\"...\"7\"hexdigit ::= digit | \"a\"...\"f\" | \"A\"...\"F\" Python 2 integer literal definitions: 12345678910longinteger ::= integer (\"l\" | \"L\")integer ::= decimalinteger | octinteger | hexinteger | binintegerdecimalinteger ::= nonzerodigit digit* | \"0\"octinteger ::= \"0\" (\"o\" | \"O\") octdigit+ | \"0\" octdigit+hexinteger ::= \"0\" (\"x\" | \"X\") hexdigit+bininteger ::= \"0\" (\"b\" | \"B\") bindigit+nonzerodigit ::= \"1\"...\"9\"octdigit ::= \"0\"...\"7\"bindigit ::= \"0\" | \"1\"hexdigit ::= digit | \"a\"...\"f\" | \"A\"...\"F\" base表示x的进制数，如int(&#39;101&#39;, 8)表示101是一个八进制的字符串，转换为整数则为：1 8 ** 0 + 0 + 1 8 ** 2 == 65。base的有效值可以为 0 和 2-36。 当base=0时，意味着x按照 integer literal 转换。但 Python 2+ 与 Python 3+ 的integer literal 有些不同，如当x是以 0 开头时在 Python 3+ 是不合法的，但在 Python 2+ 中为 octinteger int(&#39;010&#39;, 0) == int(&#39;010&#39;, 8)。 当base为 2, 8, 16 时，x可以分别以0b/0B, 0o/0O和0x/0X开头。 当base的值大于 10 时，x可以用字母 a-z 或 A-Z 来表示 10 - 35 (注意，字母必须小于base，如当base=12时，x中只能够有字母a和b)。 12345678910111213141516int('101', 8)65int('101', 0) # decinteger101int('0b101', 0) # bininteger5int('0Xa0', 0) # hexinteger160int('a0', 0)ValueError: invalid literal for int() with base 0: 'a0'int('101', 2)5int('0B101', 2)5int('ab1', 12)1573 isinstance(object, classinfo)判断object是否是classinfo的实例，返回True/False。classinfo可以是一个类或一个由若干个类型组成的元组。当classinfo是元组时，只要object属于classinfo中任意一个类型的实例则返回True。123456isinstance(0, object)Trueisinstance(0, (str, int, dict))Trueisinstance(0, ('a', int))TypeError: isinstance() arg 2 must be a type or tuple of types issubclass(class, classinfo)判断class是否是classinfo的子类，返回True/False。classinfo可以是一个类或一个由若干个类组成的元组。当classinfo是元组的时候，只要class属于classinfo中任意一个类的子类则返回True。1234issubclass(int, object)Trueissubclass(int, (str, object, dict))True 与isinstance(object, classinfo)不同，issubclass(class, classinfo)的第一个参数class必须是一个类，并且class认为是其本身的子类。123456issubclass(0, object)TypeError: issubclass() arg 1 must be a classissubclass(int, int)Trueisinstance(int, int)False iter(object[, sentinel]) iter(collection) -&gt; iteratoriter(callable, sentinel) -&gt; iterator 当没有sentinel参数时，第一个参数只能够是 collection 对象，即支持迭代协议(__iter__()方法)和序列协议(__getitem__()方法)。 123i = iter([0, 1, 2])next(i) # 0next(i) # 1 当第二个参数不为空的时候，第一个参数必须是一个可调用对象。创建的迭代器在每次迭代的时候，会调用callable，当调用的返回值为sentinel时停止。 123with open('mydata.txt') as fp: for line in iter(fp.readline, ''): print(line) len(s)获取对象s的长度(元素个数)。12345678len('abc')3len(&#123;'a', 'b', 'c'&#125;)3len(dict(a=0, b=1, c=2))3len(range(10))10 list([iterable])list() -&gt; new empty listlist(iterable) -&gt; new list initialized from iterable’s items locals()获取当前局部符号表，即当前范围的局部变量组成的字典。 map(function, iterable[, iterable, ..]) (Python2.7) Apply function to every item of iterable and return a list of the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. If one iterable is shorter than another it is assumed to be extended with None items. If function is None, the identity function is assumed; if there are multiple arguments, map() returns a list consisting of tuples containing the corresponding items from all iterables (a kind of transpose operation). The iterable arguments may be a sequence or any iterable object; the result is always a list.(Python3+) Return an iterator that applies function to every item of iterable, yielding the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterable stops when the shortest iterable is exhausted. 将function应用于iterable的每一项，返回列表(Python3+，迭代对象)，列表(迭代对象)中的每一项都是function作用后的结果。注意：Python3+ 返回的是迭代对象。 如果有多个iterable，function将并行应用于iterable的每一项。也即是，所有iterable中相同序列的项同时作为参数传递给function运行。如： 12345678map(lambda x, y: x + y, [1, 2, 3], [4, 5, 6])[5, 7, 9] # Python3+ 返回迭代器&lt;map object&gt;map(lambda x: x * x, [1, 2, 3], [4, 5, 6])TypeError: &lt;lambda&gt;() takes exactly 1 argument (2 given)def func(*args): return argsmap(func, [1, 2, 3], [4, 5, 6], [7, 8, 9])[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 当iterable的个数(注意，不是iterable元素个数)与function函数的参数不一致时会出错。如： 12map(lambda x: x * x, [1, 2, 3], [4, 5, 6])TypeError: &lt;lambda&gt;() takes exactly 1 argument (2 given) 当有多个iterable并且iterable的元素数目不一致时：Python2，会以最长的为准，短自动用None补全。Python3+，以最短的为准，迭代完最短的iterable就会自动结束。 12345678def func(*args): return args# Python2.7map(func, [1, 2, 3], [4, 5, 6, 7])[(1, 4), (2, 5), (3, 6), (None, 7)]# Python3+list(map(func, [1, 2, 3], [4, 5, 6, 7]))[(1, 4), (2, 5), (3, 6)] 当function为None 123456# Python2map(None, [1, 2, 3], [4, 5, 6, 7])[(1, 4), (2, 5), (3, 6), (None, 7)]# Python3+list(map(None, [1, 2, 3], [4, 5, 6, 7]))TypeError: 'NoneType' object is not callable max() max(iterable, *[, key=func, default=obj])max(arg1, arg2, *args[, key=func]) 当只有一个位置参数的时候(即第一种模式)，这个参数只能是一个可迭代对象，函数会返回迭代对象中最大的一个元素。如：list, str, tuple 等。 1234max('0123')3max([0, 1, 2, 3])3 如果有两个或两个以上位置参数(即第二种模式)，则返回这些参数中最大的一个。注意，这些位置参数一定要可比较大小的，不然会出错。Python3 两个不同类型之间不可以比较大小。 12345678max(0, 1, 2)2# Python 2+max('a', 1, 2)'a' # 'a' &gt; 2 == True, in python 2# Python 3+max('a', 1, 2)TypeError: '&gt;' not supported between instances of 'str' and 'int' 除了位置参数之外，max()还有 keyword-only 参数key=func。key参数和list.sort()的key参数类似。key参数的值为接收一个参数的函数(如func(x))，iterable中的元素或各个位置参数会作为参数传给func函数处理，max()函数会根据func函数的返回值进行比较取最大值。 12345# Python 3max(['a', 0, 1, 97], key=lambda x: ord(x) if isinstance(x, str) else x)'a'max('a', 0, 98, key=lambda x: ord(x) if isinstance(x, str) else x)98 原本 Python 3+ 是不能够比较 str 和 int 的，但是key参数自动将字符串转换为了整数。同时，当比较的参数中有相同的时候，会返回第一个最大值(ord(&#39;a&#39;) == 97)。 Python 3.4 以上，第一种模式max(iterable, *[, key=func, default=obj])新增了一个 keyword-only 参数 default=obj。default参数可以指定当iterable为空的时候，函数返回的默认值。 12max('', default=1)1 min() min(iterable, *[, key=func, default=obj])min(arg1, arg2, *args[, key=func]) 用法和max()函数一样，功能相反，返回参数中的最小值。 memoryview(object)创建 memoryview 对象。123456789101112a = bytearray(1000000)sys.getsizeof(a)1000057b = memoryview(a)print(b)&lt;memory at 0x...&gt;print(sys.getsizeof(b))192print(b[1])0print(b[1:3])&lt;memory at 0x...&gt; next(iterator[, default])返回迭代器iterator的下一个元素，即调用iterator.__next__()的返回值。next()的第二个参数为iterator遍历结束时返回的默认值，否则当iterator迭代完的时候会引起StopIteration错误。12345678910a = iter(range(2))next(a) # 0next(a) # 1next(a) # StopIterationa = iter(range(3))next(a) # 0next(a, 3) # 1next(a, default=3) # TypeError: next() takes no keyword argumentsnext(a, 3) # 2next(a, 3) # 3 当给出第二个参数的时候，当迭代器迭代完毕的时候会返回这个默认值，而不会引起StopIteration错误。同时，next()的第二个参数是一个位置参数。 oct(x)将整数x转换为以0o开头的八进制字符串。x为整数或int对象(即该对象必须定义__index__()方法，并返回一个整数)。注意，Python 2+ 八进制字符串以0开头。1234oct(3) # 0o3oct(10) # 0o12int('0o12', 8)10 open() open(name[, mode[, buffering]])open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) ord(c)获取 Unicode 单个字符c的 code point。与chr(x)功能相反。1234ord('a')97chr(97)'a' pow(x, y[, z])当只有两个参数时，返回 x ** y；当由三个参数时，返回x ** y % z。 print() Python 2+: print()函数实际上是print表达式。Python 3+: print(value, …, sep=’ ‘, end=’\\n’, file=sys.stdout, flush=False) Python 2+，print()函数实际上是print表达式，所以，是没有关键字参数的，并且，多个位置参数时，是当做元组处理。 1234print('a', 'b')('a', 'b')print('a', 'b', sep='|')SyntaxError: invalid syntax Python 3+，print()函数不是关键字参数都会转换成字符串，并且组成一个由sep连接和end结尾的字符串输出。 sep=&#39; &#39;，关键字参数，表示当有多个位置参数时的连接符，默认值为空格。 end=&#39;\\n&#39;，关键字参数，表示添加到字符串结尾的字符。 file=sys.stdout, 关键字参数，必须是有wirite(string)方法的对象。 flush=False，关键字参数，表示是否刷新缓冲区。 12345print('a', 'b') # a bprint('a', 'b', sep='|') # a|bprint('a', 'b', sep='|', end='===') # a|b===with open('test.py', 'w') as fp: print('#!/usr/bin/env', 'python', file=fp) property(fget=None, fset=None, fdel=None, doc=None)创建一个 property 属性。fget是用来获取该属性值的相关函数，fset用来设置该属性值的函数，fdel是用来删除该属性的函数，doc是一个文档信息字符串。 12345class C(object): def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") 这样便通过property()创建了C对象的属性x。 以上操作也可以同 @property 装饰器更简单地实现：12345678910111213141516class C(object): def __init__(self): self._x = None @property def x(self): \"\"\"I am the 'x' property.\"\"\" return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x range() range(stop)range(start, stop[, step]) Python 2+, range()返回一个列表对象；Python 3+，range()返回的是一个 range 对象。","categories":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lizsgh.github.io/tags/python/"},{"name":"tutorial","slug":"tutorial","permalink":"https://lizsgh.github.io/tags/tutorial/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://lizsgh.github.io/categories/Python/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-12-31T16:00:00.000Z","updated":"2018-09-12T07:47:33.451Z","comments":true,"path":"2017/01/01/hello-world/","link":"","permalink":"https://lizsgh.github.io/2017/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://lizsgh.github.io/tags/other/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://lizsgh.github.io/categories/Other/"}]}]}